(window["webpackJsonp"] = window["webpackJsonp"] || []).push([
  [22],
  Array(343).concat([
    /* 343 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;
      /**
       * String of the current PIXI version.
       *
       * @static
       * @constant
       * @memberof PIXI
       * @name VERSION
       * @type {string}
       */
      let VERSION = (exports.VERSION = "4.8.9");

      /**
       * Two Pi.
       *
       * @static
       * @constant
       * @memberof PIXI
       * @type {number}
       */
      let PI_2 = (exports.PI_2 = Math.PI * 2);

      /**
       * Conversion factor for converting radians to degrees.
       *
       * @static
       * @constant
       * @memberof PIXI
       * @type {number}
       */
      let RAD_TO_DEG = (exports.RAD_TO_DEG = 180 / Math.PI);

      /**
       * Conversion factor for converting degrees to radians.
       *
       * @static
       * @constant
       * @memberof PIXI
       * @type {number}
       */
      let DEG_TO_RAD = (exports.DEG_TO_RAD = Math.PI / 180);

      /**
       * Constant to identify the Renderer Type.
       *
       * @static
       * @constant
       * @memberof PIXI
       * @name RENDERER_TYPE
       * @type {object}
       * @property {number} UNKNOWN - Unknown render type.
       * @property {number} WEBGL - WebGL render type.
       * @property {number} CANVAS - Canvas render type.
       */
      let RENDERER_TYPE = (exports.RENDERER_TYPE = {
        UNKNOWN: 0,
        WEBGL: 1,
        CANVAS: 2,
      });

      /**
       * Various blend modes supported by PIXI.
       *
       * IMPORTANT - The WebGL renderer only supports the NORMAL, ADD, MULTIPLY and SCREEN blend modes.
       * Anything else will silently act like NORMAL.
       *
       * @static
       * @constant
       * @memberof PIXI
       * @name BLEND_MODES
       * @type {object}
       * @property {number} NORMAL
       * @property {number} ADD
       * @property {number} MULTIPLY
       * @property {number} SCREEN
       * @property {number} OVERLAY
       * @property {number} DARKEN
       * @property {number} LIGHTEN
       * @property {number} COLOR_DODGE
       * @property {number} COLOR_BURN
       * @property {number} HARD_LIGHT
       * @property {number} SOFT_LIGHT
       * @property {number} DIFFERENCE
       * @property {number} EXCLUSION
       * @property {number} HUE
       * @property {number} SATURATION
       * @property {number} COLOR
       * @property {number} LUMINOSITY
       */
      let BLEND_MODES = (exports.BLEND_MODES = {
        NORMAL: 0,
        ADD: 1,
        MULTIPLY: 2,
        SCREEN: 3,
        OVERLAY: 4,
        DARKEN: 5,
        LIGHTEN: 6,
        COLOR_DODGE: 7,
        COLOR_BURN: 8,
        HARD_LIGHT: 9,
        SOFT_LIGHT: 10,
        DIFFERENCE: 11,
        EXCLUSION: 12,
        HUE: 13,
        SATURATION: 14,
        COLOR: 15,
        LUMINOSITY: 16,
        NORMAL_NPM: 17,
        ADD_NPM: 18,
        SCREEN_NPM: 19,
      });

      /**
       * Various webgl draw modes. These can be used to specify which GL drawMode to use
       * under certain situations and renderers.
       *
       * @static
       * @constant
       * @memberof PIXI
       * @name DRAW_MODES
       * @type {object}
       * @property {number} POINTS
       * @property {number} LINES
       * @property {number} LINE_LOOP
       * @property {number} LINE_STRIP
       * @property {number} TRIANGLES
       * @property {number} TRIANGLE_STRIP
       * @property {number} TRIANGLE_FAN
       */
      let DRAW_MODES = (exports.DRAW_MODES = {
        POINTS: 0,
        LINES: 1,
        LINE_LOOP: 2,
        LINE_STRIP: 3,
        TRIANGLES: 4,
        TRIANGLE_STRIP: 5,
        TRIANGLE_FAN: 6,
      });

      /**
       * The scale modes that are supported by pixi.
       *
       * The {@link PIXI.settings.SCALE_MODE} scale mode affects the default scaling mode of future operations.
       * It can be re-assigned to either LINEAR or NEAREST, depending upon suitability.
       *
       * @static
       * @constant
       * @memberof PIXI
       * @name SCALE_MODES
       * @type {object}
       * @property {number} LINEAR Smooth scaling
       * @property {number} NEAREST Pixelating scaling
       */
      let SCALE_MODES = (exports.SCALE_MODES = {
        LINEAR: 0,
        NEAREST: 1,
      });

      /**
       * The wrap modes that are supported by pixi.
       *
       * The {@link PIXI.settings.WRAP_MODE} wrap mode affects the default wrapping mode of future operations.
       * It can be re-assigned to either CLAMP or REPEAT, depending upon suitability.
       * If the texture is non power of two then clamp will be used regardless as webGL can
       * only use REPEAT if the texture is po2.
       *
       * This property only affects WebGL.
       *
       * @static
       * @constant
       * @name WRAP_MODES
       * @memberof PIXI
       * @type {object}
       * @property {number} CLAMP - The textures uvs are clamped
       * @property {number} REPEAT - The texture uvs tile and repeat
       * @property {number} MIRRORED_REPEAT - The texture uvs tile and repeat with mirroring
       */
      let WRAP_MODES = (exports.WRAP_MODES = {
        CLAMP: 0,
        REPEAT: 1,
        MIRRORED_REPEAT: 2,
      });

      /**
       * The gc modes that are supported by pixi.
       *
       * The {@link PIXI.settings.GC_MODE} Garbage Collection mode for PixiJS textures is AUTO
       * If set to GC_MODE, the renderer will occasionally check textures usage. If they are not
       * used for a specified period of time they will be removed from the GPU. They will of course
       * be uploaded again when they are required. This is a silent behind the scenes process that
       * should ensure that the GPU does not  get filled up.
       *
       * Handy for mobile devices!
       * This property only affects WebGL.
       *
       * @static
       * @constant
       * @name GC_MODES
       * @memberof PIXI
       * @type {object}
       * @property {number} AUTO - Garbage collection will happen periodically automatically
       * @property {number} MANUAL - Garbage collection will need to be called manually
       */
      let GC_MODES = (exports.GC_MODES = {
        AUTO: 0,
        MANUAL: 1,
      });

      /**
       * Regexp for image type by extension.
       *
       * @static
       * @constant
       * @memberof PIXI
       * @type {RegExp|string}
       * @example `image.png`
       */
      let URL_FILE_EXTENSION = (exports.URL_FILE_EXTENSION = /\.(\w{3,4})(?:$|\?|#)/i);

      /**
       * Regexp for data URI.
       * Based on: {@link https://github.com/ragingwind/data-uri-regex}
       *
       * @static
       * @constant
       * @name DATA_URI
       * @memberof PIXI
       * @type {RegExp|string}
       * @example data:image/png;base64
       */
      let DATA_URI = (exports.DATA_URI = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i);

      /**
       * Regexp for SVG size.
       *
       * @static
       * @constant
       * @name SVG_SIZE
       * @memberof PIXI
       * @type {RegExp|string}
       * @example &lt;svg width="100" height="100"&gt;&lt;/svg&gt;
       */
      let SVG_SIZE = (exports.SVG_SIZE =
        /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i); // eslint-disable-line max-len

      /**
       * Constants that identify shapes, mainly to prevent `instanceof` calls.
       *
       * @static
       * @constant
       * @name SHAPES
       * @memberof PIXI
       * @type {object}
       * @property {number} POLY Polygon
       * @property {number} RECT Rectangle
       * @property {number} CIRC Circle
       * @property {number} ELIP Ellipse
       * @property {number} RREC Rounded Rectangle
       */
      let SHAPES = (exports.SHAPES = {
        POLY: 0,
        RECT: 1,
        CIRC: 2,
        ELIP: 3,
        RREC: 4,
      });

      /**
       * Constants that specify float precision in shaders.
       *
       * @static
       * @constant
       * @name PRECISION
       * @memberof PIXI
       * @type {object}
       * @property {string} LOW='lowp'
       * @property {string} MEDIUM='mediump'
       * @property {string} HIGH='highp'
       */
      let PRECISION = (exports.PRECISION = {
        LOW: "lowp",
        MEDIUM: "mediump",
        HIGH: "highp",
      });

      /**
       * Constants that specify the transform type.
       *
       * @static
       * @constant
       * @name TRANSFORM_MODE
       * @memberof PIXI
       * @type {object}
       * @property {number} STATIC
       * @property {number} DYNAMIC
       */
      let TRANSFORM_MODE = (exports.TRANSFORM_MODE = {
        STATIC: 0,
        DYNAMIC: 1,
      });

      /**
       * Constants that define the type of gradient on text.
       *
       * @static
       * @constant
       * @name TEXT_GRADIENT
       * @memberof PIXI
       * @type {object}
       * @property {number} LINEAR_VERTICAL Vertical gradient
       * @property {number} LINEAR_HORIZONTAL Linear gradient
       */
      let TEXT_GRADIENT = (exports.TEXT_GRADIENT = {
        LINEAR_VERTICAL: 0,
        LINEAR_HORIZONTAL: 1,
      });

      /**
       * Represents the update priorities used by internal PIXI classes when registered with
       * the {@link PIXI.ticker.Ticker} object. Higher priority items are updated first and lower
       * priority items, such as render, should go later.
       *
       * @static
       * @constant
       * @name UPDATE_PRIORITY
       * @memberof PIXI
       * @type {object}
       * @property {number} INTERACTION=50 Highest priority, used for {@link PIXI.interaction.InteractionManager}
       * @property {number} HIGH=25 High priority updating, {@link PIXI.VideoBaseTexture} and {@link PIXI.extras.AnimatedSprite}
       * @property {number} NORMAL=0 Default priority for ticker events, see {@link PIXI.ticker.Ticker#add}.
       * @property {number} LOW=-25 Low priority used for {@link PIXI.Application} rendering.
       * @property {number} UTILITY=-50 Lowest priority used for {@link PIXI.prepare.BasePrepare} utility.
       */
      let UPDATE_PRIORITY = (exports.UPDATE_PRIORITY = {
        INTERACTION: 50,
        HIGH: 25,
        NORMAL: 0,
        LOW: -25,
        UTILITY: -50,
      });
      //# sourceMappingURL=const.js.map

      /***/
    },
    /* 344 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;
      exports.autoDetectRenderer =
        exports.Application =
        exports.Filter =
        exports.SpriteMaskFilter =
        exports.Quad =
        exports.RenderTarget =
        exports.ObjectRenderer =
        exports.WebGLManager =
        exports.Shader =
        exports.CanvasRenderTarget =
        exports.TextureUvs =
        exports.VideoBaseTexture =
        exports.BaseRenderTexture =
        exports.RenderTexture =
        exports.BaseTexture =
        exports.TextureMatrix =
        exports.Texture =
        exports.Spritesheet =
        exports.CanvasGraphicsRenderer =
        exports.GraphicsRenderer =
        exports.GraphicsData =
        exports.Graphics =
        exports.TextMetrics =
        exports.TextStyle =
        exports.Text =
        exports.SpriteRenderer =
        exports.CanvasTinter =
        exports.CanvasSpriteRenderer =
        exports.Sprite =
        exports.TransformBase =
        exports.TransformStatic =
        exports.Transform =
        exports.Container =
        exports.DisplayObject =
        exports.Bounds =
        exports.glCore =
        exports.WebGLRenderer =
        exports.CanvasRenderer =
        exports.ticker =
        exports.utils =
        exports.settings =
          undefined;

      let _const = __webpack_require__(343);

      Object.keys(_const).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _const[key];
          },
        });
      });

      let _math = __webpack_require__(348);

      Object.keys(_math).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _math[key];
          },
        });
      });

      let _pixiGlCore = __webpack_require__(350);

      Object.defineProperty(exports, "glCore", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_pixiGlCore).default;
        },
      });

      let _Bounds = __webpack_require__(377);

      Object.defineProperty(exports, "Bounds", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_Bounds).default;
        },
      });

      let _DisplayObject = __webpack_require__(404);

      Object.defineProperty(exports, "DisplayObject", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_DisplayObject).default;
        },
      });

      let _Container = __webpack_require__(358);

      Object.defineProperty(exports, "Container", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_Container).default;
        },
      });

      let _Transform = __webpack_require__(406);

      Object.defineProperty(exports, "Transform", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_Transform).default;
        },
      });

      let _TransformStatic = __webpack_require__(405);

      Object.defineProperty(exports, "TransformStatic", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_TransformStatic).default;
        },
      });

      let _TransformBase = __webpack_require__(379);

      Object.defineProperty(exports, "TransformBase", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_TransformBase).default;
        },
      });

      let _Sprite = __webpack_require__(381);

      Object.defineProperty(exports, "Sprite", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_Sprite).default;
        },
      });

      let _CanvasSpriteRenderer = __webpack_require__(500);

      Object.defineProperty(exports, "CanvasSpriteRenderer", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_CanvasSpriteRenderer).default;
        },
      });

      let _CanvasTinter = __webpack_require__(364);

      Object.defineProperty(exports, "CanvasTinter", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_CanvasTinter).default;
        },
      });

      let _SpriteRenderer = __webpack_require__(503);

      Object.defineProperty(exports, "SpriteRenderer", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_SpriteRenderer).default;
        },
      });

      let _Text = __webpack_require__(518);

      Object.defineProperty(exports, "Text", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_Text).default;
        },
      });

      let _TextStyle = __webpack_require__(419);

      Object.defineProperty(exports, "TextStyle", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_TextStyle).default;
        },
      });

      let _TextMetrics = __webpack_require__(420);

      Object.defineProperty(exports, "TextMetrics", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_TextMetrics).default;
        },
      });

      let _Graphics = __webpack_require__(520);

      Object.defineProperty(exports, "Graphics", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_Graphics).default;
        },
      });

      let _GraphicsData = __webpack_require__(421);

      Object.defineProperty(exports, "GraphicsData", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_GraphicsData).default;
        },
      });

      let _GraphicsRenderer = __webpack_require__(522);

      Object.defineProperty(exports, "GraphicsRenderer", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_GraphicsRenderer).default;
        },
      });

      let _CanvasGraphicsRenderer = __webpack_require__(529);

      Object.defineProperty(exports, "CanvasGraphicsRenderer", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_CanvasGraphicsRenderer).default;
        },
      });

      let _Spritesheet = __webpack_require__(530);

      Object.defineProperty(exports, "Spritesheet", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_Spritesheet).default;
        },
      });

      let _Texture = __webpack_require__(353);

      Object.defineProperty(exports, "Texture", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_Texture).default;
        },
      });

      let _TextureMatrix = __webpack_require__(417);

      Object.defineProperty(exports, "TextureMatrix", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_TextureMatrix).default;
        },
      });

      let _BaseTexture = __webpack_require__(355);

      Object.defineProperty(exports, "BaseTexture", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_BaseTexture).default;
        },
      });

      let _RenderTexture = __webpack_require__(384);

      Object.defineProperty(exports, "RenderTexture", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_RenderTexture).default;
        },
      });

      let _BaseRenderTexture = __webpack_require__(412);

      Object.defineProperty(exports, "BaseRenderTexture", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_BaseRenderTexture).default;
        },
      });

      let _VideoBaseTexture = __webpack_require__(409);

      Object.defineProperty(exports, "VideoBaseTexture", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_VideoBaseTexture).default;
        },
      });

      let _TextureUvs = __webpack_require__(410);

      Object.defineProperty(exports, "TextureUvs", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_TextureUvs).default;
        },
      });

      let _CanvasRenderTarget = __webpack_require__(413);

      Object.defineProperty(exports, "CanvasRenderTarget", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_CanvasRenderTarget).default;
        },
      });

      let _Shader = __webpack_require__(361);

      Object.defineProperty(exports, "Shader", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_Shader).default;
        },
      });

      let _WebGLManager = __webpack_require__(360);

      Object.defineProperty(exports, "WebGLManager", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_WebGLManager).default;
        },
      });

      let _ObjectRenderer = __webpack_require__(365);

      Object.defineProperty(exports, "ObjectRenderer", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_ObjectRenderer).default;
        },
      });

      let _RenderTarget = __webpack_require__(367);

      Object.defineProperty(exports, "RenderTarget", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_RenderTarget).default;
        },
      });

      let _Quad = __webpack_require__(418);

      Object.defineProperty(exports, "Quad", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_Quad).default;
        },
      });

      let _SpriteMaskFilter = __webpack_require__(415);

      Object.defineProperty(exports, "SpriteMaskFilter", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_SpriteMaskFilter).default;
        },
      });

      let _Filter = __webpack_require__(416);

      Object.defineProperty(exports, "Filter", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_Filter).default;
        },
      });

      let _Application = __webpack_require__(422);

      Object.defineProperty(exports, "Application", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_Application).default;
        },
      });

      let _autoDetectRenderer = __webpack_require__(423);

      Object.defineProperty(exports, "autoDetectRenderer", {
        enumerable: true,
        get: function get() {
          return _autoDetectRenderer.autoDetectRenderer;
        },
      });

      let _utils = __webpack_require__(345);

      let utils = _interopRequireWildcard(_utils);

      let _ticker = __webpack_require__(383);

      let ticker = _interopRequireWildcard(_ticker);

      let _settings = __webpack_require__(346);

      let _settings2 = _interopRequireDefault(_settings);

      let _CanvasRenderer = __webpack_require__(359);

      let _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);

      let _WebGLRenderer = __webpack_require__(366);

      let _WebGLRenderer2 = _interopRequireDefault(_WebGLRenderer);

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          let newObj = {};
          if (obj != null) {
            for (let key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }
          newObj.default = obj;
          return newObj;
        }
      }

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      exports.settings = _settings2.default;
      exports.utils = utils;
      exports.ticker = ticker;
      exports.CanvasRenderer = _CanvasRenderer2.default;
      exports.WebGLRenderer = _WebGLRenderer2.default;
      /**
       * @namespace PIXI
       */
      //# sourceMappingURL=index.js.map

      /***/
    },
    /* 345 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;
      exports.premultiplyBlendMode =
        exports.BaseTextureCache =
        exports.TextureCache =
        exports.earcut =
        exports.mixins =
        exports.pluginTarget =
        exports.EventEmitter =
        exports.removeItems =
        exports.isMobile =
          undefined;
      exports.uid = uid;
      exports.hex2rgb = hex2rgb;
      exports.hex2string = hex2string;
      exports.rgb2hex = rgb2hex;
      exports.getResolutionOfUrl = getResolutionOfUrl;
      exports.decomposeDataUri = decomposeDataUri;
      exports.getUrlFileExtension = getUrlFileExtension;
      exports.getSvgSize = getSvgSize;
      exports.skipHello = skipHello;
      exports.sayHello = sayHello;
      exports.isWebGLSupported = isWebGLSupported;
      exports.sign = sign;
      exports.destroyTextureCache = destroyTextureCache;
      exports.clearTextureCache = clearTextureCache;
      exports.correctBlendMode = correctBlendMode;
      exports.premultiplyTint = premultiplyTint;
      exports.premultiplyRgba = premultiplyRgba;
      exports.premultiplyTintToRgba = premultiplyTintToRgba;

      let _const = __webpack_require__(343);

      let _settings = __webpack_require__(346);

      let _settings2 = _interopRequireDefault(_settings);

      let _eventemitter = __webpack_require__(354);

      let _eventemitter2 = _interopRequireDefault(_eventemitter);

      let _pluginTarget = __webpack_require__(488);

      let _pluginTarget2 = _interopRequireDefault(_pluginTarget);

      let _mixin = __webpack_require__(489);

      let mixins = _interopRequireWildcard(_mixin);

      let _ismobilejs = __webpack_require__(378);

      let isMobile = _interopRequireWildcard(_ismobilejs);

      let _removeArrayItems = __webpack_require__(490);

      let _removeArrayItems2 = _interopRequireDefault(_removeArrayItems);

      let _mapPremultipliedBlendModes = __webpack_require__(491);

      let _mapPremultipliedBlendModes2 = _interopRequireDefault(_mapPremultipliedBlendModes);

      let _earcut = __webpack_require__(380);

      let _earcut2 = _interopRequireDefault(_earcut);

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          let newObj = {};
          if (obj != null) {
            for (let key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }
          newObj.default = obj;
          return newObj;
        }
      }

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      let nextUid = 0;
      let saidHello = false;

      /**
       * Generalized convenience utilities for PIXI.
       * @example
       * // Extend PIXI's internal Event Emitter.
       * class MyEmitter extends PIXI.utils.EventEmitter {
       *   constructor() {
       *      super();
       *      console.log("Emitter created!");
       *   }
       * }
       *
       * // Get info on current device
       * console.log(PIXI.utils.isMobile);
       *
       * // Convert hex color to string
       * console.log(PIXI.utils.hex2string(0xff00ff)); // returns: "#ff00ff"
       * @namespace PIXI.utils
       */
      exports.isMobile = isMobile;
      exports.removeItems = _removeArrayItems2.default;
      exports.EventEmitter = _eventemitter2.default;
      exports.pluginTarget = _pluginTarget2.default;
      exports.mixins = mixins;
      exports.earcut = _earcut2.default;

      /**
       * Gets the next unique identifier
       *
       * @memberof PIXI.utils
       * @function uid
       * @return {number} The next unique identifier to use.
       */

      function uid() {
        return ++nextUid;
      }

      /**
       * Converts a hex color number to an [R, G, B] array
       *
       * @memberof PIXI.utils
       * @function hex2rgb
       * @param {number} hex - The number to convert
       * @param  {number[]} [out=[]] If supplied, this array will be used rather than returning a new one
       * @return {number[]} An array representing the [R, G, B] of the color.
       */
      function hex2rgb(hex, out) {
        out = out || [];

        out[0] = ((hex >> 16) & 0xff) / 255;
        out[1] = ((hex >> 8) & 0xff) / 255;
        out[2] = (hex & 0xff) / 255;

        return out;
      }

      /**
       * Converts a hex color number to a string.
       *
       * @memberof PIXI.utils
       * @function hex2string
       * @param {number} hex - Number in hex
       * @return {string} The string color.
       */
      function hex2string(hex) {
        hex = hex.toString(16);
        hex = "000000".substr(0, 6 - hex.length) + hex;

        return "#" + hex;
      }

      /**
       * Converts a color as an [R, G, B] array to a hex number
       *
       * @memberof PIXI.utils
       * @function rgb2hex
       * @param {number[]} rgb - rgb array
       * @return {number} The color number
       */
      function rgb2hex(rgb) {
        return ((rgb[0] * 255) << 16) + ((rgb[1] * 255) << 8) + ((rgb[2] * 255) | 0);
      }

      /**
       * get the resolution / device pixel ratio of an asset by looking for the prefix
       * used by spritesheets and image urls
       *
       * @memberof PIXI.utils
       * @function getResolutionOfUrl
       * @param {string} url - the image path
       * @param {number} [defaultValue=1] - the defaultValue if no filename prefix is set.
       * @return {number} resolution / device pixel ratio of an asset
       */
      function getResolutionOfUrl(url, defaultValue) {
        let resolution = _settings2.default.RETINA_PREFIX.exec(url);

        if (resolution) {
          return parseFloat(resolution[1]);
        }

        return defaultValue !== undefined ? defaultValue : 1;
      }

      /**
       * Typedef for decomposeDataUri return object.
       *
       * @typedef {object} PIXI.utils~DecomposedDataUri
       * @property {mediaType} Media type, eg. `image`
       * @property {subType} Sub type, eg. `png`
       * @property {encoding} Data encoding, eg. `base64`
       * @property {data} The actual data
       */

      /**
       * Split a data URI into components. Returns undefined if
       * parameter `dataUri` is not a valid data URI.
       *
       * @memberof PIXI.utils
       * @function decomposeDataUri
       * @param {string} dataUri - the data URI to check
       * @return {PIXI.utils~DecomposedDataUri|undefined} The decomposed data uri or undefined
       */
      function decomposeDataUri(dataUri) {
        let dataUriMatch = _const.DATA_URI.exec(dataUri);

        if (dataUriMatch) {
          return {
            mediaType: dataUriMatch[1] ? dataUriMatch[1].toLowerCase() : undefined,
            subType: dataUriMatch[2] ? dataUriMatch[2].toLowerCase() : undefined,
            charset: dataUriMatch[3] ? dataUriMatch[3].toLowerCase() : undefined,
            encoding: dataUriMatch[4] ? dataUriMatch[4].toLowerCase() : undefined,
            data: dataUriMatch[5],
          };
        }

        return undefined;
      }

      /**
       * Get type of the image by regexp for extension. Returns undefined for unknown extensions.
       *
       * @memberof PIXI.utils
       * @function getUrlFileExtension
       * @param {string} url - the image path
       * @return {string|undefined} image extension
       */
      function getUrlFileExtension(url) {
        let extension = _const.URL_FILE_EXTENSION.exec(url);

        if (extension) {
          return extension[1].toLowerCase();
        }

        return undefined;
      }

      /**
       * Typedef for Size object.
       *
       * @typedef {object} PIXI.utils~Size
       * @property {width} Width component
       * @property {height} Height component
       */

      /**
       * Get size from an svg string using regexp.
       *
       * @memberof PIXI.utils
       * @function getSvgSize
       * @param {string} svgString - a serialized svg element
       * @return {PIXI.utils~Size|undefined} image extension
       */
      function getSvgSize(svgString) {
        let sizeMatch = _const.SVG_SIZE.exec(svgString);
        let size = {};

        if (sizeMatch) {
          size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));
          size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));
        }

        return size;
      }

      /**
       * Skips the hello message of renderers that are created after this is run.
       *
       * @function skipHello
       * @memberof PIXI.utils
       */
      function skipHello() {
        saidHello = true;
      }

      /**
       * Logs out the version and renderer information for this running instance of PIXI.
       * If you don't want to see this message you can run `PIXI.utils.skipHello()` before
       * creating your renderer. Keep in mind that doing that will forever makes you a jerk face.
       *
       * @static
       * @function sayHello
       * @memberof PIXI.utils
       * @param {string} type - The string renderer type to log.
       */
      function sayHello(type) {
        if (saidHello) {
          return;
        }

        if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
          let args = [
            "\n %c %c %c PixiJS " +
              _const.VERSION +
              " - \u2730 " +
              type +
              " \u2730  %c  %c  http://www.pixijs.com/  %c %c \u2665%c\u2665%c\u2665 \n\n",
            "background: #ff66a5; padding:5px 0;",
            "background: #ff66a5; padding:5px 0;",
            "color: #ff66a5; background: #030307; padding:5px 0;",
            "background: #ff66a5; padding:5px 0;",
            "background: #ffc3dc; padding:5px 0;",
            "background: #ff66a5; padding:5px 0;",
            "color: #ff2424; background: #fff; padding:5px 0;",
            "color: #ff2424; background: #fff; padding:5px 0;",
            "color: #ff2424; background: #fff; padding:5px 0;",
          ];

          window.console.log.apply(console, args);
        } else if (window.console) {
          window.console.log("PixiJS " + _const.VERSION + " - " + type + " - http://www.pixijs.com/");
        }

        saidHello = true;
      }

      /**
       * Helper for checking for webgl support
       *
       * @memberof PIXI.utils
       * @function isWebGLSupported
       * @return {boolean} is webgl supported
       */
      function isWebGLSupported() {
        let contextOptions = { stencil: true, failIfMajorPerformanceCaveat: true };

        try {
          if (!window.WebGLRenderingContext) {
            return false;
          }

          let canvas = document.createElement("canvas");
          let gl = canvas.getContext("webgl", contextOptions) || canvas.getContext("experimental-webgl", contextOptions);

          let success = !!(gl && gl.getContextAttributes().stencil);

          if (gl) {
            let loseContext = gl.getExtension("WEBGL_lose_context");

            if (loseContext) {
              loseContext.loseContext();
            }
          }

          gl = null;

          return success;
        } catch (e) {
          return false;
        }
      }

      /**
       * Returns sign of number
       *
       * @memberof PIXI.utils
       * @function sign
       * @param {number} n - the number to check the sign of
       * @returns {number} 0 if `n` is 0, -1 if `n` is negative, 1 if `n` is positive
       */
      function sign(n) {
        if (n === 0) return 0;

        return n < 0 ? -1 : 1;
      }

      /**
       * @todo Describe property usage
       *
       * @memberof PIXI.utils
       * @private
       */
      let TextureCache = (exports.TextureCache = Object.create(null));

      /**
       * @todo Describe property usage
       *
       * @memberof PIXI.utils
       * @private
       */
      let BaseTextureCache = (exports.BaseTextureCache = Object.create(null));

      /**
       * Destroys all texture in the cache
       *
       * @memberof PIXI.utils
       * @function destroyTextureCache
       */
      function destroyTextureCache() {
        let key = void 0;

        for (key in TextureCache) {
          TextureCache[key].destroy();
        }
        for (key in BaseTextureCache) {
          BaseTextureCache[key].destroy();
        }
      }

      /**
       * Removes all textures from cache, but does not destroy them
       *
       * @memberof PIXI.utils
       * @function clearTextureCache
       */
      function clearTextureCache() {
        let key = void 0;

        for (key in TextureCache) {
          delete TextureCache[key];
        }
        for (key in BaseTextureCache) {
          delete BaseTextureCache[key];
        }
      }

      /**
       * maps premultiply flag and blendMode to adjusted blendMode
       * @memberof PIXI.utils
       * @const premultiplyBlendMode
       * @type {Array<number[]>}
       */
      let premultiplyBlendMode = (exports.premultiplyBlendMode = (0, _mapPremultipliedBlendModes2.default)());

      /**
       * changes blendMode according to texture format
       *
       * @memberof PIXI.utils
       * @function correctBlendMode
       * @param {number} blendMode supposed blend mode
       * @param {boolean} premultiplied  whether source is premultiplied
       * @returns {number} true blend mode for this texture
       */
      function correctBlendMode(blendMode, premultiplied) {
        return premultiplyBlendMode[premultiplied ? 1 : 0][blendMode];
      }

      /**
       * premultiplies tint
       *
       * @memberof PIXI.utils
       * @param {number} tint integet RGB
       * @param {number} alpha floating point alpha (0.0-1.0)
       * @returns {number} tint multiplied by alpha
       */
      function premultiplyTint(tint, alpha) {
        if (alpha === 1.0) {
          return ((alpha * 255) << 24) + tint;
        }
        if (alpha === 0.0) {
          return 0;
        }
        let R = (tint >> 16) & 0xff;
        let G = (tint >> 8) & 0xff;
        let B = tint & 0xff;

        R = (R * alpha + 0.5) | 0;
        G = (G * alpha + 0.5) | 0;
        B = (B * alpha + 0.5) | 0;

        return ((alpha * 255) << 24) + (R << 16) + (G << 8) + B;
      }

      /**
       * combines rgb and alpha to out array
       *
       * @memberof PIXI.utils
       * @param {Float32Array|number[]} rgb input rgb
       * @param {number} alpha alpha param
       * @param {Float32Array} [out] output
       * @param {boolean} [premultiply=true] do premultiply it
       * @returns {Float32Array} vec4 rgba
       */
      function premultiplyRgba(rgb, alpha, out, premultiply) {
        out = out || new Float32Array(4);
        if (premultiply || premultiply === undefined) {
          out[0] = rgb[0] * alpha;
          out[1] = rgb[1] * alpha;
          out[2] = rgb[2] * alpha;
        } else {
          out[0] = rgb[0];
          out[1] = rgb[1];
          out[2] = rgb[2];
        }
        out[3] = alpha;

        return out;
      }

      /**
       * converts integer tint and float alpha to vec4 form, premultiplies by default
       *
       * @memberof PIXI.utils
       * @param {number} tint input tint
       * @param {number} alpha alpha param
       * @param {Float32Array} [out] output
       * @param {boolean} [premultiply=true] do premultiply it
       * @returns {Float32Array} vec4 rgba
       */
      function premultiplyTintToRgba(tint, alpha, out, premultiply) {
        out = out || new Float32Array(4);
        out[0] = ((tint >> 16) & 0xff) / 255.0;
        out[1] = ((tint >> 8) & 0xff) / 255.0;
        out[2] = (tint & 0xff) / 255.0;
        if (premultiply || premultiply === undefined) {
          out[0] *= alpha;
          out[1] *= alpha;
          out[2] *= alpha;
        }
        out[3] = alpha;

        return out;
      }
      //# sourceMappingURL=index.js.map

      /***/
    },
    /* 346 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      let _maxRecommendedTextures = __webpack_require__(486);

      let _maxRecommendedTextures2 = _interopRequireDefault(_maxRecommendedTextures);

      let _canUploadSameBuffer = __webpack_require__(487);

      let _canUploadSameBuffer2 = _interopRequireDefault(_canUploadSameBuffer);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      /**
       * User's customizable globals for overriding the default PIXI settings, such
       * as a renderer's default resolution, framerate, float percision, etc.
       * @example
       * // Use the native window resolution as the default resolution
       * // will support high-density displays when rendering
       * PIXI.settings.RESOLUTION = window.devicePixelRatio.
       *
       * // Disable interpolation when scaling, will make texture be pixelated
       * PIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.NEAREST;
       * @namespace PIXI.settings
       */
      exports.default = {
        /**
         * Target frames per millisecond.
         *
         * @static
         * @memberof PIXI.settings
         * @type {number}
         * @default 0.06
         */
        TARGET_FPMS: 0.06,

        /**
         * If set to true WebGL will attempt make textures mimpaped by default.
         * Mipmapping will only succeed if the base texture uploaded has power of two dimensions.
         *
         * @static
         * @memberof PIXI.settings
         * @type {boolean}
         * @default true
         */
        MIPMAP_TEXTURES: true,

        /**
         * Default resolution / device pixel ratio of the renderer.
         *
         * @static
         * @memberof PIXI.settings
         * @type {number}
         * @default 1
         */
        RESOLUTION: 1,

        /**
         * Default filter resolution.
         *
         * @static
         * @memberof PIXI.settings
         * @type {number}
         * @default 1
         */
        FILTER_RESOLUTION: 1,

        /**
         * The maximum textures that this device supports.
         *
         * @static
         * @memberof PIXI.settings
         * @type {number}
         * @default 32
         */
        SPRITE_MAX_TEXTURES: (0, _maxRecommendedTextures2.default)(32),

        // TODO: maybe change to SPRITE.BATCH_SIZE: 2000
        // TODO: maybe add PARTICLE.BATCH_SIZE: 15000

        /**
         * The default sprite batch size.
         *
         * The default aims to balance desktop and mobile devices.
         *
         * @static
         * @memberof PIXI.settings
         * @type {number}
         * @default 4096
         */
        SPRITE_BATCH_SIZE: 4096,

        /**
         * The prefix that denotes a URL is for a retina asset.
         *
         * @static
         * @memberof PIXI.settings
         * @type {RegExp}
         * @example `@2x`
         * @default /@([0-9\.]+)x/
         */
        RETINA_PREFIX: /@([0-9\.]+)x/,

        /**
         * The default render options if none are supplied to {@link PIXI.WebGLRenderer}
         * or {@link PIXI.CanvasRenderer}.
         *
         * @static
         * @constant
         * @memberof PIXI.settings
         * @type {object}
         * @property {HTMLCanvasElement} view=null
         * @property {number} resolution=1
         * @property {boolean} antialias=false
         * @property {boolean} forceFXAA=false
         * @property {boolean} autoResize=false
         * @property {boolean} transparent=false
         * @property {number} backgroundColor=0x000000
         * @property {boolean} clearBeforeRender=true
         * @property {boolean} preserveDrawingBuffer=false
         * @property {boolean} roundPixels=false
         * @property {number} width=800
         * @property {number} height=600
         * @property {boolean} legacy=false
         */
        RENDER_OPTIONS: {
          view: null,
          antialias: false,
          forceFXAA: false,
          autoResize: false,
          transparent: false,
          backgroundColor: 0x000000,
          clearBeforeRender: true,
          preserveDrawingBuffer: false,
          roundPixels: false,
          width: 800,
          height: 600,
          legacy: false,
        },

        /**
         * Default transform type.
         *
         * @static
         * @memberof PIXI.settings
         * @type {PIXI.TRANSFORM_MODE}
         * @default PIXI.TRANSFORM_MODE.STATIC
         */
        TRANSFORM_MODE: 0,

        /**
         * Default Garbage Collection mode.
         *
         * @static
         * @memberof PIXI.settings
         * @type {PIXI.GC_MODES}
         * @default PIXI.GC_MODES.AUTO
         */
        GC_MODE: 0,

        /**
         * Default Garbage Collection max idle.
         *
         * @static
         * @memberof PIXI.settings
         * @type {number}
         * @default 3600
         */
        GC_MAX_IDLE: 60 * 60,

        /**
         * Default Garbage Collection maximum check count.
         *
         * @static
         * @memberof PIXI.settings
         * @type {number}
         * @default 600
         */
        GC_MAX_CHECK_COUNT: 60 * 10,

        /**
         * Default wrap modes that are supported by pixi.
         *
         * @static
         * @memberof PIXI.settings
         * @type {PIXI.WRAP_MODES}
         * @default PIXI.WRAP_MODES.CLAMP
         */
        WRAP_MODE: 0,

        /**
         * The scale modes that are supported by pixi.
         *
         * @static
         * @memberof PIXI.settings
         * @type {PIXI.SCALE_MODES}
         * @default PIXI.SCALE_MODES.LINEAR
         */
        SCALE_MODE: 0,

        /**
         * Default specify float precision in vertex shader.
         *
         * @static
         * @memberof PIXI.settings
         * @type {PIXI.PRECISION}
         * @default PIXI.PRECISION.HIGH
         */
        PRECISION_VERTEX: "highp",

        /**
         * Default specify float precision in fragment shader.
         *
         * @static
         * @memberof PIXI.settings
         * @type {PIXI.PRECISION}
         * @default PIXI.PRECISION.MEDIUM
         */
        PRECISION_FRAGMENT: "mediump",

        /**
         * Can we upload the same buffer in a single frame?
         *
         * @static
         * @constant
         * @memberof PIXI.settings
         * @type {boolean}
         */
        CAN_UPLOAD_SAME_BUFFER: (0, _canUploadSameBuffer2.default)(),

        /**
         * Default Mesh `canvasPadding`.
         *
         * @see PIXI.mesh.Mesh#canvasPadding
         * @static
         * @constant
         * @memberof PIXI.settings
         * @type {number}
         */
        MESH_CANVAS_PADDING: 0,
      };
      //# sourceMappingURL=settings.js.map

      /***/
    },
    ,
    /* 347 */ /* 348 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      let _Point = __webpack_require__(373);

      Object.defineProperty(exports, "Point", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_Point).default;
        },
      });

      let _ObservablePoint = __webpack_require__(393);

      Object.defineProperty(exports, "ObservablePoint", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_ObservablePoint).default;
        },
      });

      let _Matrix = __webpack_require__(374);

      Object.defineProperty(exports, "Matrix", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_Matrix).default;
        },
      });

      let _GroupD = __webpack_require__(394);

      Object.defineProperty(exports, "GroupD8", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_GroupD).default;
        },
      });

      let _Circle = __webpack_require__(476);

      Object.defineProperty(exports, "Circle", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_Circle).default;
        },
      });

      let _Ellipse = __webpack_require__(477);

      Object.defineProperty(exports, "Ellipse", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_Ellipse).default;
        },
      });

      let _Polygon = __webpack_require__(478);

      Object.defineProperty(exports, "Polygon", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_Polygon).default;
        },
      });

      let _Rectangle = __webpack_require__(375);

      Object.defineProperty(exports, "Rectangle", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_Rectangle).default;
        },
      });

      let _RoundedRectangle = __webpack_require__(479);

      Object.defineProperty(exports, "RoundedRectangle", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_RoundedRectangle).default;
        },
      });

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      //# sourceMappingURL=index.js.map

      /***/
    },
    ,
    /* 349 */ /* 350 */
    /***/ function (module, exports, __webpack_require__) {
      let gl = {
        createContext: __webpack_require__(480),
        setVertexAttribArrays: __webpack_require__(395),
        GLBuffer: __webpack_require__(481),
        GLFramebuffer: __webpack_require__(482),
        GLShader: __webpack_require__(483),
        GLTexture: __webpack_require__(396),
        VertexArrayObject: __webpack_require__(484),
        shader: __webpack_require__(485),
      };

      // Export for Node-compatible environments
      if (true && module.exports) {
        // Export the module
        module.exports = gl;
      }

      // Add to the browser window pixi.gl
      if (typeof window !== "undefined") {
        // add the window object
        window.PIXI = window.PIXI || {};
        window.PIXI.glCore = gl;
      }

      /***/
    },
    ,
    /* 351 */ /* 352 */
    /***/ function (module, exports, __webpack_require__) {
      /* WEBPACK VAR INJECTION */ (function (process) {
        // .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
        // backported and transplited with Babel, with backwards-compat fixes

        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        // resolves . and .. elements in a path array with directory names there
        // must be no slashes, empty elements, or device names (c:\) in the array
        // (so also no leading and trailing slashes - it does not distinguish
        // relative and absolute paths)
        function normalizeArray(parts, allowAboveRoot) {
          // if the path tries to go above the root, `up` ends up > 0
          let up = 0;
          for (let i = parts.length - 1; i >= 0; i--) {
            let last = parts[i];
            if (last === ".") {
              parts.splice(i, 1);
            } else if (last === "..") {
              parts.splice(i, 1);
              up++;
            } else if (up) {
              parts.splice(i, 1);
              up--;
            }
          }

          // if the path is allowed to go above the root, restore leading ..s
          if (allowAboveRoot) {
            for (; up--; up) {
              parts.unshift("..");
            }
          }

          return parts;
        }

        // path.resolve([from ...], to)
        // posix version
        exports.resolve = function () {
          let resolvedPath = "",
            resolvedAbsolute = false;

          for (let i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
            let path = i >= 0 ? arguments[i] : process.cwd();

            // Skip empty and invalid entries
            if (typeof path !== "string") {
              throw new TypeError("Arguments to path.resolve must be strings");
            } else if (!path) {
              continue;
            }

            resolvedPath = path + "/" + resolvedPath;
            resolvedAbsolute = path.charAt(0) === "/";
          }

          // At this point the path should be resolved to a full absolute path, but
          // handle relative paths to be safe (might happen when process.cwd() fails)

          // Normalize the path
          resolvedPath = normalizeArray(
            filter(resolvedPath.split("/"), function (p) {
              return !!p;
            }),
            !resolvedAbsolute
          ).join("/");

          return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
        };

        // path.normalize(path)
        // posix version
        exports.normalize = function (path) {
          let isAbsolute = exports.isAbsolute(path),
            trailingSlash = substr(path, -1) === "/";

          // Normalize the path
          path = normalizeArray(
            filter(path.split("/"), function (p) {
              return !!p;
            }),
            !isAbsolute
          ).join("/");

          if (!path && !isAbsolute) {
            path = ".";
          }
          if (path && trailingSlash) {
            path += "/";
          }

          return (isAbsolute ? "/" : "") + path;
        };

        // posix version
        exports.isAbsolute = function (path) {
          return path.charAt(0) === "/";
        };

        // posix version
        exports.join = function () {
          let paths = Array.prototype.slice.call(arguments, 0);
          return exports.normalize(
            filter(paths, function (p, index) {
              if (typeof p !== "string") {
                throw new TypeError("Arguments to path.join must be strings");
              }
              return p;
            }).join("/")
          );
        };

        // path.relative(from, to)
        // posix version
        exports.relative = function (from, to) {
          from = exports.resolve(from).substr(1);
          to = exports.resolve(to).substr(1);

          function trim(arr) {
            let start = 0;
            for (; start < arr.length; start++) {
              if (arr[start] !== "") break;
            }

            let end = arr.length - 1;
            for (; end >= 0; end--) {
              if (arr[end] !== "") break;
            }

            if (start > end) return [];
            return arr.slice(start, end - start + 1);
          }

          let fromParts = trim(from.split("/"));
          let toParts = trim(to.split("/"));

          let length = Math.min(fromParts.length, toParts.length);
          let samePartsLength = length;
          for (var i = 0; i < length; i++) {
            if (fromParts[i] !== toParts[i]) {
              samePartsLength = i;
              break;
            }
          }

          let outputParts = [];
          for (var i = samePartsLength; i < fromParts.length; i++) {
            outputParts.push("..");
          }

          outputParts = outputParts.concat(toParts.slice(samePartsLength));

          return outputParts.join("/");
        };

        exports.sep = "/";
        exports.delimiter = ":";

        exports.dirname = function (path) {
          if (typeof path !== "string") path = path + "";
          if (path.length === 0) return ".";
          let code = path.charCodeAt(0);
          let hasRoot = code === 47; /*/*/
          let end = -1;
          let matchedSlash = true;
          for (let i = path.length - 1; i >= 1; --i) {
            code = path.charCodeAt(i);
            if (code === 47 /*/*/) {
              if (!matchedSlash) {
                end = i;
                break;
              }
            } else {
              // We saw the first non-path separator
              matchedSlash = false;
            }
          }

          if (end === -1) return hasRoot ? "/" : ".";
          if (hasRoot && end === 1) {
            // return '//';
            // Backwards-compat fix:
            return "/";
          }
          return path.slice(0, end);
        };

        function basename(path) {
          if (typeof path !== "string") path = path + "";

          let start = 0;
          let end = -1;
          let matchedSlash = true;
          let i;

          for (i = path.length - 1; i >= 0; --i) {
            if (path.charCodeAt(i) === 47 /*/*/) {
              // If we reached a path separator that was not part of a set of path
              // separators at the end of the string, stop now
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else if (end === -1) {
              // We saw the first non-path separator, mark this as the end of our
              // path component
              matchedSlash = false;
              end = i + 1;
            }
          }

          if (end === -1) return "";
          return path.slice(start, end);
        }

        // Uses a mixed approach for backwards-compatibility, as ext behavior changed
        // in new Node.js versions, so only basename() above is backported here
        exports.basename = function (path, ext) {
          let f = basename(path);
          if (ext && f.substr(-1 * ext.length) === ext) {
            f = f.substr(0, f.length - ext.length);
          }
          return f;
        };

        exports.extname = function (path) {
          if (typeof path !== "string") path = path + "";
          let startDot = -1;
          let startPart = 0;
          let end = -1;
          let matchedSlash = true;
          // Track the state of characters (if any) we see before our first dot and
          // after any path separator we find
          let preDotState = 0;
          for (let i = path.length - 1; i >= 0; --i) {
            let code = path.charCodeAt(i);
            if (code === 47 /*/*/) {
              // If we reached a path separator that was not part of a set of path
              // separators at the end of the string, stop now
              if (!matchedSlash) {
                startPart = i + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              // We saw the first non-path separator, mark this as the end of our
              // extension
              matchedSlash = false;
              end = i + 1;
            }
            if (code === 46 /*.*/) {
              // If this is our first dot, mark it as the start of our extension
              if (startDot === -1) startDot = i;
              else if (preDotState !== 1) preDotState = 1;
            } else if (startDot !== -1) {
              // We saw a non-dot and non-path separator before our dot, so we should
              // have a good chance at having a non-empty extension
              preDotState = -1;
            }
          }

          if (
            startDot === -1 ||
            end === -1 ||
            // We saw a non-dot character immediately before the dot
            preDotState === 0 ||
            // The (right-most) trimmed path component is exactly '..'
            (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)
          ) {
            return "";
          }
          return path.slice(startDot, end);
        };

        function filter(xs, f) {
          if (xs.filter) return xs.filter(f);
          let res = [];
          for (let i = 0; i < xs.length; i++) {
            if (f(xs[i], i, xs)) res.push(xs[i]);
          }
          return res;
        }

        // String.prototype.substr - negative index don't work in IE8
        var substr =
          "ab".substr(-1) === "b"
            ? function (str, start, len) {
                return str.substr(start, len);
              }
            : function (str, start, len) {
                if (start < 0) start = str.length + start;
                return str.substr(start, len);
              };

        /* WEBPACK VAR INJECTION */
      }).call(this, __webpack_require__(229));

      /***/
    },
    /* 353 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      let _createClass = (function () {
        function defineProperties(target, props) {
          for (let i = 0; i < props.length; i++) {
            let descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      })();

      let _BaseTexture = __webpack_require__(355);

      let _BaseTexture2 = _interopRequireDefault(_BaseTexture);

      let _VideoBaseTexture = __webpack_require__(409);

      let _VideoBaseTexture2 = _interopRequireDefault(_VideoBaseTexture);

      let _TextureUvs = __webpack_require__(410);

      let _TextureUvs2 = _interopRequireDefault(_TextureUvs);

      let _eventemitter = __webpack_require__(354);

      let _eventemitter2 = _interopRequireDefault(_eventemitter);

      let _math = __webpack_require__(348);

      let _utils = __webpack_require__(345);

      let _settings = __webpack_require__(346);

      let _settings2 = _interopRequireDefault(_settings);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: { value: subClass, enumerable: false, writable: true, configurable: true },
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass);
      }

      /**
       * A texture stores the information that represents an image or part of an image. It cannot be added
       * to the display list directly. Instead use it as the texture for a Sprite. If no frame is provided
       * then the whole image is used.
       *
       * You can directly create a texture from an image and then reuse it multiple times like this :
       *
       * ```js
       * let texture = PIXI.Texture.fromImage('assets/image.png');
       * let sprite1 = new PIXI.Sprite(texture);
       * let sprite2 = new PIXI.Sprite(texture);
       * ```
       *
       * Textures made from SVGs, loaded or not, cannot be used before the file finishes processing.
       * You can check for this by checking the sprite's _textureID property.
       * ```js
       * var texture = PIXI.Texture.fromImage('assets/image.svg');
       * var sprite1 = new PIXI.Sprite(texture);
       * //sprite1._textureID should not be undefined if the texture has finished processing the SVG file
       * ```
       * You can use a ticker or rAF to ensure your sprites load the finished textures after processing. See issue #3068.
       *
       * @class
       * @extends EventEmitter
       * @memberof PIXI
       */
      let Texture = (function (_EventEmitter) {
        _inherits(Texture, _EventEmitter);

        /**
         * @param {PIXI.BaseTexture} baseTexture - The base texture source to create the texture from
         * @param {PIXI.Rectangle} [frame] - The rectangle frame of the texture to show
         * @param {PIXI.Rectangle} [orig] - The area of original texture
         * @param {PIXI.Rectangle} [trim] - Trimmed rectangle of original texture
         * @param {number} [rotate] - indicates how the texture was rotated by texture packer. See {@link PIXI.GroupD8}
         * @param {PIXI.Point} [anchor] - Default anchor point used for sprite placement / rotation
         */
        function Texture(baseTexture, frame, orig, trim, rotate, anchor) {
          _classCallCheck(this, Texture);

          /**
           * Does this Texture have any frame data assigned to it?
           *
           * @member {boolean}
           */
          let _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

          _this.noFrame = false;

          if (!frame) {
            _this.noFrame = true;
            frame = new _math.Rectangle(0, 0, 1, 1);
          }

          if (baseTexture instanceof Texture) {
            baseTexture = baseTexture.baseTexture;
          }

          /**
           * The base texture that this texture uses.
           *
           * @member {PIXI.BaseTexture}
           */
          _this.baseTexture = baseTexture;

          /**
           * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,
           * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)
           *
           * @member {PIXI.Rectangle}
           */
          _this._frame = frame;

          /**
           * This is the trimmed area of original texture, before it was put in atlas
           * Please call `_updateUvs()` after you change coordinates of `trim` manually.
           *
           * @member {PIXI.Rectangle}
           */
          _this.trim = trim;

          /**
           * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.
           *
           * @member {boolean}
           */
          _this.valid = false;

          /**
           * This will let a renderer know that a texture has been updated (used mainly for webGL uv updates)
           *
           * @member {boolean}
           */
          _this.requiresUpdate = false;

          /**
           * The WebGL UV data cache.
           *
           * @member {PIXI.TextureUvs}
           * @private
           */
          _this._uvs = null;

          /**
           * This is the area of original texture, before it was put in atlas
           *
           * @member {PIXI.Rectangle}
           */
          _this.orig = orig || frame; // new Rectangle(0, 0, 1, 1);

          _this._rotate = Number(rotate || 0);

          if (rotate === true) {
            // this is old texturepacker legacy, some games/libraries are passing "true" for rotated textures
            _this._rotate = 2;
          } else if (_this._rotate % 2 !== 0) {
            throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
          }

          if (baseTexture.hasLoaded) {
            if (_this.noFrame) {
              frame = new _math.Rectangle(0, 0, baseTexture.width, baseTexture.height);

              // if there is no frame we should monitor for any base texture changes..
              baseTexture.on("update", _this.onBaseTextureUpdated, _this);
            }
            _this.frame = frame;
          } else {
            baseTexture.once("loaded", _this.onBaseTextureLoaded, _this);
          }

          /**
           * Anchor point that is used as default if sprite is created with this texture.
           * Changing the `defaultAnchor` at a later point of time will not update Sprite's anchor point.
           * @member {PIXI.Point}
           * @default {0,0}
           */
          _this.defaultAnchor = anchor ? new _math.Point(anchor.x, anchor.y) : new _math.Point(0, 0);

          /**
           * Fired when the texture is updated. This happens if the frame or the baseTexture is updated.
           *
           * @event PIXI.Texture#update
           * @protected
           * @param {PIXI.Texture} texture - Instance of texture being updated.
           */

          _this._updateID = 0;

          /**
           * Contains data for uvs. May contain clamp settings and some matrices.
           * Its a bit heavy, so by default that object is not created.
           * @member {PIXI.TextureMatrix}
           * @default null
           */
          _this.transform = null;

          /**
           * The ids under which this Texture has been added to the texture cache. This is
           * automatically set as long as Texture.addToCache is used, but may not be set if a
           * Texture is added directly to the TextureCache array.
           *
           * @member {string[]}
           */
          _this.textureCacheIds = [];
          return _this;
        }

        /**
         * Updates this texture on the gpu.
         *
         */

        Texture.prototype.update = function update() {
          this.baseTexture.update();
        };

        /**
         * Called when the base texture is loaded
         *
         * @private
         * @param {PIXI.BaseTexture} baseTexture - The base texture.
         */

        Texture.prototype.onBaseTextureLoaded = function onBaseTextureLoaded(baseTexture) {
          this._updateID++;

          // TODO this code looks confusing.. boo to abusing getters and setters!
          if (this.noFrame) {
            this.frame = new _math.Rectangle(0, 0, baseTexture.width, baseTexture.height);
          } else {
            this.frame = this._frame;
          }

          this.baseTexture.on("update", this.onBaseTextureUpdated, this);
          this.emit("update", this);
        };

        /**
         * Called when the base texture is updated
         *
         * @private
         * @param {PIXI.BaseTexture} baseTexture - The base texture.
         */

        Texture.prototype.onBaseTextureUpdated = function onBaseTextureUpdated(baseTexture) {
          this._updateID++;

          this._frame.width = baseTexture.width;
          this._frame.height = baseTexture.height;

          this.emit("update", this);
        };

        /**
         * Destroys this texture
         *
         * @param {boolean} [destroyBase=false] Whether to destroy the base texture as well
         */

        Texture.prototype.destroy = function destroy(destroyBase) {
          if (this.baseTexture) {
            if (destroyBase) {
              // delete the texture if it exists in the texture cache..
              // this only needs to be removed if the base texture is actually destroyed too..
              if (_utils.TextureCache[this.baseTexture.imageUrl]) {
                Texture.removeFromCache(this.baseTexture.imageUrl);
              }

              this.baseTexture.destroy();
            }

            this.baseTexture.off("update", this.onBaseTextureUpdated, this);
            this.baseTexture.off("loaded", this.onBaseTextureLoaded, this);

            this.baseTexture = null;
          }

          this._frame = null;
          this._uvs = null;
          this.trim = null;
          this.orig = null;

          this.valid = false;

          Texture.removeFromCache(this);
          this.textureCacheIds = null;
        };

        /**
         * Creates a new texture object that acts the same as this one.
         *
         * @return {PIXI.Texture} The new texture
         */

        Texture.prototype.clone = function clone() {
          return new Texture(this.baseTexture, this.frame, this.orig, this.trim, this.rotate, this.defaultAnchor);
        };

        /**
         * Updates the internal WebGL UV cache. Use it after you change `frame` or `trim` of the texture.
         */

        Texture.prototype._updateUvs = function _updateUvs() {
          if (!this._uvs) {
            this._uvs = new _TextureUvs2.default();
          }

          this._uvs.set(this._frame, this.baseTexture, this.rotate);

          this._updateID++;
        };

        /**
         * Helper function that creates a Texture object from the given image url.
         * If the image is not in the texture cache it will be  created and loaded.
         *
         * @static
         * @param {string} imageUrl - The image url of the texture
         * @param {boolean} [crossorigin] - Whether requests should be treated as crossorigin
         * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
         * @param {number} [sourceScale=(auto)] - Scale for the original image, used with SVG images.
         * @return {PIXI.Texture} The newly created texture
         */

        Texture.fromImage = function fromImage(imageUrl, crossorigin, scaleMode, sourceScale) {
          let texture = _utils.TextureCache[imageUrl];

          if (!texture) {
            texture = new Texture(_BaseTexture2.default.fromImage(imageUrl, crossorigin, scaleMode, sourceScale));
            Texture.addToCache(texture, imageUrl);
          }

          return texture;
        };

        /**
         * Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId
         * The frame ids are created when a Texture packer file has been loaded
         *
         * @static
         * @param {string} frameId - The frame Id of the texture in the cache
         * @return {PIXI.Texture} The newly created texture
         */

        Texture.fromFrame = function fromFrame(frameId) {
          let texture = _utils.TextureCache[frameId];

          if (!texture) {
            throw new Error('The frameId "' + frameId + '" does not exist in the texture cache');
          }

          return texture;
        };

        /**
         * Helper function that creates a new Texture based on the given canvas element.
         *
         * @static
         * @param {HTMLCanvasElement} canvas - The canvas element source of the texture
         * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
         * @param {string} [origin='canvas'] - A string origin of who created the base texture
         * @return {PIXI.Texture} The newly created texture
         */

        Texture.fromCanvas = function fromCanvas(canvas, scaleMode) {
          let origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "canvas";

          return new Texture(_BaseTexture2.default.fromCanvas(canvas, scaleMode, origin));
        };

        /**
         * Helper function that creates a new Texture based on the given video element.
         *
         * @static
         * @param {HTMLVideoElement|string} video - The URL or actual element of the video
         * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
         * @param {boolean} [crossorigin=(auto)] - Should use anonymous CORS? Defaults to true if the URL is not a data-URI.
         * @param {boolean} [autoPlay=true] - Start playing video as soon as it is loaded
         * @return {PIXI.Texture} The newly created texture
         */

        Texture.fromVideo = function fromVideo(video, scaleMode, crossorigin, autoPlay) {
          if (typeof video === "string") {
            return Texture.fromVideoUrl(video, scaleMode, crossorigin, autoPlay);
          }

          return new Texture(_VideoBaseTexture2.default.fromVideo(video, scaleMode, autoPlay));
        };

        /**
         * Helper function that creates a new Texture based on the video url.
         *
         * @static
         * @param {string} videoUrl - URL of the video
         * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
         * @param {boolean} [crossorigin=(auto)] - Should use anonymous CORS? Defaults to true if the URL is not a data-URI.
         * @param {boolean} [autoPlay=true] - Start playing video as soon as it is loaded
         * @return {PIXI.Texture} The newly created texture
         */

        Texture.fromVideoUrl = function fromVideoUrl(videoUrl, scaleMode, crossorigin, autoPlay) {
          return new Texture(_VideoBaseTexture2.default.fromUrl(videoUrl, scaleMode, crossorigin, autoPlay));
        };

        /**
         * Helper function that creates a new Texture based on the source you provide.
         * The source can be - frame id, image url, video url, canvas element, video element, base texture
         *
         * @static
         * @param {number|string|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|PIXI.BaseTexture}
         *        source - Source to create texture from
         * @return {PIXI.Texture} The newly created texture
         */

        Texture.from = function from(source) {
          // TODO auto detect cross origin..
          // TODO pass in scale mode?
          if (typeof source === "string") {
            let texture = _utils.TextureCache[source];

            if (!texture) {
              // check if its a video..
              let isVideo = source.match(/\.(mp4|webm|ogg|h264|avi|mov)$/) !== null;

              if (isVideo) {
                return Texture.fromVideoUrl(source);
              }

              return Texture.fromImage(source);
            }

            return texture;
          } else if (source instanceof HTMLImageElement) {
            return new Texture(_BaseTexture2.default.from(source));
          } else if (source instanceof HTMLCanvasElement) {
            return Texture.fromCanvas(source, _settings2.default.SCALE_MODE, "HTMLCanvasElement");
          } else if (source instanceof HTMLVideoElement) {
            return Texture.fromVideo(source);
          } else if (source instanceof _BaseTexture2.default) {
            return new Texture(source);
          }

          // lets assume its a texture!
          return source;
        };

        /**
         * Create a texture from a source and add to the cache.
         *
         * @static
         * @param {HTMLImageElement|HTMLCanvasElement} source - The input source.
         * @param {String} imageUrl - File name of texture, for cache and resolving resolution.
         * @param {String} [name] - Human readible name for the texture cache. If no name is
         *        specified, only `imageUrl` will be used as the cache ID.
         * @return {PIXI.Texture} Output texture
         */

        Texture.fromLoader = function fromLoader(source, imageUrl, name) {
          let baseTexture = new _BaseTexture2.default(source, undefined, (0, _utils.getResolutionOfUrl)(imageUrl));
          let texture = new Texture(baseTexture);

          baseTexture.imageUrl = imageUrl;

          // No name, use imageUrl instead
          if (!name) {
            name = imageUrl;
          }

          // lets also add the frame to pixi's global cache for fromFrame and fromImage fucntions
          _BaseTexture2.default.addToCache(texture.baseTexture, name);
          Texture.addToCache(texture, name);

          // also add references by url if they are different.
          if (name !== imageUrl) {
            _BaseTexture2.default.addToCache(texture.baseTexture, imageUrl);
            Texture.addToCache(texture, imageUrl);
          }

          return texture;
        };

        /**
         * Adds a Texture to the global TextureCache. This cache is shared across the whole PIXI object.
         *
         * @static
         * @param {PIXI.Texture} texture - The Texture to add to the cache.
         * @param {string} id - The id that the Texture will be stored against.
         */

        Texture.addToCache = function addToCache(texture, id) {
          if (id) {
            if (texture.textureCacheIds.indexOf(id) === -1) {
              texture.textureCacheIds.push(id);
            }

            // @if DEBUG
            /* eslint-disable no-console */
            if (_utils.TextureCache[id]) {
              console.warn("Texture added to the cache with an id [" + id + "] that already had an entry");
            }
            /* eslint-enable no-console */
            // @endif

            _utils.TextureCache[id] = texture;
          }
        };

        /**
         * Remove a Texture from the global TextureCache.
         *
         * @static
         * @param {string|PIXI.Texture} texture - id of a Texture to be removed, or a Texture instance itself
         * @return {PIXI.Texture|null} The Texture that was removed
         */

        Texture.removeFromCache = function removeFromCache(texture) {
          if (typeof texture === "string") {
            let textureFromCache = _utils.TextureCache[texture];

            if (textureFromCache) {
              let index = textureFromCache.textureCacheIds.indexOf(texture);

              if (index > -1) {
                textureFromCache.textureCacheIds.splice(index, 1);
              }

              delete _utils.TextureCache[texture];

              return textureFromCache;
            }
          } else if (texture && texture.textureCacheIds) {
            for (let i = 0; i < texture.textureCacheIds.length; ++i) {
              // Check that texture matches the one being passed in before deleting it from the cache.
              if (_utils.TextureCache[texture.textureCacheIds[i]] === texture) {
                delete _utils.TextureCache[texture.textureCacheIds[i]];
              }
            }

            texture.textureCacheIds.length = 0;

            return texture;
          }

          return null;
        };

        /**
         * The frame specifies the region of the base texture that this texture uses.
         * Please call `_updateUvs()` after you change coordinates of `frame` manually.
         *
         * @member {PIXI.Rectangle}
         */

        _createClass(Texture, [
          {
            key: "frame",
            get: function get() {
              return this._frame;
            },
            set: function set(
              frame // eslint-disable-line require-jsdoc
            ) {
              this._frame = frame;

              this.noFrame = false;

              let x = frame.x,
                y = frame.y,
                width = frame.width,
                height = frame.height;

              let xNotFit = x + width > this.baseTexture.width;
              let yNotFit = y + height > this.baseTexture.height;

              if (xNotFit || yNotFit) {
                let relationship = xNotFit && yNotFit ? "and" : "or";
                let errorX = "X: " + x + " + " + width + " = " + (x + width) + " > " + this.baseTexture.width;
                let errorY = "Y: " + y + " + " + height + " = " + (y + height) + " > " + this.baseTexture.height;

                throw new Error(
                  "Texture Error: frame does not fit inside the base Texture dimensions: " + (errorX + " " + relationship + " " + errorY)
                );
              }

              // this.valid = width && height && this.baseTexture.source && this.baseTexture.hasLoaded;
              this.valid = width && height && this.baseTexture.hasLoaded;

              if (!this.trim && !this.rotate) {
                this.orig = frame;
              }

              if (this.valid) {
                this._updateUvs();
              }
            },

            /**
             * Indicates whether the texture is rotated inside the atlas
             * set to 2 to compensate for texture packer rotation
             * set to 6 to compensate for spine packer rotation
             * can be used to rotate or mirror sprites
             * See {@link PIXI.GroupD8} for explanation
             *
             * @member {number}
             */
          },
          {
            key: "rotate",
            get: function get() {
              return this._rotate;
            },
            set: function set(
              rotate // eslint-disable-line require-jsdoc
            ) {
              this._rotate = rotate;
              if (this.valid) {
                this._updateUvs();
              }
            },

            /**
             * The width of the Texture in pixels.
             *
             * @member {number}
             */
          },
          {
            key: "width",
            get: function get() {
              return this.orig.width;
            },

            /**
             * The height of the Texture in pixels.
             *
             * @member {number}
             */
          },
          {
            key: "height",
            get: function get() {
              return this.orig.height;
            },
          },
        ]);

        return Texture;
      })(_eventemitter2.default);

      exports.default = Texture;

      function createWhiteTexture() {
        let canvas = document.createElement("canvas");

        canvas.width = 10;
        canvas.height = 10;

        let context = canvas.getContext("2d");

        context.fillStyle = "white";
        context.fillRect(0, 0, 10, 10);

        return new Texture(new _BaseTexture2.default(canvas));
      }

      function removeAllHandlers(tex) {
        tex.destroy = function _emptyDestroy() {
          /* empty */
        };
        tex.on = function _emptyOn() {
          /* empty */
        };
        tex.once = function _emptyOnce() {
          /* empty */
        };
        tex.emit = function _emptyEmit() {
          /* empty */
        };
      }

      /**
       * An empty texture, used often to not have to create multiple empty textures.
       * Can not be destroyed.
       *
       * @static
       * @constant
       */
      Texture.EMPTY = new Texture(new _BaseTexture2.default());
      removeAllHandlers(Texture.EMPTY);
      removeAllHandlers(Texture.EMPTY.baseTexture);

      /**
       * A white texture of 10x10 size, used for graphics and other things
       * Can not be destroyed.
       *
       * @static
       * @constant
       */
      Texture.WHITE = createWhiteTexture();
      removeAllHandlers(Texture.WHITE);
      removeAllHandlers(Texture.WHITE.baseTexture);
      //# sourceMappingURL=Texture.js.map

      /***/
    },
    /* 354 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      let has = Object.prototype.hasOwnProperty,
        prefix = "~";

      /**
       * Constructor to create a storage for our `EE` objects.
       * An `Events` instance is a plain object whose properties are event names.
       *
       * @constructor
       * @api private
       */
      function Events() {}

      //
      // We try to not inherit from `Object.prototype`. In some engines creating an
      // instance in this way is faster than calling `Object.create(null)` directly.
      // If `Object.create(null)` is not supported we prefix the event names with a
      // character to make sure that the built-in object properties are not
      // overridden or used as an attack vector.
      //
      if (Object.create) {
        Events.prototype = Object.create(null);

        //
        // This hack is needed because the `__proto__` property is still inherited in
        // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
        //
        if (!new Events().__proto__) prefix = false;
      }

      /**
       * Representation of a single event listener.
       *
       * @param {Function} fn The listener function.
       * @param {Mixed} context The context to invoke the listener with.
       * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
       * @constructor
       * @api private
       */
      function EE(fn, context, once) {
        this.fn = fn;
        this.context = context;
        this.once = once || false;
      }

      /**
       * Minimal `EventEmitter` interface that is molded against the Node.js
       * `EventEmitter` interface.
       *
       * @constructor
       * @api public
       */
      function EventEmitter() {
        this._events = new Events();
        this._eventsCount = 0;
      }

      /**
       * Return an array listing the events for which the emitter has registered
       * listeners.
       *
       * @returns {Array}
       * @api public
       */
      EventEmitter.prototype.eventNames = function eventNames() {
        let names = [],
          events,
          name;

        if (this._eventsCount === 0) return names;

        for (name in (events = this._events)) {
          if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
        }

        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events));
        }

        return names;
      };

      /**
       * Return the listeners registered for a given event.
       *
       * @param {String|Symbol} event The event name.
       * @param {Boolean} exists Only check if there are listeners.
       * @returns {Array|Boolean}
       * @api public
       */
      EventEmitter.prototype.listeners = function listeners(event, exists) {
        let evt = prefix ? prefix + event : event,
          available = this._events[evt];

        if (exists) return !!available;
        if (!available) return [];
        if (available.fn) return [available.fn];

        for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {
          ee[i] = available[i].fn;
        }

        return ee;
      };

      /**
       * Calls each of the listeners registered for a given event.
       *
       * @param {String|Symbol} event The event name.
       * @returns {Boolean} `true` if the event had listeners, else `false`.
       * @api public
       */
      EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
        let evt = prefix ? prefix + event : event;

        if (!this._events[evt]) return false;

        let listeners = this._events[evt],
          len = arguments.length,
          args,
          i;

        if (listeners.fn) {
          if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }

          for (i = 1, args = new Array(len - 1); i < len; i++) {
            args[i - 1] = arguments[i];
          }

          listeners.fn.apply(listeners.context, args);
        } else {
          let length = listeners.length,
            j;

          for (i = 0; i < length; i++) {
            if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

            switch (len) {
              case 1:
                listeners[i].fn.call(listeners[i].context);
                break;
              case 2:
                listeners[i].fn.call(listeners[i].context, a1);
                break;
              case 3:
                listeners[i].fn.call(listeners[i].context, a1, a2);
                break;
              case 4:
                listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                break;
              default:
                if (!args)
                  for (j = 1, args = new Array(len - 1); j < len; j++) {
                    args[j - 1] = arguments[j];
                  }

                listeners[i].fn.apply(listeners[i].context, args);
            }
          }
        }

        return true;
      };

      /**
       * Add a listener for a given event.
       *
       * @param {String|Symbol} event The event name.
       * @param {Function} fn The listener function.
       * @param {Mixed} [context=this] The context to invoke the listener with.
       * @returns {EventEmitter} `this`.
       * @api public
       */
      EventEmitter.prototype.on = function on(event, fn, context) {
        let listener = new EE(fn, context || this),
          evt = prefix ? prefix + event : event;

        if (!this._events[evt]) (this._events[evt] = listener), this._eventsCount++;
        else if (!this._events[evt].fn) this._events[evt].push(listener);
        else this._events[evt] = [this._events[evt], listener];

        return this;
      };

      /**
       * Add a one-time listener for a given event.
       *
       * @param {String|Symbol} event The event name.
       * @param {Function} fn The listener function.
       * @param {Mixed} [context=this] The context to invoke the listener with.
       * @returns {EventEmitter} `this`.
       * @api public
       */
      EventEmitter.prototype.once = function once(event, fn, context) {
        let listener = new EE(fn, context || this, true),
          evt = prefix ? prefix + event : event;

        if (!this._events[evt]) (this._events[evt] = listener), this._eventsCount++;
        else if (!this._events[evt].fn) this._events[evt].push(listener);
        else this._events[evt] = [this._events[evt], listener];

        return this;
      };

      /**
       * Remove the listeners of a given event.
       *
       * @param {String|Symbol} event The event name.
       * @param {Function} fn Only remove the listeners that match this function.
       * @param {Mixed} context Only remove the listeners that have this context.
       * @param {Boolean} once Only remove one-time listeners.
       * @returns {EventEmitter} `this`.
       * @api public
       */
      EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
        let evt = prefix ? prefix + event : event;

        if (!this._events[evt]) return this;
        if (!fn) {
          if (--this._eventsCount === 0) this._events = new Events();
          else delete this._events[evt];
          return this;
        }

        let listeners = this._events[evt];

        if (listeners.fn) {
          if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
            if (--this._eventsCount === 0) this._events = new Events();
            else delete this._events[evt];
          }
        } else {
          for (var i = 0, events = [], length = listeners.length; i < length; i++) {
            if (listeners[i].fn !== fn || (once && !listeners[i].once) || (context && listeners[i].context !== context)) {
              events.push(listeners[i]);
            }
          }

          //
          // Reset the array, or remove it completely if we have no more listeners.
          //
          if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
          else if (--this._eventsCount === 0) this._events = new Events();
          else delete this._events[evt];
        }

        return this;
      };

      /**
       * Remove all listeners, or those of the specified event.
       *
       * @param {String|Symbol} [event] The event name.
       * @returns {EventEmitter} `this`.
       * @api public
       */
      EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
        let evt;

        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt]) {
            if (--this._eventsCount === 0) this._events = new Events();
            else delete this._events[evt];
          }
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }

        return this;
      };

      //
      // Alias methods names because people roll like that.
      //
      EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
      EventEmitter.prototype.addListener = EventEmitter.prototype.on;

      //
      // This function doesn't apply anymore.
      //
      EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
        return this;
      };

      //
      // Expose the prefix.
      //
      EventEmitter.prefixed = prefix;

      //
      // Allow `EventEmitter` to be imported as module namespace.
      //
      EventEmitter.EventEmitter = EventEmitter;

      //
      // Expose the module.
      //
      if (true) {
        module.exports = EventEmitter;
      }

      /***/
    },
    /* 355 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      let _utils = __webpack_require__(345);

      let _settings = __webpack_require__(346);

      let _settings2 = _interopRequireDefault(_settings);

      let _eventemitter = __webpack_require__(354);

      let _eventemitter2 = _interopRequireDefault(_eventemitter);

      let _determineCrossOrigin = __webpack_require__(407);

      let _determineCrossOrigin2 = _interopRequireDefault(_determineCrossOrigin);

      let _bitTwiddle = __webpack_require__(382);

      let _bitTwiddle2 = _interopRequireDefault(_bitTwiddle);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: { value: subClass, enumerable: false, writable: true, configurable: true },
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass);
      }

      /**
       * A texture stores the information that represents an image. All textures have a base texture.
       *
       * @class
       * @extends EventEmitter
       * @memberof PIXI
       */
      let BaseTexture = (function (_EventEmitter) {
        _inherits(BaseTexture, _EventEmitter);

        /**
         * @param {HTMLImageElement|HTMLCanvasElement} [source] - the source object of the texture.
         * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
         * @param {number} [resolution=1] - The resolution / device pixel ratio of the texture
         */
        function BaseTexture(source, scaleMode, resolution) {
          _classCallCheck(this, BaseTexture);

          let _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

          _this.uid = (0, _utils.uid)();

          _this.touched = 0;

          /**
           * The resolution / device pixel ratio of the texture
           *
           * @member {number}
           * @default 1
           */
          _this.resolution = resolution || _settings2.default.RESOLUTION;

          /**
           * The width of the base texture set when the image has loaded
           *
           * @readonly
           * @member {number}
           */
          _this.width = 100;

          /**
           * The height of the base texture set when the image has loaded
           *
           * @readonly
           * @member {number}
           */
          _this.height = 100;

          // TODO docs
          // used to store the actual dimensions of the source
          /**
           * Used to store the actual width of the source of this texture
           *
           * @readonly
           * @member {number}
           */
          _this.realWidth = 100;
          /**
           * Used to store the actual height of the source of this texture
           *
           * @readonly
           * @member {number}
           */
          _this.realHeight = 100;

          /**
           * The scale mode to apply when scaling this texture
           *
           * @member {number}
           * @default PIXI.settings.SCALE_MODE
           * @see PIXI.SCALE_MODES
           */
          _this.scaleMode = scaleMode !== undefined ? scaleMode : _settings2.default.SCALE_MODE;

          /**
           * Set to true once the base texture has successfully loaded.
           *
           * This is never true if the underlying source fails to load or has no texture data.
           *
           * @readonly
           * @member {boolean}
           */
          _this.hasLoaded = false;

          /**
           * Set to true if the source is currently loading.
           *
           * If an Image source is loading the 'loaded' or 'error' event will be
           * dispatched when the operation ends. An underyling source that is
           * immediately-available bypasses loading entirely.
           *
           * @readonly
           * @member {boolean}
           */
          _this.isLoading = false;

          /**
           * The image source that is used to create the texture.
           *
           * TODO: Make this a setter that calls loadSource();
           *
           * @readonly
           * @member {HTMLImageElement|HTMLCanvasElement}
           */
          _this.source = null; // set in loadSource, if at all

          /**
           * The image source that is used to create the texture. This is used to
           * store the original Svg source when it is replaced with a canvas element.
           *
           * TODO: Currently not in use but could be used when re-scaling svg.
           *
           * @readonly
           * @member {Image}
           */
          _this.origSource = null; // set in loadSvg, if at all

          /**
           * Type of image defined in source, eg. `png` or `svg`
           *
           * @readonly
           * @member {string}
           */
          _this.imageType = null; // set in updateImageType

          /**
           * Scale for source image. Used with Svg images to scale them before rasterization.
           *
           * @readonly
           * @member {number}
           */
          _this.sourceScale = 1.0;

          /**
           * Controls if RGB channels should be pre-multiplied by Alpha  (WebGL only)
           * All blend modes, and shaders written for default value. Change it on your own risk.
           *
           * @member {boolean}
           * @default true
           */
          _this.premultipliedAlpha = true;

          /**
           * The image url of the texture
           *
           * @member {string}
           */
          _this.imageUrl = null;

          /**
           * Whether or not the texture is a power of two, try to use power of two textures as much
           * as you can
           *
           * @private
           * @member {boolean}
           */
          _this.isPowerOfTwo = false;

          // used for webGL

          /**
           *
           * Set this to true if a mipmap of this texture needs to be generated. This value needs
           * to be set before the texture is used
           * Also the texture must be a power of two size to work
           *
           * @member {boolean}
           * @see PIXI.MIPMAP_TEXTURES
           */
          _this.mipmap = _settings2.default.MIPMAP_TEXTURES;

          /**
           *
           * WebGL Texture wrap mode
           *
           * @member {number}
           * @see PIXI.WRAP_MODES
           */
          _this.wrapMode = _settings2.default.WRAP_MODE;

          /**
           * A map of renderer IDs to webgl textures
           *
           * @private
           * @member {object<number, WebGLTexture>}
           */
          _this._glTextures = {};

          _this._enabled = 0;
          _this._virtalBoundId = -1;

          /**
           * If the object has been destroyed via destroy(). If true, it should not be used.
           *
           * @member {boolean}
           * @private
           * @readonly
           */
          _this._destroyed = false;

          /**
           * The ids under which this BaseTexture has been added to the base texture cache. This is
           * automatically set as long as BaseTexture.addToCache is used, but may not be set if a
           * BaseTexture is added directly to the BaseTextureCache array.
           *
           * @member {string[]}
           */
          _this.textureCacheIds = [];

          // if no source passed don't try to load
          if (source) {
            _this.loadSource(source);
          }

          /**
           * Fired when a not-immediately-available source finishes loading.
           *
           * @protected
           * @event PIXI.BaseTexture#loaded
           * @param {PIXI.BaseTexture} baseTexture - Resource loaded.
           */

          /**
           * Fired when a not-immediately-available source fails to load.
           *
           * @protected
           * @event PIXI.BaseTexture#error
           * @param {PIXI.BaseTexture} baseTexture - Resource errored.
           */

          /**
           * Fired when BaseTexture is updated.
           *
           * @protected
           * @event PIXI.BaseTexture#update
           * @param {PIXI.BaseTexture} baseTexture - Instance of texture being updated.
           */

          /**
           * Fired when BaseTexture is destroyed.
           *
           * @protected
           * @event PIXI.BaseTexture#dispose
           * @param {PIXI.BaseTexture} baseTexture - Instance of texture being destroyed.
           */
          return _this;
        }

        /**
         * Updates the texture on all the webgl renderers, this also assumes the src has changed.
         *
         * @fires PIXI.BaseTexture#update
         */

        BaseTexture.prototype.update = function update() {
          // Svg size is handled during load
          if (this.imageType !== "svg") {
            this.realWidth = this.source.naturalWidth || this.source.videoWidth || this.source.width;
            this.realHeight = this.source.naturalHeight || this.source.videoHeight || this.source.height;

            this._updateDimensions();
          }

          this.emit("update", this);
        };

        /**
         * Update dimensions from real values
         */

        BaseTexture.prototype._updateDimensions = function _updateDimensions() {
          this.width = this.realWidth / this.resolution;
          this.height = this.realHeight / this.resolution;

          this.isPowerOfTwo = _bitTwiddle2.default.isPow2(this.realWidth) && _bitTwiddle2.default.isPow2(this.realHeight);
        };

        /**
         * Load a source.
         *
         * If the source is not-immediately-available, such as an image that needs to be
         * downloaded, then the 'loaded' or 'error' event will be dispatched in the future
         * and `hasLoaded` will remain false after this call.
         *
         * The logic state after calling `loadSource` directly or indirectly (eg. `fromImage`, `new BaseTexture`) is:
         *
         *     if (texture.hasLoaded) {
         *        // texture ready for use
         *     } else if (texture.isLoading) {
         *        // listen to 'loaded' and/or 'error' events on texture
         *     } else {
         *        // not loading, not going to load UNLESS the source is reloaded
         *        // (it may still make sense to listen to the events)
         *     }
         *
         * @protected
         * @param {HTMLImageElement|HTMLCanvasElement} source - the source object of the texture.
         */

        BaseTexture.prototype.loadSource = function loadSource(source) {
          let wasLoading = this.isLoading;

          this.hasLoaded = false;
          this.isLoading = false;

          if (wasLoading && this.source) {
            this.source.onload = null;
            this.source.onerror = null;
          }

          let firstSourceLoaded = !this.source;

          this.source = source;

          // Apply source if loaded. Otherwise setup appropriate loading monitors.
          if (((source.src && source.complete) || source.getContext) && source.width && source.height) {
            this._updateImageType();

            if (this.imageType === "svg") {
              this._loadSvgSource();
            } else {
              this._sourceLoaded();
            }

            if (firstSourceLoaded) {
              // send loaded event if previous source was null and we have been passed a pre-loaded IMG element
              this.emit("loaded", this);
            }
          } else if (!source.getContext) {
            // Image fail / not ready
            this.isLoading = true;

            let scope = this;

            source.onload = function () {
              scope._updateImageType();
              source.onload = null;
              source.onerror = null;

              if (!scope.isLoading) {
                return;
              }

              scope.isLoading = false;
              scope._sourceLoaded();

              if (scope.imageType === "svg") {
                scope._loadSvgSource();

                return;
              }

              scope.emit("loaded", scope);
            };

            source.onerror = function () {
              source.onload = null;
              source.onerror = null;

              if (!scope.isLoading) {
                return;
              }

              scope.isLoading = false;
              scope.emit("error", scope);
            };

            // Per http://www.w3.org/TR/html5/embedded-content-0.html#the-img-element
            //   "The value of `complete` can thus change while a script is executing."
            // So complete needs to be re-checked after the callbacks have been added..
            // NOTE: complete will be true if the image has no src so best to check if the src is set.
            if (source.complete && source.src) {
              // ..and if we're complete now, no need for callbacks
              source.onload = null;
              source.onerror = null;

              if (scope.imageType === "svg") {
                scope._loadSvgSource();

                return;
              }

              this.isLoading = false;

              if (source.width && source.height) {
                this._sourceLoaded();

                // If any previous subscribers possible
                if (wasLoading) {
                  this.emit("loaded", this);
                }
              }
              // If any previous subscribers possible
              else if (wasLoading) {
                this.emit("error", this);
              }
            }
          }
        };

        /**
         * Updates type of the source image.
         */

        BaseTexture.prototype._updateImageType = function _updateImageType() {
          if (!this.imageUrl) {
            return;
          }

          let dataUri = (0, _utils.decomposeDataUri)(this.imageUrl);
          let imageType = void 0;

          if (dataUri && dataUri.mediaType === "image") {
            // Check for subType validity
            let firstSubType = dataUri.subType.split("+")[0];

            imageType = (0, _utils.getUrlFileExtension)("." + firstSubType);

            if (!imageType) {
              throw new Error("Invalid image type in data URI.");
            }
          } else {
            imageType = (0, _utils.getUrlFileExtension)(this.imageUrl);

            if (!imageType) {
              imageType = "png";
            }
          }

          this.imageType = imageType;
        };

        /**
         * Checks if `source` is an SVG image and whether it's loaded via a URL or a data URI. Then calls
         * `_loadSvgSourceUsingDataUri` or `_loadSvgSourceUsingXhr`.
         */

        BaseTexture.prototype._loadSvgSource = function _loadSvgSource() {
          if (this.imageType !== "svg") {
            // Do nothing if source is not svg
            return;
          }

          let dataUri = (0, _utils.decomposeDataUri)(this.imageUrl);

          if (dataUri) {
            this._loadSvgSourceUsingDataUri(dataUri);
          } else {
            // We got an URL, so we need to do an XHR to check the svg size
            this._loadSvgSourceUsingXhr();
          }
        };

        /**
         * Reads an SVG string from data URI and then calls `_loadSvgSourceUsingString`.
         *
         * @param {string} dataUri - The data uri to load from.
         */

        BaseTexture.prototype._loadSvgSourceUsingDataUri = function _loadSvgSourceUsingDataUri(dataUri) {
          let svgString = void 0;

          if (dataUri.encoding === "base64") {
            if (!atob) {
              throw new Error("Your browser doesn't support base64 conversions.");
            }
            svgString = atob(dataUri.data);
          } else {
            svgString = dataUri.data;
          }

          this._loadSvgSourceUsingString(svgString);
        };

        /**
         * Loads an SVG string from `imageUrl` using XHR and then calls `_loadSvgSourceUsingString`.
         */

        BaseTexture.prototype._loadSvgSourceUsingXhr = function _loadSvgSourceUsingXhr() {
          let _this2 = this;

          let svgXhr = new XMLHttpRequest();

          // This throws error on IE, so SVG Document can't be used
          // svgXhr.responseType = 'document';

          // This is not needed since we load the svg as string (breaks IE too)
          // but overrideMimeType() can be used to force the response to be parsed as XML
          // svgXhr.overrideMimeType('image/svg+xml');

          svgXhr.onload = function () {
            if (svgXhr.readyState !== svgXhr.DONE || svgXhr.status !== 200) {
              throw new Error("Failed to load SVG using XHR.");
            }

            _this2._loadSvgSourceUsingString(svgXhr.response);
          };

          svgXhr.onerror = function () {
            return _this2.emit("error", _this2);
          };

          svgXhr.open("GET", this.imageUrl, true);
          svgXhr.send();
        };

        /**
         * Loads texture using an SVG string. The original SVG Image is stored as `origSource` and the
         * created canvas is the new `source`. The SVG is scaled using `sourceScale`. Called by
         * `_loadSvgSourceUsingXhr` or `_loadSvgSourceUsingDataUri`.
         *
         * @param  {string} svgString SVG source as string
         *
         * @fires PIXI.BaseTexture#loaded
         */

        BaseTexture.prototype._loadSvgSourceUsingString = function _loadSvgSourceUsingString(svgString) {
          let svgSize = (0, _utils.getSvgSize)(svgString);

          let svgWidth = svgSize.width;
          let svgHeight = svgSize.height;

          if (!svgWidth || !svgHeight) {
            throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
          }

          // Scale realWidth and realHeight
          this.realWidth = Math.round(svgWidth * this.sourceScale);
          this.realHeight = Math.round(svgHeight * this.sourceScale);

          this._updateDimensions();

          // Create a canvas element
          let canvas = document.createElement("canvas");

          canvas.width = this.realWidth;
          canvas.height = this.realHeight;
          canvas._pixiId = "canvas_" + (0, _utils.uid)();

          // Draw the Svg to the canvas
          canvas.getContext("2d").drawImage(this.source, 0, 0, svgWidth, svgHeight, 0, 0, this.realWidth, this.realHeight);

          // Replace the original source image with the canvas
          this.origSource = this.source;
          this.source = canvas;

          // Add also the canvas in cache (destroy clears by `imageUrl` and `source._pixiId`)
          BaseTexture.addToCache(this, canvas._pixiId);

          this.isLoading = false;
          this._sourceLoaded();
          this.emit("loaded", this);
        };

        /**
         * Used internally to update the width, height, and some other tracking vars once
         * a source has successfully loaded.
         *
         * @private
         */

        BaseTexture.prototype._sourceLoaded = function _sourceLoaded() {
          this.hasLoaded = true;
          this.update();
        };

        /**
         * Destroys this base texture
         *
         */

        BaseTexture.prototype.destroy = function destroy() {
          if (this.imageUrl) {
            delete _utils.TextureCache[this.imageUrl];

            this.imageUrl = null;

            if (!navigator.isCocoonJS) {
              this.source.src = "";
            }
          }

          this.source = null;

          this.dispose();

          BaseTexture.removeFromCache(this);
          this.textureCacheIds = null;

          this._destroyed = true;
        };

        /**
         * Frees the texture from WebGL memory without destroying this texture object.
         * This means you can still use the texture later which will upload it to GPU
         * memory again.
         *
         * @fires PIXI.BaseTexture#dispose
         */

        BaseTexture.prototype.dispose = function dispose() {
          this.emit("dispose", this);
        };

        /**
         * Changes the source image of the texture.
         * The original source must be an Image element.
         *
         * @param {string} newSrc - the path of the image
         */

        BaseTexture.prototype.updateSourceImage = function updateSourceImage(newSrc) {
          this.source.src = newSrc;

          this.loadSource(this.source);
        };

        /**
         * Helper function that creates a base texture from the given image url.
         * If the image is not in the base texture cache it will be created and loaded.
         *
         * @static
         * @param {string} imageUrl - The image url of the texture
         * @param {boolean} [crossorigin=(auto)] - Should use anonymous CORS? Defaults to true if the URL is not a data-URI.
         * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
         * @param {number} [sourceScale=(auto)] - Scale for the original image, used with Svg images.
         * @return {PIXI.BaseTexture} The new base texture.
         */

        BaseTexture.fromImage = function fromImage(imageUrl, crossorigin, scaleMode, sourceScale) {
          let baseTexture = _utils.BaseTextureCache[imageUrl];

          if (!baseTexture) {
            // new Image() breaks tex loading in some versions of Chrome.
            // See https://code.google.com/p/chromium/issues/detail?id=238071
            let image = new Image(); // document.createElement('img');

            if (crossorigin === undefined && imageUrl.indexOf("data:") !== 0) {
              image.crossOrigin = (0, _determineCrossOrigin2.default)(imageUrl);
            } else if (crossorigin) {
              image.crossOrigin = typeof crossorigin === "string" ? crossorigin : "anonymous";
            }

            baseTexture = new BaseTexture(image, scaleMode);
            baseTexture.imageUrl = imageUrl;

            if (sourceScale) {
              baseTexture.sourceScale = sourceScale;
            }

            // if there is an @2x at the end of the url we are going to assume its a highres image
            baseTexture.resolution = (0, _utils.getResolutionOfUrl)(imageUrl);

            image.src = imageUrl; // Setting this triggers load

            BaseTexture.addToCache(baseTexture, imageUrl);
          }

          return baseTexture;
        };

        /**
         * Helper function that creates a base texture from the given canvas element.
         *
         * @static
         * @param {HTMLCanvasElement} canvas - The canvas element source of the texture
         * @param {number} scaleMode - See {@link PIXI.SCALE_MODES} for possible values
         * @param {string} [origin='canvas'] - A string origin of who created the base texture
         * @return {PIXI.BaseTexture} The new base texture.
         */

        BaseTexture.fromCanvas = function fromCanvas(canvas, scaleMode) {
          let origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "canvas";

          if (!canvas._pixiId) {
            canvas._pixiId = origin + "_" + (0, _utils.uid)();
          }

          let baseTexture = _utils.BaseTextureCache[canvas._pixiId];

          if (!baseTexture) {
            baseTexture = new BaseTexture(canvas, scaleMode);
            BaseTexture.addToCache(baseTexture, canvas._pixiId);
          }

          return baseTexture;
        };

        /**
         * Helper function that creates a base texture based on the source you provide.
         * The source can be - image url, image element, canvas element. If the
         * source is an image url or an image element and not in the base texture
         * cache, it will be created and loaded.
         *
         * @static
         * @param {string|HTMLImageElement|HTMLCanvasElement} source - The source to create base texture from.
         * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
         * @param {number} [sourceScale=(auto)] - Scale for the original image, used with Svg images.
         * @return {PIXI.BaseTexture} The new base texture.
         */

        BaseTexture.from = function from(source, scaleMode, sourceScale) {
          if (typeof source === "string") {
            return BaseTexture.fromImage(source, undefined, scaleMode, sourceScale);
          } else if (source instanceof HTMLImageElement) {
            let imageUrl = source.src;
            let baseTexture = _utils.BaseTextureCache[imageUrl];

            if (!baseTexture) {
              baseTexture = new BaseTexture(source, scaleMode);
              baseTexture.imageUrl = imageUrl;

              if (sourceScale) {
                baseTexture.sourceScale = sourceScale;
              }

              // if there is an @2x at the end of the url we are going to assume its a highres image
              baseTexture.resolution = (0, _utils.getResolutionOfUrl)(imageUrl);

              BaseTexture.addToCache(baseTexture, imageUrl);
            }

            return baseTexture;
          } else if (source instanceof HTMLCanvasElement) {
            return BaseTexture.fromCanvas(source, scaleMode);
          }

          // lets assume its a base texture!
          return source;
        };

        /**
         * Adds a BaseTexture to the global BaseTextureCache. This cache is shared across the whole PIXI object.
         *
         * @static
         * @param {PIXI.BaseTexture} baseTexture - The BaseTexture to add to the cache.
         * @param {string} id - The id that the BaseTexture will be stored against.
         */

        BaseTexture.addToCache = function addToCache(baseTexture, id) {
          if (id) {
            if (baseTexture.textureCacheIds.indexOf(id) === -1) {
              baseTexture.textureCacheIds.push(id);
            }

            // @if DEBUG
            /* eslint-disable no-console */
            if (_utils.BaseTextureCache[id]) {
              console.warn("BaseTexture added to the cache with an id [" + id + "] that already had an entry");
            }
            /* eslint-enable no-console */
            // @endif

            _utils.BaseTextureCache[id] = baseTexture;
          }
        };

        /**
         * Remove a BaseTexture from the global BaseTextureCache.
         *
         * @static
         * @param {string|PIXI.BaseTexture} baseTexture - id of a BaseTexture to be removed, or a BaseTexture instance itself.
         * @return {PIXI.BaseTexture|null} The BaseTexture that was removed.
         */

        BaseTexture.removeFromCache = function removeFromCache(baseTexture) {
          if (typeof baseTexture === "string") {
            let baseTextureFromCache = _utils.BaseTextureCache[baseTexture];

            if (baseTextureFromCache) {
              let index = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);

              if (index > -1) {
                baseTextureFromCache.textureCacheIds.splice(index, 1);
              }

              delete _utils.BaseTextureCache[baseTexture];

              return baseTextureFromCache;
            }
          } else if (baseTexture && baseTexture.textureCacheIds) {
            for (let i = 0; i < baseTexture.textureCacheIds.length; ++i) {
              delete _utils.BaseTextureCache[baseTexture.textureCacheIds[i]];
            }

            baseTexture.textureCacheIds.length = 0;

            return baseTexture;
          }

          return null;
        };

        return BaseTexture;
      })(_eventemitter2.default);

      exports.default = BaseTexture;
      //# sourceMappingURL=BaseTexture.js.map

      /***/
    },
    ,
    ,
    /* 356 */ /* 357 */ /* 358 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      let _createClass = (function () {
        function defineProperties(target, props) {
          for (let i = 0; i < props.length; i++) {
            let descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      })();

      let _utils = __webpack_require__(345);

      let _DisplayObject2 = __webpack_require__(404);

      let _DisplayObject3 = _interopRequireDefault(_DisplayObject2);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: { value: subClass, enumerable: false, writable: true, configurable: true },
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass);
      }

      /**
       * A Container represents a collection of display objects.
       * It is the base class of all display objects that act as a container for other objects.
       *
       *```js
       * let container = new PIXI.Container();
       * container.addChild(sprite);
       * ```
       *
       * @class
       * @extends PIXI.DisplayObject
       * @memberof PIXI
       */
      let Container = (function (_DisplayObject) {
        _inherits(Container, _DisplayObject);

        /**
         *
         */
        function Container() {
          _classCallCheck(this, Container);

          /**
           * The array of children of this container.
           *
           * @member {PIXI.DisplayObject[]}
           * @readonly
           */
          let _this = _possibleConstructorReturn(this, _DisplayObject.call(this));

          _this.children = [];
          return _this;
        }

        /**
         * Overridable method that can be used by Container subclasses whenever the children array is modified
         *
         * @private
         */

        Container.prototype.onChildrenChange = function onChildrenChange() {};
        /* empty */

        /**
         * Adds one or more children to the container.
         *
         * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`
         *
         * @param {...PIXI.DisplayObject} child - The DisplayObject(s) to add to the container
         * @return {PIXI.DisplayObject} The first child that was added.
         */

        Container.prototype.addChild = function addChild(child) {
          let argumentsLength = arguments.length;

          // if there is only one argument we can bypass looping through the them
          if (argumentsLength > 1) {
            // loop through the arguments property and add all children
            // use it the right way (.length and [i]) so that this function can still be optimised by JS runtimes
            for (let i = 0; i < argumentsLength; i++) {
              this.addChild(arguments[i]);
            }
          } else {
            // if the child has a parent then lets remove it as PixiJS objects can only exist in one place
            if (child.parent) {
              child.parent.removeChild(child);
            }

            child.parent = this;
            // ensure child transform will be recalculated
            child.transform._parentID = -1;

            this.children.push(child);

            // ensure bounds will be recalculated
            this._boundsID++;

            // TODO - lets either do all callbacks or all events.. not both!
            this.onChildrenChange(this.children.length - 1);
            child.emit("added", this);
          }

          return child;
        };

        /**
         * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown
         *
         * @param {PIXI.DisplayObject} child - The child to add
         * @param {number} index - The index to place the child in
         * @return {PIXI.DisplayObject} The child that was added.
         */

        Container.prototype.addChildAt = function addChildAt(child, index) {
          if (index < 0 || index > this.children.length) {
            throw new Error(child + "addChildAt: The index " + index + " supplied is out of bounds " + this.children.length);
          }

          if (child.parent) {
            child.parent.removeChild(child);
          }

          child.parent = this;
          // ensure child transform will be recalculated
          child.transform._parentID = -1;

          this.children.splice(index, 0, child);

          // ensure bounds will be recalculated
          this._boundsID++;

          // TODO - lets either do all callbacks or all events.. not both!
          this.onChildrenChange(index);
          child.emit("added", this);

          return child;
        };

        /**
         * Swaps the position of 2 Display Objects within this container.
         *
         * @param {PIXI.DisplayObject} child - First display object to swap
         * @param {PIXI.DisplayObject} child2 - Second display object to swap
         */

        Container.prototype.swapChildren = function swapChildren(child, child2) {
          if (child === child2) {
            return;
          }

          let index1 = this.getChildIndex(child);
          let index2 = this.getChildIndex(child2);

          this.children[index1] = child2;
          this.children[index2] = child;
          this.onChildrenChange(index1 < index2 ? index1 : index2);
        };

        /**
         * Returns the index position of a child DisplayObject instance
         *
         * @param {PIXI.DisplayObject} child - The DisplayObject instance to identify
         * @return {number} The index position of the child display object to identify
         */

        Container.prototype.getChildIndex = function getChildIndex(child) {
          let index = this.children.indexOf(child);

          if (index === -1) {
            throw new Error("The supplied DisplayObject must be a child of the caller");
          }

          return index;
        };

        /**
         * Changes the position of an existing child in the display object container
         *
         * @param {PIXI.DisplayObject} child - The child DisplayObject instance for which you want to change the index number
         * @param {number} index - The resulting index number for the child display object
         */

        Container.prototype.setChildIndex = function setChildIndex(child, index) {
          if (index < 0 || index >= this.children.length) {
            throw new Error("The index " + index + " supplied is out of bounds " + this.children.length);
          }

          let currentIndex = this.getChildIndex(child);

          (0, _utils.removeItems)(this.children, currentIndex, 1); // remove from old position
          this.children.splice(index, 0, child); // add at new position

          this.onChildrenChange(index);
        };

        /**
         * Returns the child at the specified index
         *
         * @param {number} index - The index to get the child at
         * @return {PIXI.DisplayObject} The child at the given index, if any.
         */

        Container.prototype.getChildAt = function getChildAt(index) {
          if (index < 0 || index >= this.children.length) {
            throw new Error("getChildAt: Index (" + index + ") does not exist.");
          }

          return this.children[index];
        };

        /**
         * Removes one or more children from the container.
         *
         * @param {...PIXI.DisplayObject} child - The DisplayObject(s) to remove
         * @return {PIXI.DisplayObject} The first child that was removed.
         */

        Container.prototype.removeChild = function removeChild(child) {
          let argumentsLength = arguments.length;

          // if there is only one argument we can bypass looping through the them
          if (argumentsLength > 1) {
            // loop through the arguments property and add all children
            // use it the right way (.length and [i]) so that this function can still be optimised by JS runtimes
            for (let i = 0; i < argumentsLength; i++) {
              this.removeChild(arguments[i]);
            }
          } else {
            let index = this.children.indexOf(child);

            if (index === -1) return null;

            child.parent = null;
            // ensure child transform will be recalculated
            child.transform._parentID = -1;
            (0, _utils.removeItems)(this.children, index, 1);

            // ensure bounds will be recalculated
            this._boundsID++;

            // TODO - lets either do all callbacks or all events.. not both!
            this.onChildrenChange(index);
            child.emit("removed", this);
          }

          return child;
        };

        /**
         * Removes a child from the specified index position.
         *
         * @param {number} index - The index to get the child from
         * @return {PIXI.DisplayObject} The child that was removed.
         */

        Container.prototype.removeChildAt = function removeChildAt(index) {
          let child = this.getChildAt(index);

          // ensure child transform will be recalculated..
          child.parent = null;
          child.transform._parentID = -1;
          (0, _utils.removeItems)(this.children, index, 1);

          // ensure bounds will be recalculated
          this._boundsID++;

          // TODO - lets either do all callbacks or all events.. not both!
          this.onChildrenChange(index);
          child.emit("removed", this);

          return child;
        };

        /**
         * Removes all children from this container that are within the begin and end indexes.
         *
         * @param {number} [beginIndex=0] - The beginning position.
         * @param {number} [endIndex=this.children.length] - The ending position. Default value is size of the container.
         * @returns {DisplayObject[]} List of removed children
         */

        Container.prototype.removeChildren = function removeChildren() {
          let beginIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
          let endIndex = arguments[1];

          let begin = beginIndex;
          let end = typeof endIndex === "number" ? endIndex : this.children.length;
          let range = end - begin;
          let removed = void 0;

          if (range > 0 && range <= end) {
            removed = this.children.splice(begin, range);

            for (let i = 0; i < removed.length; ++i) {
              removed[i].parent = null;
              if (removed[i].transform) {
                removed[i].transform._parentID = -1;
              }
            }

            this._boundsID++;

            this.onChildrenChange(beginIndex);

            for (let _i = 0; _i < removed.length; ++_i) {
              removed[_i].emit("removed", this);
            }

            return removed;
          } else if (range === 0 && this.children.length === 0) {
            return [];
          }

          throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
        };

        /**
         * Updates the transform on all children of this container for rendering
         */

        Container.prototype.updateTransform = function updateTransform() {
          this._boundsID++;

          this.transform.updateTransform(this.parent.transform);

          // TODO: check render flags, how to process stuff here
          this.worldAlpha = this.alpha * this.parent.worldAlpha;

          for (let i = 0, j = this.children.length; i < j; ++i) {
            let child = this.children[i];

            if (child.visible) {
              child.updateTransform();
            }
          }
        };

        /**
         * Recalculates the bounds of the container.
         *
         */

        Container.prototype.calculateBounds = function calculateBounds() {
          this._bounds.clear();

          this._calculateBounds();

          for (let i = 0; i < this.children.length; i++) {
            let child = this.children[i];

            if (!child.visible || !child.renderable) {
              continue;
            }

            child.calculateBounds();

            // TODO: filter+mask, need to mask both somehow
            if (child._mask) {
              child._mask.calculateBounds();
              this._bounds.addBoundsMask(child._bounds, child._mask._bounds);
            } else if (child.filterArea) {
              this._bounds.addBoundsArea(child._bounds, child.filterArea);
            } else {
              this._bounds.addBounds(child._bounds);
            }
          }

          this._lastBoundsID = this._boundsID;
        };

        /**
         * Recalculates the bounds of the object. Override this to
         * calculate the bounds of the specific object (not including children).
         *
         */

        Container.prototype._calculateBounds = function _calculateBounds() {};
        // FILL IN//

        /**
         * Renders the object using the WebGL renderer
         *
         * @param {PIXI.WebGLRenderer} renderer - The renderer
         */

        Container.prototype.renderWebGL = function renderWebGL(renderer) {
          // if the object is not visible or the alpha is 0 then no need to render this element
          if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
            return;
          }

          // do a quick check to see if this element has a mask or a filter.
          if (this._mask || (this.filters && this.filters.length)) {
            this.renderAdvancedWebGL(renderer);
          } else {
            this._renderWebGL(renderer);

            // simple render children!
            for (let i = 0, j = this.children.length; i < j; ++i) {
              this.children[i].renderWebGL(renderer);
            }
          }
        };

        /**
         * Render the object using the WebGL renderer and advanced features.
         *
         * @private
         * @param {PIXI.WebGLRenderer} renderer - The renderer
         */

        Container.prototype.renderAdvancedWebGL = function renderAdvancedWebGL(renderer) {
          renderer.flush();

          let filters = this._filters;
          let mask = this._mask;

          // push filter first as we need to ensure the stencil buffer is correct for any masking
          if (filters) {
            if (!this._enabledFilters) {
              this._enabledFilters = [];
            }

            this._enabledFilters.length = 0;

            for (let i = 0; i < filters.length; i++) {
              if (filters[i].enabled) {
                this._enabledFilters.push(filters[i]);
              }
            }

            if (this._enabledFilters.length) {
              renderer.filterManager.pushFilter(this, this._enabledFilters);
            }
          }

          if (mask) {
            renderer.maskManager.pushMask(this, this._mask);
          }

          // add this object to the batch, only rendered if it has a texture.
          this._renderWebGL(renderer);

          // now loop through the children and make sure they get rendered
          for (let _i2 = 0, j = this.children.length; _i2 < j; _i2++) {
            this.children[_i2].renderWebGL(renderer);
          }

          renderer.flush();

          if (mask) {
            renderer.maskManager.popMask(this, this._mask);
          }

          if (filters && this._enabledFilters && this._enabledFilters.length) {
            renderer.filterManager.popFilter();
          }
        };

        /**
         * To be overridden by the subclasses.
         *
         * @private
         * @param {PIXI.WebGLRenderer} renderer - The renderer
         */

        Container.prototype._renderWebGL = function _renderWebGL(
          renderer // eslint-disable-line no-unused-vars
        ) {};
        // this is where content itself gets rendered...

        /**
         * To be overridden by the subclass
         *
         * @private
         * @param {PIXI.CanvasRenderer} renderer - The renderer
         */

        Container.prototype._renderCanvas = function _renderCanvas(
          renderer // eslint-disable-line no-unused-vars
        ) {};
        // this is where content itself gets rendered...

        /**
         * Renders the object using the Canvas renderer
         *
         * @param {PIXI.CanvasRenderer} renderer - The renderer
         */

        Container.prototype.renderCanvas = function renderCanvas(renderer) {
          // if not visible or the alpha is 0 then no need to render this
          if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
            return;
          }

          if (this._mask) {
            renderer.maskManager.pushMask(this._mask);
          }

          this._renderCanvas(renderer);
          for (let i = 0, j = this.children.length; i < j; ++i) {
            this.children[i].renderCanvas(renderer);
          }

          if (this._mask) {
            renderer.maskManager.popMask(renderer);
          }
        };

        /**
         * Removes all internal references and listeners as well as removes children from the display list.
         * Do not use a Container after calling `destroy`.
         *
         * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
         *  have been set to that value
         * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
         *  method called as well. 'options' will be passed on to those calls.
         * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true
         *  Should it destroy the texture of the child sprite
         * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
         *  Should it destroy the base texture of the child sprite
         */

        Container.prototype.destroy = function destroy(options) {
          _DisplayObject.prototype.destroy.call(this);

          let destroyChildren = typeof options === "boolean" ? options : options && options.children;

          let oldChildren = this.removeChildren(0, this.children.length);

          if (destroyChildren) {
            for (let i = 0; i < oldChildren.length; ++i) {
              oldChildren[i].destroy(options);
            }
          }
        };

        /**
         * The width of the Container, setting this will actually modify the scale to achieve the value set
         *
         * @member {number}
         */

        _createClass(Container, [
          {
            key: "width",
            get: function get() {
              return this.scale.x * this.getLocalBounds().width;
            },
            set: function set(
              value // eslint-disable-line require-jsdoc
            ) {
              let width = this.getLocalBounds().width;

              if (width !== 0) {
                this.scale.x = value / width;
              } else {
                this.scale.x = 1;
              }

              this._width = value;
            },

            /**
             * The height of the Container, setting this will actually modify the scale to achieve the value set
             *
             * @member {number}
             */
          },
          {
            key: "height",
            get: function get() {
              return this.scale.y * this.getLocalBounds().height;
            },
            set: function set(
              value // eslint-disable-line require-jsdoc
            ) {
              let height = this.getLocalBounds().height;

              if (height !== 0) {
                this.scale.y = value / height;
              } else {
                this.scale.y = 1;
              }

              this._height = value;
            },
          },
        ]);

        return Container;
      })(_DisplayObject3.default);

      // performance increase to avoid using call.. (10x faster)

      exports.default = Container;
      Container.prototype.containerUpdateTransform = Container.prototype.updateTransform;
      //# sourceMappingURL=Container.js.map

      /***/
    },
    /* 359 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      let _SystemRenderer2 = __webpack_require__(411);

      let _SystemRenderer3 = _interopRequireDefault(_SystemRenderer2);

      let _CanvasMaskManager = __webpack_require__(501);

      let _CanvasMaskManager2 = _interopRequireDefault(_CanvasMaskManager);

      let _CanvasRenderTarget = __webpack_require__(413);

      let _CanvasRenderTarget2 = _interopRequireDefault(_CanvasRenderTarget);

      let _mapCanvasBlendModesToPixi = __webpack_require__(502);

      let _mapCanvasBlendModesToPixi2 = _interopRequireDefault(_mapCanvasBlendModesToPixi);

      let _utils = __webpack_require__(345);

      let _const = __webpack_require__(343);

      let _settings = __webpack_require__(346);

      let _settings2 = _interopRequireDefault(_settings);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: { value: subClass, enumerable: false, writable: true, configurable: true },
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass);
      }

      /**
       * The CanvasRenderer draws the scene and all its content onto a 2d canvas. This renderer should
       * be used for browsers that do not support WebGL. Don't forget to add the CanvasRenderer.view to
       * your DOM or you will not see anything :)
       *
       * @class
       * @memberof PIXI
       * @extends PIXI.SystemRenderer
       */
      let CanvasRenderer = (function (_SystemRenderer) {
        _inherits(CanvasRenderer, _SystemRenderer);

        // eslint-disable-next-line valid-jsdoc
        /**
         * @param {object} [options] - The optional renderer parameters
         * @param {number} [options.width=800] - the width of the screen
         * @param {number} [options.height=600] - the height of the screen
         * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional
         * @param {boolean} [options.transparent=false] - If the render view is transparent, default false
         * @param {boolean} [options.autoResize=false] - If the render view is automatically resized, default false
         * @param {boolean} [options.antialias=false] - sets antialias (only applicable in chrome at the moment)
         * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer. The
         *  resolution of the renderer retina would be 2.
         * @param {boolean} [options.preserveDrawingBuffer=false] - enables drawing buffer preservation,
         *  enable this if you need to call toDataUrl on the webgl context.
         * @param {boolean} [options.clearBeforeRender=true] - This sets if the renderer will clear the canvas or
         *      not before the new render pass.
         * @param {number} [options.backgroundColor=0x000000] - The background color of the rendered area
         *  (shown if not transparent).
         * @param {boolean} [options.roundPixels=false] - If true PixiJS will Math.floor() x/y values when rendering,
         *  stopping pixel interpolation.
         */
        function CanvasRenderer(options, arg2, arg3) {
          _classCallCheck(this, CanvasRenderer);

          let _this = _possibleConstructorReturn(this, _SystemRenderer.call(this, "Canvas", options, arg2, arg3));

          _this.type = _const.RENDERER_TYPE.CANVAS;

          /**
           * The root canvas 2d context that everything is drawn with.
           *
           * @member {CanvasRenderingContext2D}
           */
          _this.rootContext = _this.view.getContext("2d", { alpha: _this.transparent });

          /**
           * The currently active canvas 2d context (could change with renderTextures)
           *
           * @member {CanvasRenderingContext2D}
           */
          _this.context = _this.rootContext;

          /**
           * Boolean flag controlling canvas refresh.
           *
           * @member {boolean}
           */
          _this.refresh = true;

          /**
           * Instance of a CanvasMaskManager, handles masking when using the canvas renderer.
           *
           * @member {PIXI.CanvasMaskManager}
           */
          _this.maskManager = new _CanvasMaskManager2.default(_this);

          /**
           * The canvas property used to set the canvas smoothing property.
           *
           * @member {string}
           */
          _this.smoothProperty = "imageSmoothingEnabled";

          if (!_this.rootContext.imageSmoothingEnabled) {
            if (_this.rootContext.webkitImageSmoothingEnabled) {
              _this.smoothProperty = "webkitImageSmoothingEnabled";
            } else if (_this.rootContext.mozImageSmoothingEnabled) {
              _this.smoothProperty = "mozImageSmoothingEnabled";
            } else if (_this.rootContext.oImageSmoothingEnabled) {
              _this.smoothProperty = "oImageSmoothingEnabled";
            } else if (_this.rootContext.msImageSmoothingEnabled) {
              _this.smoothProperty = "msImageSmoothingEnabled";
            }
          }

          _this.initPlugins();

          _this.blendModes = (0, _mapCanvasBlendModesToPixi2.default)();
          _this._activeBlendMode = null;

          _this.renderingToScreen = false;

          _this.resize(_this.options.width, _this.options.height);

          /**
           * Fired after rendering finishes.
           *
           * @event PIXI.CanvasRenderer#postrender
           */

          /**
           * Fired before rendering starts.
           *
           * @event PIXI.CanvasRenderer#prerender
           */
          return _this;
        }

        /**
         * Renders the object to this canvas view
         *
         * @param {PIXI.DisplayObject} displayObject - The object to be rendered
         * @param {PIXI.RenderTexture} [renderTexture] - A render texture to be rendered to.
         *  If unset, it will render to the root context.
         * @param {boolean} [clear=false] - Whether to clear the canvas before drawing
         * @param {PIXI.Matrix} [transform] - A transformation to be applied
         * @param {boolean} [skipUpdateTransform=false] - Whether to skip the update transform
         */

        CanvasRenderer.prototype.render = function render(displayObject, renderTexture, clear, transform, skipUpdateTransform) {
          if (!this.view) {
            return;
          }

          // can be handy to know!
          this.renderingToScreen = !renderTexture;

          this.emit("prerender");

          let rootResolution = this.resolution;

          if (renderTexture) {
            renderTexture = renderTexture.baseTexture || renderTexture;

            if (!renderTexture._canvasRenderTarget) {
              renderTexture._canvasRenderTarget = new _CanvasRenderTarget2.default(
                renderTexture.width,
                renderTexture.height,
                renderTexture.resolution
              );
              renderTexture.source = renderTexture._canvasRenderTarget.canvas;
              renderTexture.valid = true;
            }

            this.context = renderTexture._canvasRenderTarget.context;
            this.resolution = renderTexture._canvasRenderTarget.resolution;
          } else {
            this.context = this.rootContext;
          }

          let context = this.context;

          if (!renderTexture) {
            this._lastObjectRendered = displayObject;
          }

          if (!skipUpdateTransform) {
            // update the scene graph
            let cacheParent = displayObject.parent;
            let tempWt = this._tempDisplayObjectParent.transform.worldTransform;

            if (transform) {
              transform.copy(tempWt);

              // lets not forget to flag the parent transform as dirty...
              this._tempDisplayObjectParent.transform._worldID = -1;
            } else {
              tempWt.identity();
            }

            displayObject.parent = this._tempDisplayObjectParent;

            displayObject.updateTransform();
            displayObject.parent = cacheParent;
            // displayObject.hitArea = //TODO add a temp hit area
          }

          context.save();
          context.setTransform(1, 0, 0, 1, 0, 0);
          context.globalAlpha = 1;
          this._activeBlendMode = _const.BLEND_MODES.NORMAL;
          context.globalCompositeOperation = this.blendModes[_const.BLEND_MODES.NORMAL];

          if (navigator.isCocoonJS && this.view.screencanvas) {
            context.fillStyle = "black";
            context.clear();
          }

          if (clear !== undefined ? clear : this.clearBeforeRender) {
            if (this.renderingToScreen) {
              if (this.transparent) {
                context.clearRect(0, 0, this.width, this.height);
              } else {
                context.fillStyle = this._backgroundColorString;
                context.fillRect(0, 0, this.width, this.height);
              }
            } // else {
            // TODO: implement background for CanvasRenderTarget or RenderTexture?
            // }
          }

          // TODO RENDER TARGET STUFF HERE..
          let tempContext = this.context;

          this.context = context;
          displayObject.renderCanvas(this);
          this.context = tempContext;

          context.restore();

          this.resolution = rootResolution;

          this.emit("postrender");
        };

        /**
         * Clear the canvas of renderer.
         *
         * @param {string} [clearColor] - Clear the canvas with this color, except the canvas is transparent.
         */

        CanvasRenderer.prototype.clear = function clear(clearColor) {
          let context = this.context;

          clearColor = clearColor || this._backgroundColorString;

          if (!this.transparent && clearColor) {
            context.fillStyle = clearColor;
            context.fillRect(0, 0, this.width, this.height);
          } else {
            context.clearRect(0, 0, this.width, this.height);
          }
        };

        /**
         * Sets the blend mode of the renderer.
         *
         * @param {number} blendMode - See {@link PIXI.BLEND_MODES} for valid values.
         */

        CanvasRenderer.prototype.setBlendMode = function setBlendMode(blendMode) {
          if (this._activeBlendMode === blendMode) {
            return;
          }

          this._activeBlendMode = blendMode;
          this.context.globalCompositeOperation = this.blendModes[blendMode];
        };

        /**
         * Removes everything from the renderer and optionally removes the Canvas DOM element.
         *
         * @param {boolean} [removeView=false] - Removes the Canvas element from the DOM.
         */

        CanvasRenderer.prototype.destroy = function destroy(removeView) {
          this.destroyPlugins();

          // call the base destroy
          _SystemRenderer.prototype.destroy.call(this, removeView);

          this.context = null;

          this.refresh = true;

          this.maskManager.destroy();
          this.maskManager = null;

          this.smoothProperty = null;
        };

        /**
         * Resizes the canvas view to the specified width and height.
         *
         * @extends PIXI.SystemRenderer#resize
         *
         * @param {number} screenWidth - the new width of the screen
         * @param {number} screenHeight - the new height of the screen
         */

        CanvasRenderer.prototype.resize = function resize(screenWidth, screenHeight) {
          _SystemRenderer.prototype.resize.call(this, screenWidth, screenHeight);

          // reset the scale mode.. oddly this seems to be reset when the canvas is resized.
          // surely a browser bug?? Let PixiJS fix that for you..
          if (this.smoothProperty) {
            this.rootContext[this.smoothProperty] = _settings2.default.SCALE_MODE === _const.SCALE_MODES.LINEAR;
          }
        };

        /**
         * Checks if blend mode has changed.
         */

        CanvasRenderer.prototype.invalidateBlendMode = function invalidateBlendMode() {
          this._activeBlendMode = this.blendModes.indexOf(this.context.globalCompositeOperation);
        };

        return CanvasRenderer;
      })(_SystemRenderer3.default);

      /**
       * Collection of installed plugins. These are included by default in PIXI, but can be excluded
       * by creating a custom build. Consult the README for more information about creating custom
       * builds and excluding plugins.
       * @name PIXI.CanvasRenderer#plugins
       * @type {object}
       * @readonly
       * @property {PIXI.accessibility.AccessibilityManager} accessibility Support tabbing interactive elements.
       * @property {PIXI.extract.CanvasExtract} extract Extract image data from renderer.
       * @property {PIXI.interaction.InteractionManager} interaction Handles mouse, touch and pointer events.
       * @property {PIXI.prepare.CanvasPrepare} prepare Pre-render display objects.
       */

      /**
       * Adds a plugin to the renderer.
       *
       * @method PIXI.CanvasRenderer#registerPlugin
       * @param {string} pluginName - The name of the plugin.
       * @param {Function} ctor - The constructor function or class for the plugin.
       */

      exports.default = CanvasRenderer;
      _utils.pluginTarget.mixin(CanvasRenderer);
      //# sourceMappingURL=CanvasRenderer.js.map

      /***/
    },
    /* 360 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      /**
       * @class
       * @memberof PIXI
       */
      let WebGLManager = (function () {
        /**
         * @param {PIXI.WebGLRenderer} renderer - The renderer this manager works for.
         */
        function WebGLManager(renderer) {
          _classCallCheck(this, WebGLManager);

          /**
           * The renderer this manager works for.
           *
           * @member {PIXI.WebGLRenderer}
           */
          this.renderer = renderer;

          this.renderer.on("context", this.onContextChange, this);
        }

        /**
         * Generic method called when there is a WebGL context change.
         *
         */

        WebGLManager.prototype.onContextChange = function onContextChange() {};
        // do some codes init!

        /**
         * Generic destroy methods to be overridden by the subclass
         *
         */

        WebGLManager.prototype.destroy = function destroy() {
          this.renderer.off("context", this.onContextChange, this);

          this.renderer = null;
        };

        return WebGLManager;
      })();

      exports.default = WebGLManager;
      //# sourceMappingURL=WebGLManager.js.map

      /***/
    },
    /* 361 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      let _pixiGlCore = __webpack_require__(350);

      let _settings = __webpack_require__(346);

      let _settings2 = _interopRequireDefault(_settings);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: { value: subClass, enumerable: false, writable: true, configurable: true },
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass);
      }

      function checkPrecision(src, def) {
        if (src instanceof Array) {
          if (src[0].substring(0, 9) !== "precision") {
            let copy = src.slice(0);

            copy.unshift("precision " + def + " float;");

            return copy;
          }
        } else if (src.trim().substring(0, 9) !== "precision") {
          return "precision " + def + " float;\n" + src;
        }

        return src;
      }

      /**
       * Wrapper class, webGL Shader for Pixi.
       * Adds precision string if vertexSrc or fragmentSrc have no mention of it.
       *
       * @class
       * @extends GLShader
       * @memberof PIXI
       */

      let Shader = (function (_GLShader) {
        _inherits(Shader, _GLShader);

        /**
       *
       * @param {WebGLRenderingContext} gl - The current WebGL rendering context
       * @param {string|string[]} vertexSrc - The vertex shader source as an array of strings.
       * @param {string|string[]} fragmentSrc - The fragment shader source as an array of strings.
       * @param {object} [attributeLocations] - A key value pair showing which location eact attribute should sit.
                         e.g. {position:0, uvs:1}.
       * @param {string} [precision] - The float precision of the shader. Options are 'lowp', 'mediump' or 'highp'.
       */
        function Shader(gl, vertexSrc, fragmentSrc, attributeLocations, precision) {
          _classCallCheck(this, Shader);

          return _possibleConstructorReturn(
            this,
            _GLShader.call(
              this,
              gl,
              checkPrecision(vertexSrc, precision || _settings2.default.PRECISION_VERTEX),
              checkPrecision(fragmentSrc, precision || _settings2.default.PRECISION_FRAGMENT),
              undefined,
              attributeLocations
            )
          );
        }

        return Shader;
      })(_pixiGlCore.GLShader);

      exports.default = Shader;
      //# sourceMappingURL=Shader.js.map

      /***/
    },
    /* 362 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      // import Loader from './Loader';
      // import Resource from './Resource';
      // import * as async from './async';
      // import * as b64 from './b64';

      /* eslint-disable no-undef */

      let Loader = __webpack_require__(554).Loader;
      let Resource = __webpack_require__(386).Resource;
      let async = __webpack_require__(438);
      let b64 = __webpack_require__(439);

      /**
       *
       * @static
       * @memberof Loader
       * @member {Class<Resource>}
       */
      Loader.Resource = Resource;

      /**
       *
       * @static
       * @memberof Loader
       * @member {Class<async>}
       */
      Loader.async = async;

      /**
       *
       * @static
       * @memberof Loader
       * @member {Class<encodeBinary>}
       */
      Loader.encodeBinary = b64;

      /**
       *
       * @deprecated
       * @see Loader.encodeBinary
       *
       * @static
       * @memberof Loader
       * @member {Class<encodeBinary>}
       */
      Loader.base64 = b64;

      // export manually, and also as default
      module.exports = Loader;

      // default & named export
      module.exports.Loader = Loader;
      module.exports.default = Loader;
      //# sourceMappingURL=index.js.map

      /***/
    },
    /* 363 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      let _createClass = (function () {
        function defineProperties(target, props) {
          for (let i = 0; i < props.length; i++) {
            let descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      })();

      let _core = __webpack_require__(344);

      let core = _interopRequireWildcard(_core);

      let _Texture = __webpack_require__(353);

      let _Texture2 = _interopRequireDefault(_Texture);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          let newObj = {};
          if (obj != null) {
            for (let key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }
          newObj.default = obj;
          return newObj;
        }
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: { value: subClass, enumerable: false, writable: true, configurable: true },
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass);
      }

      let tempPoint = new core.Point();
      let tempPolygon = new core.Polygon();

      /**
       * Base mesh class
       * @class
       * @extends PIXI.Container
       * @memberof PIXI.mesh
       */

      let Mesh = (function (_core$Container) {
        _inherits(Mesh, _core$Container);

        /**
         * @param {PIXI.Texture} texture - The texture to use
         * @param {Float32Array} [vertices] - if you want to specify the vertices
         * @param {Float32Array} [uvs] - if you want to specify the uvs
         * @param {Uint16Array} [indices] - if you want to specify the indices
         * @param {number} [drawMode] - the drawMode, can be any of the Mesh.DRAW_MODES consts
         */
        function Mesh(texture, vertices, uvs, indices, drawMode) {
          _classCallCheck(this, Mesh);

          /**
           * The texture of the Mesh
           *
           * @member {PIXI.Texture}
           * @default PIXI.Texture.EMPTY
           * @private
           */
          let _this = _possibleConstructorReturn(this, _core$Container.call(this));

          _this._texture = texture || _Texture2.default.EMPTY;

          /**
           * The Uvs of the Mesh
           *
           * @member {Float32Array}
           */
          _this.uvs = uvs || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);

          /**
           * An array of vertices
           *
           * @member {Float32Array}
           */
          _this.vertices = vertices || new Float32Array([0, 0, 100, 0, 100, 100, 0, 100]);

          /**
           * An array containing the indices of the vertices
           *
           * @member {Uint16Array}
           */
          //  TODO auto generate this based on draw mode!
          _this.indices = indices || new Uint16Array([0, 1, 3, 2]);

          /**
           * Version of mesh uvs are dirty or not
           *
           * @member {number}
           */
          _this.dirty = 0;

          /**
           * Version of mesh indices
           *
           * @member {number}
           */
          _this.indexDirty = 0;

          /**
           * Version of mesh verticies array
           *
           * @member {number}
           */
          _this.vertexDirty = 0;

          /**
           * For backwards compatibility the default is to re-upload verticies each render call.
           * Set this to `false` and increase `vertexDirty` to manually re-upload the buffer.
           *
           * @member {boolean}
           */
          _this.autoUpdate = true;

          /**
           * The blend mode to be applied to the sprite. Set to `PIXI.BLEND_MODES.NORMAL` to remove
           * any blend mode.
           *
           * @member {number}
           * @default PIXI.BLEND_MODES.NORMAL
           * @see PIXI.BLEND_MODES
           */
          _this.blendMode = core.BLEND_MODES.NORMAL;

          /**
           * Triangles in canvas mode are automatically antialiased, use this value to force triangles
           * to overlap a bit with each other.
           *
           * @member {number}
           */
          _this.canvasPadding = core.settings.MESH_CANVAS_PADDING;

          /**
           * The way the Mesh should be drawn, can be any of the {@link PIXI.mesh.Mesh.DRAW_MODES} consts
           *
           * @member {number}
           * @see PIXI.mesh.Mesh.DRAW_MODES
           */
          _this.drawMode = drawMode || Mesh.DRAW_MODES.TRIANGLE_MESH;

          /**
           * The default shader that is used if a mesh doesn't have a more specific one.
           *
           * @member {PIXI.Shader}
           */
          _this.shader = null;

          /**
           * The tint applied to the mesh. This is a [r,g,b] value. A value of [1,1,1] will remove any
           * tint effect.
           *
           * @member {number}
           */
          _this.tintRgb = new Float32Array([1, 1, 1]);

          /**
           * A map of renderer IDs to webgl render data
           *
           * @private
           * @member {object<number, object>}
           */
          _this._glDatas = {};

          /**
           * transform that is applied to UV to get the texture coords
           * its updated independently from texture uvTransform
           * updates of uvs are tied to that thing
           *
           * @member {PIXI.TextureMatrix}
           * @private
           */
          _this._uvTransform = new core.TextureMatrix(_this._texture);

          /**
           * whether or not upload uvTransform to shader
           * if its false, then uvs should be pre-multiplied
           * if you change it for generated mesh, please call 'refresh(true)'
           * @member {boolean}
           * @default false
           */
          _this.uploadUvTransform = false;

          /**
           * Plugin that is responsible for rendering this element.
           * Allows to customize the rendering process without overriding '_renderWebGL' & '_renderCanvas' methods.
           * @member {string}
           * @default 'mesh'
           */
          _this.pluginName = "mesh";
          return _this;
        }

        /**
         * Renders the object using the WebGL renderer
         *
         * @private
         * @param {PIXI.WebGLRenderer} renderer - a reference to the WebGL renderer
         */

        Mesh.prototype._renderWebGL = function _renderWebGL(renderer) {
          this.refresh();
          renderer.setObjectRenderer(renderer.plugins[this.pluginName]);
          renderer.plugins[this.pluginName].render(this);
        };

        /**
         * Renders the object using the Canvas renderer
         *
         * @private
         * @param {PIXI.CanvasRenderer} renderer - The canvas renderer.
         */

        Mesh.prototype._renderCanvas = function _renderCanvas(renderer) {
          this.refresh();
          renderer.plugins[this.pluginName].render(this);
        };

        /**
         * When the texture is updated, this event will fire to update the scale and frame
         *
         * @private
         */

        Mesh.prototype._onTextureUpdate = function _onTextureUpdate() {
          this._uvTransform.texture = this._texture;
          this.refresh();
        };

        /**
         * multiplies uvs only if uploadUvTransform is false
         * call it after you change uvs manually
         * make sure that texture is valid
         */

        Mesh.prototype.multiplyUvs = function multiplyUvs() {
          if (!this.uploadUvTransform) {
            this._uvTransform.multiplyUvs(this.uvs);
          }
        };

        /**
         * Refreshes uvs for generated meshes (rope, plane)
         * sometimes refreshes vertices too
         *
         * @param {boolean} [forceUpdate=false] if true, matrices will be updated any case
         */

        Mesh.prototype.refresh = function refresh(forceUpdate) {
          if (this.autoUpdate) {
            this.vertexDirty++;
          }
          if (this._uvTransform.update(forceUpdate)) {
            this._refresh();
          }
        };

        /**
         * re-calculates mesh coords
         * @protected
         */

        Mesh.prototype._refresh = function _refresh() {};
        /* empty */

        /**
         * Returns the bounds of the mesh as a rectangle. The bounds calculation takes the worldTransform into account.
         *
         */

        Mesh.prototype._calculateBounds = function _calculateBounds() {
          // TODO - we can cache local bounds and use them if they are dirty (like graphics)
          this._bounds.addVertices(this.transform, this.vertices, 0, this.vertices.length);
        };

        /**
         * Tests if a point is inside this mesh. Works only for TRIANGLE_MESH
         *
         * @param {PIXI.Point} point - the point to test
         * @return {boolean} the result of the test
         */

        Mesh.prototype.containsPoint = function containsPoint(point) {
          if (!this.getBounds().contains(point.x, point.y)) {
            return false;
          }

          this.worldTransform.applyInverse(point, tempPoint);

          let vertices = this.vertices;
          let points = tempPolygon.points;
          let indices = this.indices;
          let len = this.indices.length;
          let step = this.drawMode === Mesh.DRAW_MODES.TRIANGLES ? 3 : 1;

          for (let i = 0; i + 2 < len; i += step) {
            let ind0 = indices[i] * 2;
            let ind1 = indices[i + 1] * 2;
            let ind2 = indices[i + 2] * 2;

            points[0] = vertices[ind0];
            points[1] = vertices[ind0 + 1];
            points[2] = vertices[ind1];
            points[3] = vertices[ind1 + 1];
            points[4] = vertices[ind2];
            points[5] = vertices[ind2 + 1];

            if (tempPolygon.contains(tempPoint.x, tempPoint.y)) {
              return true;
            }
          }

          return false;
        };

        /**
         * The texture that the mesh uses.
         *
         * @member {PIXI.Texture}
         */

        /**
         * Destroys the Mesh object.
         *
         * @param {object|boolean} [options] - Options parameter. A boolean will act as if all
         *  options have been set to that value
         * @param {boolean} [options.children=false] - if set to true, all the children will have
         *  their destroy method called as well. 'options' will be passed on to those calls.
         * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true
         *  Should it destroy the texture of the child sprite
         * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
         *  Should it destroy the base texture of the child sprite
         */
        Mesh.prototype.destroy = function destroy(options) {
          // for each webgl data entry, destroy the WebGLGraphicsData
          for (let id in this._glDatas) {
            let data = this._glDatas[id];

            if (data.destroy) {
              data.destroy();
            } else {
              if (data.vertexBuffer) {
                data.vertexBuffer.destroy();
                data.vertexBuffer = null;
              }
              if (data.indexBuffer) {
                data.indexBuffer.destroy();
                data.indexBuffer = null;
              }
              if (data.uvBuffer) {
                data.uvBuffer.destroy();
                data.uvBuffer = null;
              }
              if (data.vao) {
                data.vao.destroy();
                data.vao = null;
              }
            }
          }

          this._glDatas = null;

          _core$Container.prototype.destroy.call(this, options);
        };

        _createClass(Mesh, [
          {
            key: "texture",
            get: function get() {
              return this._texture;
            },
            set: function set(
              value // eslint-disable-line require-jsdoc
            ) {
              if (this._texture === value) {
                return;
              }

              this._texture = value;

              if (value) {
                // wait for the texture to load
                if (value.baseTexture.hasLoaded) {
                  this._onTextureUpdate();
                } else {
                  value.once("update", this._onTextureUpdate, this);
                }
              }
            },

            /**
             * The tint applied to the mesh. This is a hex value. A value of 0xFFFFFF will remove any tint effect.
             *
             * @member {number}
             * @default 0xFFFFFF
             */
          },
          {
            key: "tint",
            get: function get() {
              return core.utils.rgb2hex(this.tintRgb);
            },
            set: function set(
              value // eslint-disable-line require-jsdoc
            ) {
              this.tintRgb = core.utils.hex2rgb(value, this.tintRgb);
            },
          },
        ]);

        return Mesh;
      })(core.Container);

      /**
       * Different drawing buffer modes supported
       *
       * @static
       * @constant
       * @type {object}
       * @property {number} TRIANGLE_MESH
       * @property {number} TRIANGLES
       */

      exports.default = Mesh;
      Mesh.DRAW_MODES = {
        TRIANGLE_MESH: 0,
        TRIANGLES: 1,
      };
      //# sourceMappingURL=Mesh.js.map

      /***/
    },
    /* 364 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      let _utils = __webpack_require__(345);

      let _canUseNewCanvasBlendModes = __webpack_require__(414);

      let _canUseNewCanvasBlendModes2 = _interopRequireDefault(_canUseNewCanvasBlendModes);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      /**
       * Utility methods for Sprite/Texture tinting.
       *
       * @class
       * @memberof PIXI
       */
      var CanvasTinter = {
        /**
         * Basically this method just needs a sprite and a color and tints the sprite with the given color.
         *
         * @memberof PIXI.CanvasTinter
         * @param {PIXI.Sprite} sprite - the sprite to tint
         * @param {number} color - the color to use to tint the sprite with
         * @return {HTMLCanvasElement} The tinted canvas
         */
        getTintedTexture: function getTintedTexture(sprite, color) {
          let texture = sprite._texture;

          color = CanvasTinter.roundColor(color);

          let stringColor = "#" + ("00000" + (color | 0).toString(16)).substr(-6);

          texture.tintCache = texture.tintCache || {};

          let cachedTexture = texture.tintCache[stringColor];

          let canvas = void 0;

          if (cachedTexture) {
            if (cachedTexture.tintId === texture._updateID) {
              return texture.tintCache[stringColor];
            }

            canvas = texture.tintCache[stringColor];
          } else {
            canvas = CanvasTinter.canvas || document.createElement("canvas");
          }

          CanvasTinter.tintMethod(texture, color, canvas);

          canvas.tintId = texture._updateID;

          if (CanvasTinter.convertTintToImage) {
            // is this better?
            let tintImage = new Image();

            tintImage.src = canvas.toDataURL();

            texture.tintCache[stringColor] = tintImage;
          } else {
            texture.tintCache[stringColor] = canvas;
            // if we are not converting the texture to an image then we need to lose the reference to the canvas
            CanvasTinter.canvas = null;
          }

          return canvas;
        },

        /**
         * Tint a texture using the 'multiply' operation.
         *
         * @memberof PIXI.CanvasTinter
         * @param {PIXI.Texture} texture - the texture to tint
         * @param {number} color - the color to use to tint the sprite with
         * @param {HTMLCanvasElement} canvas - the current canvas
         */
        tintWithMultiply: function tintWithMultiply(texture, color, canvas) {
          let context = canvas.getContext("2d");
          let crop = texture._frame.clone();
          let resolution = texture.baseTexture.resolution;

          crop.x *= resolution;
          crop.y *= resolution;
          crop.width *= resolution;
          crop.height *= resolution;

          canvas.width = Math.ceil(crop.width);
          canvas.height = Math.ceil(crop.height);

          context.save();
          context.fillStyle = "#" + ("00000" + (color | 0).toString(16)).substr(-6);

          context.fillRect(0, 0, crop.width, crop.height);

          context.globalCompositeOperation = "multiply";

          context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);

          context.globalCompositeOperation = "destination-atop";

          context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);
          context.restore();
        },

        /**
         * Tint a texture using the 'overlay' operation.
         *
         * @memberof PIXI.CanvasTinter
         * @param {PIXI.Texture} texture - the texture to tint
         * @param {number} color - the color to use to tint the sprite with
         * @param {HTMLCanvasElement} canvas - the current canvas
         */
        tintWithOverlay: function tintWithOverlay(texture, color, canvas) {
          let context = canvas.getContext("2d");
          let crop = texture._frame.clone();
          let resolution = texture.baseTexture.resolution;

          crop.x *= resolution;
          crop.y *= resolution;
          crop.width *= resolution;
          crop.height *= resolution;

          canvas.width = Math.ceil(crop.width);
          canvas.height = Math.ceil(crop.height);

          context.save();
          context.globalCompositeOperation = "copy";
          context.fillStyle = "#" + ("00000" + (color | 0).toString(16)).substr(-6);
          context.fillRect(0, 0, crop.width, crop.height);

          context.globalCompositeOperation = "destination-atop";
          context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);

          // context.globalCompositeOperation = 'copy';
          context.restore();
        },

        /**
         * Tint a texture pixel per pixel.
         *
         * @memberof PIXI.CanvasTinter
         * @param {PIXI.Texture} texture - the texture to tint
         * @param {number} color - the color to use to tint the sprite with
         * @param {HTMLCanvasElement} canvas - the current canvas
         */
        tintWithPerPixel: function tintWithPerPixel(texture, color, canvas) {
          let context = canvas.getContext("2d");
          let crop = texture._frame.clone();
          let resolution = texture.baseTexture.resolution;

          crop.x *= resolution;
          crop.y *= resolution;
          crop.width *= resolution;
          crop.height *= resolution;

          canvas.width = Math.ceil(crop.width);
          canvas.height = Math.ceil(crop.height);

          context.save();
          context.globalCompositeOperation = "copy";
          context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);
          context.restore();

          let rgbValues = (0, _utils.hex2rgb)(color);
          let r = rgbValues[0];
          let g = rgbValues[1];
          let b = rgbValues[2];

          let pixelData = context.getImageData(0, 0, crop.width, crop.height);

          let pixels = pixelData.data;

          for (let i = 0; i < pixels.length; i += 4) {
            pixels[i + 0] *= r;
            pixels[i + 1] *= g;
            pixels[i + 2] *= b;
          }

          context.putImageData(pixelData, 0, 0);
        },

        /**
         * Rounds the specified color according to the CanvasTinter.cacheStepsPerColorChannel.
         *
         * @memberof PIXI.CanvasTinter
         * @param {number} color - the color to round, should be a hex color
         * @return {number} The rounded color.
         */
        roundColor: function roundColor(color) {
          let step = CanvasTinter.cacheStepsPerColorChannel;

          let rgbValues = (0, _utils.hex2rgb)(color);

          rgbValues[0] = Math.min(255, (rgbValues[0] / step) * step);
          rgbValues[1] = Math.min(255, (rgbValues[1] / step) * step);
          rgbValues[2] = Math.min(255, (rgbValues[2] / step) * step);

          return (0, _utils.rgb2hex)(rgbValues);
        },

        /**
         * Number of steps which will be used as a cap when rounding colors.
         *
         * @memberof PIXI.CanvasTinter
         * @type {number}
         */
        cacheStepsPerColorChannel: 8,

        /**
         * Tint cache boolean flag.
         *
         * @memberof PIXI.CanvasTinter
         * @type {boolean}
         */
        convertTintToImage: false,

        /**
         * Whether or not the Canvas BlendModes are supported, consequently the ability to tint using the multiply method.
         *
         * @memberof PIXI.CanvasTinter
         * @type {boolean}
         */
        canUseMultiply: (0, _canUseNewCanvasBlendModes2.default)(),

        /**
         * The tinting method that will be used.
         *
         * @memberof PIXI.CanvasTinter
         * @type {tintMethodFunctionType}
         */
        tintMethod: 0,
      };

      CanvasTinter.tintMethod = CanvasTinter.canUseMultiply ? CanvasTinter.tintWithMultiply : CanvasTinter.tintWithPerPixel;

      /**
       * The tintMethod type.
       *
       * @memberof PIXI.CanvasTinter
       * @callback tintMethodFunctionType
       * @param texture {PIXI.Texture} the texture to tint
       * @param color {number} the color to use to tint the sprite with
       * @param canvas {HTMLCanvasElement} the current canvas
       */

      exports.default = CanvasTinter;
      //# sourceMappingURL=CanvasTinter.js.map

      /***/
    },
    /* 365 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      let _WebGLManager2 = __webpack_require__(360);

      let _WebGLManager3 = _interopRequireDefault(_WebGLManager2);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: { value: subClass, enumerable: false, writable: true, configurable: true },
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass);
      }

      /**
       * Base for a common object renderer that can be used as a system renderer plugin.
       *
       * @class
       * @extends PIXI.WebGLManager
       * @memberof PIXI
       */
      let ObjectRenderer = (function (_WebGLManager) {
        _inherits(ObjectRenderer, _WebGLManager);

        function ObjectRenderer() {
          _classCallCheck(this, ObjectRenderer);

          return _possibleConstructorReturn(this, _WebGLManager.apply(this, arguments));
        }

        /**
         * Starts the renderer and sets the shader
         *
         */
        ObjectRenderer.prototype.start = function start() {};
        // set the shader..

        /**
         * Stops the renderer
         *
         */

        ObjectRenderer.prototype.stop = function stop() {
          this.flush();
        };

        /**
         * Stub method for rendering content and emptying the current batch.
         *
         */

        ObjectRenderer.prototype.flush = function flush() {};
        // flush!

        /**
         * Renders an object
         *
         * @param {PIXI.DisplayObject} object - The object to render.
         */

        ObjectRenderer.prototype.render = function render(
          object // eslint-disable-line no-unused-vars
        ) {
          // render the object
        };

        return ObjectRenderer;
      })(_WebGLManager3.default);

      exports.default = ObjectRenderer;
      //# sourceMappingURL=ObjectRenderer.js.map

      /***/
    },
    /* 366 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      let _SystemRenderer2 = __webpack_require__(411);

      let _SystemRenderer3 = _interopRequireDefault(_SystemRenderer2);

      let _MaskManager = __webpack_require__(504);

      let _MaskManager2 = _interopRequireDefault(_MaskManager);

      let _StencilManager = __webpack_require__(506);

      let _StencilManager2 = _interopRequireDefault(_StencilManager);

      let _FilterManager = __webpack_require__(507);

      let _FilterManager2 = _interopRequireDefault(_FilterManager);

      let _RenderTarget = __webpack_require__(367);

      let _RenderTarget2 = _interopRequireDefault(_RenderTarget);

      let _ObjectRenderer = __webpack_require__(365);

      let _ObjectRenderer2 = _interopRequireDefault(_ObjectRenderer);

      let _TextureManager = __webpack_require__(509);

      let _TextureManager2 = _interopRequireDefault(_TextureManager);

      let _BaseTexture = __webpack_require__(355);

      let _BaseTexture2 = _interopRequireDefault(_BaseTexture);

      let _TextureGarbageCollector = __webpack_require__(510);

      let _TextureGarbageCollector2 = _interopRequireDefault(_TextureGarbageCollector);

      let _WebGLState = __webpack_require__(511);

      let _WebGLState2 = _interopRequireDefault(_WebGLState);

      let _mapWebGLDrawModesToPixi = __webpack_require__(513);

      let _mapWebGLDrawModesToPixi2 = _interopRequireDefault(_mapWebGLDrawModesToPixi);

      let _validateContext = __webpack_require__(514);

      let _validateContext2 = _interopRequireDefault(_validateContext);

      let _utils = __webpack_require__(345);

      let _pixiGlCore = __webpack_require__(350);

      let _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);

      let _const = __webpack_require__(343);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: { value: subClass, enumerable: false, writable: true, configurable: true },
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass);
      }

      let CONTEXT_UID = 0;

      /**
       * The WebGLRenderer draws the scene and all its content onto a webGL enabled canvas. This renderer
       * should be used for browsers that support webGL. This Render works by automatically managing webGLBatchs.
       * So no need for Sprite Batches or Sprite Clouds.
       * Don't forget to add the view to your DOM or you will not see anything :)
       *
       * @class
       * @memberof PIXI
       * @extends PIXI.SystemRenderer
       */

      let WebGLRenderer = (function (_SystemRenderer) {
        _inherits(WebGLRenderer, _SystemRenderer);

        // eslint-disable-next-line valid-jsdoc
        /**
         *
         * @param {object} [options] - The optional renderer parameters
         * @param {number} [options.width=800] - the width of the screen
         * @param {number} [options.height=600] - the height of the screen
         * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional
         * @param {boolean} [options.transparent=false] - If the render view is transparent, default false
         * @param {boolean} [options.autoResize=false] - If the render view is automatically resized, default false
         * @param {boolean} [options.antialias=false] - sets antialias. If not available natively then FXAA
         *  antialiasing is used
         * @param {boolean} [options.forceFXAA=false] - forces FXAA antialiasing to be used over native.
         *  FXAA is faster, but may not always look as great
         * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer.
         *  The resolution of the renderer retina would be 2.
         * @param {boolean} [options.clearBeforeRender=true] - This sets if the renderer will clear
         *  the canvas or not before the new render pass. If you wish to set this to false, you *must* set
         *  preserveDrawingBuffer to `true`.
         * @param {boolean} [options.preserveDrawingBuffer=false] - enables drawing buffer preservation,
         *  enable this if you need to call toDataUrl on the webgl context.
         * @param {boolean} [options.roundPixels=false] - If true PixiJS will Math.floor() x/y values when
         *  rendering, stopping pixel interpolation.
         * @param {number} [options.backgroundColor=0x000000] - The background color of the rendered area
         *  (shown if not transparent).
         * @param {boolean} [options.legacy=false] - If true PixiJS will aim to ensure compatibility
         *  with older / less advanced devices. If you experience unexplained flickering try setting this to true.
         * @param {string} [options.powerPreference] - Parameter passed to webgl context, set to "high-performance"
         *  for devices with dual graphics card
         */
        function WebGLRenderer(options, arg2, arg3) {
          _classCallCheck(this, WebGLRenderer);

          let _this = _possibleConstructorReturn(this, _SystemRenderer.call(this, "WebGL", options, arg2, arg3));

          _this.legacy = _this.options.legacy;

          if (_this.legacy) {
            _pixiGlCore2.default.VertexArrayObject.FORCE_NATIVE = true;
          }

          /**
           * The type of this renderer as a standardised const
           *
           * @member {number}
           * @see PIXI.RENDERER_TYPE
           */
          _this.type = _const.RENDERER_TYPE.WEBGL;

          _this.handleContextLost = _this.handleContextLost.bind(_this);
          _this.handleContextRestored = _this.handleContextRestored.bind(_this);

          _this.view.addEventListener("webglcontextlost", _this.handleContextLost, false);
          _this.view.addEventListener("webglcontextrestored", _this.handleContextRestored, false);

          /**
           * The options passed in to create a new webgl context.
           *
           * @member {object}
           * @private
           */
          _this._contextOptions = {
            alpha: _this.transparent,
            antialias: _this.options.antialias,
            premultipliedAlpha: _this.transparent && _this.transparent !== "notMultiplied",
            stencil: true,
            preserveDrawingBuffer: _this.options.preserveDrawingBuffer,
            powerPreference: _this.options.powerPreference,
          };

          _this._backgroundColorRgba[3] = _this.transparent ? 0 : 1;

          /**
           * Manages the masks using the stencil buffer.
           *
           * @member {PIXI.MaskManager}
           */
          _this.maskManager = new _MaskManager2.default(_this);

          /**
           * Manages the stencil buffer.
           *
           * @member {PIXI.StencilManager}
           */
          _this.stencilManager = new _StencilManager2.default(_this);

          /**
           * An empty renderer.
           *
           * @member {PIXI.ObjectRenderer}
           */
          _this.emptyRenderer = new _ObjectRenderer2.default(_this);

          /**
           * The currently active ObjectRenderer.
           *
           * @member {PIXI.ObjectRenderer}
           */
          _this.currentRenderer = _this.emptyRenderer;

          /**
           * Manages textures
           * @member {PIXI.TextureManager}
           */
          _this.textureManager = null;

          /**
           * Manages the filters.
           *
           * @member {PIXI.FilterManager}
           */
          _this.filterManager = null;

          _this.initPlugins();

          /**
           * The current WebGL rendering context, it is created here
           *
           * @member {WebGLRenderingContext}
           */
          // initialize the context so it is ready for the managers.
          if (_this.options.context) {
            // checks to see if a context is valid..
            (0, _validateContext2.default)(_this.options.context);
          }

          _this.gl = _this.options.context || _pixiGlCore2.default.createContext(_this.view, _this._contextOptions);

          _this.CONTEXT_UID = CONTEXT_UID++;

          /**
           * The currently active ObjectRenderer.
           *
           * @member {PIXI.WebGLState}
           */
          _this.state = new _WebGLState2.default(_this.gl);

          _this.renderingToScreen = true;

          /**
           * Holds the current state of textures bound to the GPU.
           * @type {Array}
           */
          _this.boundTextures = null;

          /**
           * Holds the current shader
           *
           * @member {PIXI.Shader}
           */
          _this._activeShader = null;

          _this._activeVao = null;

          /**
           * Holds the current render target
           *
           * @member {PIXI.RenderTarget}
           */
          _this._activeRenderTarget = null;

          _this._initContext();

          // map some webGL blend and drawmodes..
          _this.drawModes = (0, _mapWebGLDrawModesToPixi2.default)(_this.gl);

          _this._nextTextureLocation = 0;

          _this.setBlendMode(0);

          /**
           * Fired after rendering finishes.
           *
           * @event PIXI.WebGLRenderer#postrender
           */

          /**
           * Fired before rendering starts.
           *
           * @event PIXI.WebGLRenderer#prerender
           */

          /**
           * Fired when the WebGL context is set.
           *
           * @event PIXI.WebGLRenderer#context
           * @param {WebGLRenderingContext} gl - WebGL context.
           */
          return _this;
        }

        /**
         * Creates the WebGL context
         *
         * @private
         */

        WebGLRenderer.prototype._initContext = function _initContext() {
          let gl = this.gl;

          // restore a context if it was previously lost
          if (gl.isContextLost() && gl.getExtension("WEBGL_lose_context")) {
            gl.getExtension("WEBGL_lose_context").restoreContext();
          }

          let maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);

          this._activeShader = null;
          this._activeVao = null;

          this.boundTextures = new Array(maxTextures);
          this.emptyTextures = new Array(maxTextures);

          /**
           * Did someone temper with textures state? We'll overwrite them when we need to unbind something.
           * @member {boolean}
           * @private
           */
          this._unknownBoundTextures = false;

          // create a texture manager...
          this.textureManager = new _TextureManager2.default(this);
          this.filterManager = new _FilterManager2.default(this);
          this.textureGC = new _TextureGarbageCollector2.default(this);

          this.state.resetToDefault();

          this.rootRenderTarget = new _RenderTarget2.default(gl, this.width, this.height, null, this.resolution, true);
          this.rootRenderTarget.clearColor = this._backgroundColorRgba;

          this.bindRenderTarget(this.rootRenderTarget);

          // now lets fill up the textures with empty ones!
          let emptyGLTexture = new _pixiGlCore2.default.GLTexture.fromData(gl, null, 1, 1);

          let tempObj = { _glTextures: {} };

          tempObj._glTextures[this.CONTEXT_UID] = {};

          for (let i = 0; i < maxTextures; i++) {
            let empty = new _BaseTexture2.default();

            empty._glTextures[this.CONTEXT_UID] = emptyGLTexture;

            this.boundTextures[i] = tempObj;
            this.emptyTextures[i] = empty;
            this.bindTexture(null, i);
          }

          this.emit("context", gl);

          // setup the width/height properties and gl viewport
          this.resize(this.screen.width, this.screen.height);
        };

        /**
         * Renders the object to its webGL view
         *
         * @param {PIXI.DisplayObject} displayObject - the object to be rendered
         * @param {PIXI.RenderTexture} renderTexture - The render texture to render to.
         * @param {boolean} [clear] - Should the canvas be cleared before the new render
         * @param {PIXI.Matrix} [transform] - A transform to apply to the render texture before rendering.
         * @param {boolean} [skipUpdateTransform] - Should we skip the update transform pass?
         */

        WebGLRenderer.prototype.render = function render(displayObject, renderTexture, clear, transform, skipUpdateTransform) {
          // can be handy to know!
          this.renderingToScreen = !renderTexture;

          this.emit("prerender");

          // no point rendering if our context has been blown up!
          if (!this.gl || this.gl.isContextLost()) {
            return;
          }

          this._nextTextureLocation = 0;

          if (!renderTexture) {
            this._lastObjectRendered = displayObject;
          }

          if (!skipUpdateTransform) {
            // update the scene graph
            let cacheParent = displayObject.parent;

            displayObject.parent = this._tempDisplayObjectParent;
            displayObject.updateTransform();
            displayObject.parent = cacheParent;
            // displayObject.hitArea = //TODO add a temp hit area
          }

          this.bindRenderTexture(renderTexture, transform);

          this.currentRenderer.start();

          if (clear !== undefined ? clear : this.clearBeforeRender) {
            this._activeRenderTarget.clear();
          }

          displayObject.renderWebGL(this);

          // apply transform..
          this.currentRenderer.flush();

          // this.setObjectRenderer(this.emptyRenderer);

          this.textureGC.update();

          this.emit("postrender");
        };

        /**
         * Changes the current renderer to the one given in parameter
         *
         * @param {PIXI.ObjectRenderer} objectRenderer - The object renderer to use.
         */

        WebGLRenderer.prototype.setObjectRenderer = function setObjectRenderer(objectRenderer) {
          if (this.currentRenderer === objectRenderer) {
            return;
          }

          this.currentRenderer.stop();
          this.currentRenderer = objectRenderer;
          this.currentRenderer.start();
        };

        /**
         * This should be called if you wish to do some custom rendering
         * It will basically render anything that may be batched up such as sprites
         *
         */

        WebGLRenderer.prototype.flush = function flush() {
          this.setObjectRenderer(this.emptyRenderer);
        };

        /**
         * Resizes the webGL view to the specified width and height.
         *
         * @param {number} screenWidth - the new width of the screen
         * @param {number} screenHeight - the new height of the screen
         */

        WebGLRenderer.prototype.resize = function resize(screenWidth, screenHeight) {
          //  if(width * this.resolution === this.width && height * this.resolution === this.height)return;

          _SystemRenderer3.default.prototype.resize.call(this, screenWidth, screenHeight);

          this.rootRenderTarget.resize(screenWidth, screenHeight);

          if (this._activeRenderTarget === this.rootRenderTarget) {
            this.rootRenderTarget.activate();

            if (this._activeShader) {
              this._activeShader.uniforms.projectionMatrix = this.rootRenderTarget.projectionMatrix.toArray(true);
            }
          }
        };

        /**
         * Resizes the webGL view to the specified width and height.
         *
         * @param {number} blendMode - the desired blend mode
         */

        WebGLRenderer.prototype.setBlendMode = function setBlendMode(blendMode) {
          this.state.setBlendMode(blendMode);
        };

        /**
         * Erases the active render target and fills the drawing area with a colour
         *
         * @param {number} [clearColor] - The colour
         */

        WebGLRenderer.prototype.clear = function clear(clearColor) {
          this._activeRenderTarget.clear(clearColor);
        };

        /**
         * Sets the transform of the active render target to the given matrix
         *
         * @param {PIXI.Matrix} matrix - The transformation matrix
         */

        WebGLRenderer.prototype.setTransform = function setTransform(matrix) {
          this._activeRenderTarget.transform = matrix;
        };

        /**
         * Erases the render texture and fills the drawing area with a colour
         *
         * @param {PIXI.RenderTexture} renderTexture - The render texture to clear
         * @param {number} [clearColor] - The colour
         * @return {PIXI.WebGLRenderer} Returns itself.
         */

        WebGLRenderer.prototype.clearRenderTexture = function clearRenderTexture(renderTexture, clearColor) {
          let baseTexture = renderTexture.baseTexture;
          let renderTarget = baseTexture._glRenderTargets[this.CONTEXT_UID];

          if (renderTarget) {
            renderTarget.clear(clearColor);
          }

          return this;
        };

        /**
         * Binds a render texture for rendering
         *
         * @param {PIXI.RenderTexture} renderTexture - The render texture to render
         * @param {PIXI.Matrix} transform - The transform to be applied to the render texture
         * @return {PIXI.WebGLRenderer} Returns itself.
         */

        WebGLRenderer.prototype.bindRenderTexture = function bindRenderTexture(renderTexture, transform) {
          let renderTarget = void 0;

          if (renderTexture) {
            let baseTexture = renderTexture.baseTexture;

            if (!baseTexture._glRenderTargets[this.CONTEXT_UID]) {
              // bind the current texture
              this.textureManager.updateTexture(baseTexture, 0);
            }

            this.unbindTexture(baseTexture);

            renderTarget = baseTexture._glRenderTargets[this.CONTEXT_UID];
            renderTarget.setFrame(renderTexture.frame);
          } else {
            renderTarget = this.rootRenderTarget;
          }

          renderTarget.transform = transform;
          this.bindRenderTarget(renderTarget);

          return this;
        };

        /**
         * Changes the current render target to the one given in parameter
         *
         * @param {PIXI.RenderTarget} renderTarget - the new render target
         * @return {PIXI.WebGLRenderer} Returns itself.
         */

        WebGLRenderer.prototype.bindRenderTarget = function bindRenderTarget(renderTarget) {
          if (renderTarget !== this._activeRenderTarget) {
            this._activeRenderTarget = renderTarget;
            renderTarget.activate();

            if (this._activeShader) {
              this._activeShader.uniforms.projectionMatrix = renderTarget.projectionMatrix.toArray(true);
            }

            this.stencilManager.setMaskStack(renderTarget.stencilMaskStack);
          }

          return this;
        };

        /**
         * Changes the current shader to the one given in parameter
         *
         * @param {PIXI.Shader} shader - the new shader
         * @param {boolean} [autoProject=true] - Whether automatically set the projection matrix
         * @return {PIXI.WebGLRenderer} Returns itself.
         */

        WebGLRenderer.prototype.bindShader = function bindShader(shader, autoProject) {
          // TODO cache
          if (this._activeShader !== shader) {
            this._activeShader = shader;
            shader.bind();

            // `autoProject` normally would be a default parameter set to true
            // but because of how Babel transpiles default parameters
            // it hinders the performance of this method.
            if (autoProject !== false) {
              // automatically set the projection matrix
              shader.uniforms.projectionMatrix = this._activeRenderTarget.projectionMatrix.toArray(true);
            }
          }

          return this;
        };

        /**
         * Binds the texture. This will return the location of the bound texture.
         * It may not be the same as the one you pass in. This is due to optimisation that prevents
         * needless binding of textures. For example if the texture is already bound it will return the
         * current location of the texture instead of the one provided. To bypass this use force location
         *
         * @param {PIXI.Texture} texture - the new texture
         * @param {number} location - the suggested texture location
         * @param {boolean} forceLocation - force the location
         * @return {number} bound texture location
         */

        WebGLRenderer.prototype.bindTexture = function bindTexture(texture, location, forceLocation) {
          texture = texture || this.emptyTextures[location];
          texture = texture.baseTexture || texture;
          texture.touched = this.textureGC.count;

          if (!forceLocation) {
            // TODO - maybe look into adding boundIds.. save us the loop?
            for (let i = 0; i < this.boundTextures.length; i++) {
              if (this.boundTextures[i] === texture) {
                return i;
              }
            }

            if (location === undefined) {
              this._nextTextureLocation++;
              this._nextTextureLocation %= this.boundTextures.length;
              location = this.boundTextures.length - this._nextTextureLocation - 1;
            }
          } else {
            location = location || 0;
          }

          let gl = this.gl;
          let glTexture = texture._glTextures[this.CONTEXT_UID];

          if (!glTexture) {
            // this will also bind the texture..
            this.textureManager.updateTexture(texture, location);
          } else {
            // bind the current texture
            this.boundTextures[location] = texture;
            gl.activeTexture(gl.TEXTURE0 + location);
            gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);
          }

          return location;
        };

        /**
         * unbinds the texture ...
         *
         * @param {PIXI.Texture} texture - the texture to unbind
         * @return {PIXI.WebGLRenderer} Returns itself.
         */

        WebGLRenderer.prototype.unbindTexture = function unbindTexture(texture) {
          let gl = this.gl;

          texture = texture.baseTexture || texture;

          if (this._unknownBoundTextures) {
            this._unknownBoundTextures = false;
            // someone changed webGL state,
            // we have to be sure that our texture does not appear in multitexture renderer samplers

            for (let i = 0; i < this.boundTextures.length; i++) {
              if (this.boundTextures[i] === this.emptyTextures[i]) {
                gl.activeTexture(gl.TEXTURE0 + i);
                gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[i]._glTextures[this.CONTEXT_UID].texture);
              }
            }
          }

          for (let _i = 0; _i < this.boundTextures.length; _i++) {
            if (this.boundTextures[_i] === texture) {
              this.boundTextures[_i] = this.emptyTextures[_i];

              gl.activeTexture(gl.TEXTURE0 + _i);
              gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[_i]._glTextures[this.CONTEXT_UID].texture);
            }
          }

          return this;
        };

        /**
         * Creates a new VAO from this renderer's context and state.
         *
         * @return {VertexArrayObject} The new VAO.
         */

        WebGLRenderer.prototype.createVao = function createVao() {
          return new _pixiGlCore2.default.VertexArrayObject(this.gl, this.state.attribState);
        };

        /**
         * Changes the current Vao to the one given in parameter
         *
         * @param {PIXI.VertexArrayObject} vao - the new Vao
         * @return {PIXI.WebGLRenderer} Returns itself.
         */

        WebGLRenderer.prototype.bindVao = function bindVao(vao) {
          if (this._activeVao === vao) {
            return this;
          }

          if (vao) {
            vao.bind();
          } else if (this._activeVao) {
            // TODO this should always be true i think?
            this._activeVao.unbind();
          }

          this._activeVao = vao;

          return this;
        };

        /**
         * Resets the WebGL state so you can render things however you fancy!
         *
         * @return {PIXI.WebGLRenderer} Returns itself.
         */

        WebGLRenderer.prototype.reset = function reset() {
          this.setObjectRenderer(this.emptyRenderer);

          this.bindVao(null);
          this._activeShader = null;
          this._activeRenderTarget = this.rootRenderTarget;

          this._unknownBoundTextures = true;

          for (let i = 0; i < this.boundTextures.length; i++) {
            this.boundTextures[i] = this.emptyTextures[i];
          }

          // bind the main frame buffer (the screen);
          this.rootRenderTarget.activate();

          this.state.resetToDefault();

          return this;
        };

        /**
         * Handles a lost webgl context
         *
         * @private
         * @param {WebGLContextEvent} event - The context lost event.
         */

        WebGLRenderer.prototype.handleContextLost = function handleContextLost(event) {
          event.preventDefault();
        };

        /**
         * Handles a restored webgl context
         *
         * @private
         */

        WebGLRenderer.prototype.handleContextRestored = function handleContextRestored() {
          this.textureManager.removeAll();
          this.filterManager.destroy(true);
          this._initContext();
        };

        /**
         * Removes everything from the renderer (event listeners, spritebatch, etc...)
         *
         * @param {boolean} [removeView=false] - Removes the Canvas element from the DOM.
         *  See: https://github.com/pixijs/pixi.js/issues/2233
         */

        WebGLRenderer.prototype.destroy = function destroy(removeView) {
          this.destroyPlugins();

          // remove listeners
          this.view.removeEventListener("webglcontextlost", this.handleContextLost);
          this.view.removeEventListener("webglcontextrestored", this.handleContextRestored);

          this.textureManager.destroy();

          // call base destroy
          _SystemRenderer.prototype.destroy.call(this, removeView);

          this.uid = 0;

          // destroy the managers
          this.maskManager.destroy();
          this.stencilManager.destroy();
          this.filterManager.destroy();

          this.maskManager = null;
          this.filterManager = null;
          this.textureManager = null;
          this.currentRenderer = null;

          this.handleContextLost = null;
          this.handleContextRestored = null;

          this._contextOptions = null;
          this.gl.useProgram(null);

          if (this.gl.getExtension("WEBGL_lose_context")) {
            this.gl.getExtension("WEBGL_lose_context").loseContext();
          }

          this.gl = null;

          // this = null;
        };

        return WebGLRenderer;
      })(_SystemRenderer3.default);

      /**
       * Collection of installed plugins. These are included by default in PIXI, but can be excluded
       * by creating a custom build. Consult the README for more information about creating custom
       * builds and excluding plugins.
       * @name PIXI.WebGLRenderer#plugins
       * @type {object}
       * @readonly
       * @property {PIXI.accessibility.AccessibilityManager} accessibility Support tabbing interactive elements.
       * @property {PIXI.extract.WebGLExtract} extract Extract image data from renderer.
       * @property {PIXI.interaction.InteractionManager} interaction Handles mouse, touch and pointer events.
       * @property {PIXI.prepare.WebGLPrepare} prepare Pre-render display objects.
       */

      /**
       * Adds a plugin to the renderer.
       *
       * @method PIXI.WebGLRenderer#registerPlugin
       * @param {string} pluginName - The name of the plugin.
       * @param {Function} ctor - The constructor function or class for the plugin.
       */

      exports.default = WebGLRenderer;
      _utils.pluginTarget.mixin(WebGLRenderer);
      //# sourceMappingURL=WebGLRenderer.js.map

      /***/
    },
    /* 367 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      let _math = __webpack_require__(348);

      let _const = __webpack_require__(343);

      let _settings = __webpack_require__(346);

      let _settings2 = _interopRequireDefault(_settings);

      let _pixiGlCore = __webpack_require__(350);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      /**
       * @class
       * @memberof PIXI
       */
      let RenderTarget = (function () {
        /**
         * @param {WebGLRenderingContext} gl - The current WebGL drawing context
         * @param {number} [width=0] - the horizontal range of the filter
         * @param {number} [height=0] - the vertical range of the filter
         * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
         * @param {number} [resolution=1] - The current resolution / device pixel ratio
         * @param {boolean} [root=false] - Whether this object is the root element or not
         */
        function RenderTarget(gl, width, height, scaleMode, resolution, root) {
          _classCallCheck(this, RenderTarget);

          // TODO Resolution could go here ( eg low res blurs )

          /**
           * The current WebGL drawing context.
           *
           * @member {WebGLRenderingContext}
           */
          this.gl = gl;

          // next time to create a frame buffer and texture

          /**
           * A frame buffer
           *
           * @member {PIXI.glCore.GLFramebuffer}
           */
          this.frameBuffer = null;

          /**
           * The texture
           *
           * @member {PIXI.glCore.GLTexture}
           */
          this.texture = null;

          /**
           * The background colour of this render target, as an array of [r,g,b,a] values
           *
           * @member {number[]}
           */
          this.clearColor = [0, 0, 0, 0];

          /**
           * The size of the object as a rectangle
           *
           * @member {PIXI.Rectangle}
           */
          this.size = new _math.Rectangle(0, 0, 1, 1);

          /**
           * The current resolution / device pixel ratio
           *
           * @member {number}
           * @default 1
           */
          this.resolution = resolution || _settings2.default.RESOLUTION;

          /**
           * The projection matrix
           *
           * @member {PIXI.Matrix}
           */
          this.projectionMatrix = new _math.Matrix();

          /**
           * The object's transform
           *
           * @member {PIXI.Matrix}
           */
          this.transform = null;

          /**
           * The frame.
           *
           * @member {PIXI.Rectangle}
           */
          this.frame = null;

          /**
           * The stencil buffer stores masking data for the render target
           *
           * @member {glCore.GLBuffer}
           */
          this.defaultFrame = new _math.Rectangle();
          this.destinationFrame = null;
          this.sourceFrame = null;

          /**
           * The stencil buffer stores masking data for the render target
           *
           * @member {glCore.GLBuffer}
           */
          this.stencilBuffer = null;

          /**
           * The data structure for the stencil masks
           *
           * @member {PIXI.Graphics[]}
           */
          this.stencilMaskStack = [];

          /**
           * Stores filter data for the render target
           *
           * @member {object[]}
           */
          this.filterData = null;

          /**
           * The key for pooled texture of FilterSystem
           * @private
           * @member {string}
           */
          this.filterPoolKey = "";

          /**
           * The scale mode.
           *
           * @member {number}
           * @default PIXI.settings.SCALE_MODE
           * @see PIXI.SCALE_MODES
           */
          this.scaleMode = scaleMode !== undefined ? scaleMode : _settings2.default.SCALE_MODE;

          /**
           * Whether this object is the root element or not
           *
           * @member {boolean}
           * @default false
           */
          this.root = root || false;

          if (!this.root) {
            this.frameBuffer = _pixiGlCore.GLFramebuffer.createRGBA(gl, 100, 100);

            if (this.scaleMode === _const.SCALE_MODES.NEAREST) {
              this.frameBuffer.texture.enableNearestScaling();
            } else {
              this.frameBuffer.texture.enableLinearScaling();
            }
            /*
            A frame buffer needs a target to render to..
            create a texture and bind it attach it to the framebuffer..
         */

            // this is used by the base texture
            this.texture = this.frameBuffer.texture;
          } else {
            // make it a null framebuffer..
            this.frameBuffer = new _pixiGlCore.GLFramebuffer(gl, 100, 100);
            this.frameBuffer.framebuffer = null;
          }

          this.setFrame();

          this.resize(width, height);
        }

        /**
         * Clears the filter texture.
         *
         * @param {number[]} [clearColor=this.clearColor] - Array of [r,g,b,a] to clear the framebuffer
         */

        RenderTarget.prototype.clear = function clear(clearColor) {
          let cc = clearColor || this.clearColor;

          this.frameBuffer.clear(cc[0], cc[1], cc[2], cc[3]); // r,g,b,a);
        };

        /**
         * Binds the stencil buffer.
         *
         */

        RenderTarget.prototype.attachStencilBuffer = function attachStencilBuffer() {
          // TODO check if stencil is done?
          /**
           * The stencil buffer is used for masking in pixi
           * lets create one and then add attach it to the framebuffer..
           */
          if (!this.root) {
            this.frameBuffer.enableStencil();
          }
        };

        /**
         * Sets the frame of the render target.
         *
         * @param {Rectangle} destinationFrame - The destination frame.
         * @param {Rectangle} sourceFrame - The source frame.
         */

        RenderTarget.prototype.setFrame = function setFrame(destinationFrame, sourceFrame) {
          this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;
          this.sourceFrame = sourceFrame || this.sourceFrame || this.destinationFrame;
        };

        /**
         * Binds the buffers and initialises the viewport.
         *
         */

        RenderTarget.prototype.activate = function activate() {
          // TODO refactor usage of frame..
          let gl = this.gl;

          // make sure the texture is unbound!
          this.frameBuffer.bind();

          this.calculateProjection(this.destinationFrame, this.sourceFrame);

          if (this.transform) {
            this.projectionMatrix.append(this.transform);
          }

          // TODO add a check as them may be the same!
          if (this.destinationFrame !== this.sourceFrame) {
            gl.enable(gl.SCISSOR_TEST);
            gl.scissor(
              this.destinationFrame.x | 0,
              this.destinationFrame.y | 0,
              (this.destinationFrame.width * this.resolution) | 0,
              (this.destinationFrame.height * this.resolution) | 0
            );
          } else {
            gl.disable(gl.SCISSOR_TEST);
          }

          // TODO - does not need to be updated all the time??
          gl.viewport(
            this.destinationFrame.x | 0,
            this.destinationFrame.y | 0,
            (this.destinationFrame.width * this.resolution) | 0,
            (this.destinationFrame.height * this.resolution) | 0
          );
        };

        /**
         * Updates the projection matrix based on a projection frame (which is a rectangle)
         *
         * @param {Rectangle} destinationFrame - The destination frame.
         * @param {Rectangle} sourceFrame - The source frame.
         */

        RenderTarget.prototype.calculateProjection = function calculateProjection(destinationFrame, sourceFrame) {
          let pm = this.projectionMatrix;

          sourceFrame = sourceFrame || destinationFrame;

          pm.identity();

          // TODO: make dest scale source
          if (!this.root) {
            pm.a = (1 / destinationFrame.width) * 2;
            pm.d = (1 / destinationFrame.height) * 2;

            pm.tx = -1 - sourceFrame.x * pm.a;
            pm.ty = -1 - sourceFrame.y * pm.d;
          } else {
            pm.a = (1 / destinationFrame.width) * 2;
            pm.d = (-1 / destinationFrame.height) * 2;

            pm.tx = -1 - sourceFrame.x * pm.a;
            pm.ty = 1 - sourceFrame.y * pm.d;
          }
        };

        /**
         * Resizes the texture to the specified width and height
         *
         * @param {number} width - the new width of the texture
         * @param {number} height - the new height of the texture
         */

        RenderTarget.prototype.resize = function resize(width, height) {
          width = width | 0;
          height = height | 0;

          if (this.size.width === width && this.size.height === height) {
            return;
          }

          this.size.width = width;
          this.size.height = height;

          this.defaultFrame.width = width;
          this.defaultFrame.height = height;

          this.frameBuffer.resize(width * this.resolution, height * this.resolution);

          let projectionFrame = this.frame || this.size;

          this.calculateProjection(projectionFrame);
        };

        /**
         * Destroys the render target.
         *
         */

        RenderTarget.prototype.destroy = function destroy() {
          if (this.frameBuffer.stencil) {
            this.gl.deleteRenderbuffer(this.frameBuffer.stencil);
          }
          this.frameBuffer.destroy();

          this.frameBuffer = null;
          this.texture = null;
        };

        return RenderTarget;
      })();

      exports.default = RenderTarget;
      //# sourceMappingURL=RenderTarget.js.map

      /***/
    },
    /* 368 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      exports.default = function (graphicsData, webGLData, webGLDataNativeLines) {
        if (graphicsData.nativeLines) {
          buildNativeLine(graphicsData, webGLDataNativeLines);
        } else {
          buildLine(graphicsData, webGLData);
        }
      };

      let _math = __webpack_require__(348);

      let _utils = __webpack_require__(345);

      /**
       * Builds a line to draw using the poligon method.
       *
       * Ignored from docs since it is not directly exposed.
       *
       * @ignore
       * @private
       * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
       * @param {object} webGLData - an object containing all the webGL-specific information to create this shape
       */
      function buildLine(graphicsData, webGLData) {
        // TODO OPTIMISE!
        let points = graphicsData.points;

        if (points.length === 0) {
          return;
        }
        // if the line width is an odd number add 0.5 to align to a whole pixel
        // commenting this out fixes #711 and #1620
        // if (graphicsData.lineWidth%2)
        // {
        //     for (i = 0; i < points.length; i++)
        //     {
        //         points[i] += 0.5;
        //     }
        // }

        // get first and last point.. figure out the middle!
        let firstPoint = new _math.Point(points[0], points[1]);
        let lastPoint = new _math.Point(points[points.length - 2], points[points.length - 1]);

        // if the first point is the last point - gonna have issues :)
        if (firstPoint.x === lastPoint.x && firstPoint.y === lastPoint.y) {
          // need to clone as we are going to slightly modify the shape..
          points = points.slice();

          points.pop();
          points.pop();

          lastPoint = new _math.Point(points[points.length - 2], points[points.length - 1]);

          let midPointX = lastPoint.x + (firstPoint.x - lastPoint.x) * 0.5;
          let midPointY = lastPoint.y + (firstPoint.y - lastPoint.y) * 0.5;

          points.unshift(midPointX, midPointY);
          points.push(midPointX, midPointY);
        }

        let verts = webGLData.points;
        let indices = webGLData.indices;
        let length = points.length / 2;
        let indexCount = points.length;
        let indexStart = verts.length / 6;

        // DRAW the Line
        let width = graphicsData.lineWidth / 2;

        // sort color
        let color = (0, _utils.hex2rgb)(graphicsData.lineColor);
        let alpha = graphicsData.lineAlpha;
        let r = color[0] * alpha;
        let g = color[1] * alpha;
        let b = color[2] * alpha;

        let p1x = points[0];
        let p1y = points[1];
        let p2x = points[2];
        let p2y = points[3];
        let p3x = 0;
        let p3y = 0;

        let perpx = -(p1y - p2y);
        let perpy = p1x - p2x;
        let perp2x = 0;
        let perp2y = 0;
        let perp3x = 0;
        let perp3y = 0;

        let dist = Math.sqrt(perpx * perpx + perpy * perpy);

        perpx /= dist;
        perpy /= dist;
        perpx *= width;
        perpy *= width;

        let ratio = graphicsData.lineAlignment; // 0.5;
        let r1 = (1 - ratio) * 2;
        let r2 = ratio * 2;

        // start
        verts.push(p1x - perpx * r1, p1y - perpy * r1, r, g, b, alpha);

        verts.push(p1x + perpx * r2, p1y + perpy * r2, r, g, b, alpha);

        for (let i = 1; i < length - 1; ++i) {
          p1x = points[(i - 1) * 2];
          p1y = points[(i - 1) * 2 + 1];

          p2x = points[i * 2];
          p2y = points[i * 2 + 1];

          p3x = points[(i + 1) * 2];
          p3y = points[(i + 1) * 2 + 1];

          perpx = -(p1y - p2y);
          perpy = p1x - p2x;

          dist = Math.sqrt(perpx * perpx + perpy * perpy);
          perpx /= dist;
          perpy /= dist;
          perpx *= width;
          perpy *= width;

          perp2x = -(p2y - p3y);
          perp2y = p2x - p3x;

          dist = Math.sqrt(perp2x * perp2x + perp2y * perp2y);
          perp2x /= dist;
          perp2y /= dist;
          perp2x *= width;
          perp2y *= width;

          let a1 = -perpy + p1y - (-perpy + p2y);
          let b1 = -perpx + p2x - (-perpx + p1x);
          let c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);
          let a2 = -perp2y + p3y - (-perp2y + p2y);
          let b2 = -perp2x + p2x - (-perp2x + p3x);
          let c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);

          let denom = a1 * b2 - a2 * b1;

          if (Math.abs(denom) < 0.1) {
            denom += 10.1;
            verts.push(p2x - perpx * r1, p2y - perpy * r1, r, g, b, alpha);

            verts.push(p2x + perpx * r2, p2y + perpy * r2, r, g, b, alpha);

            continue;
          }

          let px = (b1 * c2 - b2 * c1) / denom;
          let py = (a2 * c1 - a1 * c2) / denom;
          let pdist = (px - p2x) * (px - p2x) + (py - p2y) * (py - p2y);

          if (pdist > 196 * width * width) {
            perp3x = perpx - perp2x;
            perp3y = perpy - perp2y;

            dist = Math.sqrt(perp3x * perp3x + perp3y * perp3y);
            perp3x /= dist;
            perp3y /= dist;
            perp3x *= width;
            perp3y *= width;

            verts.push(p2x - perp3x * r1, p2y - perp3y * r1);
            verts.push(r, g, b, alpha);

            verts.push(p2x + perp3x * r2, p2y + perp3y * r2);
            verts.push(r, g, b, alpha);

            verts.push(p2x - perp3x * r2 * r1, p2y - perp3y * r1);
            verts.push(r, g, b, alpha);

            indexCount++;
          } else {
            verts.push(p2x + (px - p2x) * r1, p2y + (py - p2y) * r1);
            verts.push(r, g, b, alpha);

            verts.push(p2x - (px - p2x) * r2, p2y - (py - p2y) * r2);
            verts.push(r, g, b, alpha);
          }
        }

        p1x = points[(length - 2) * 2];
        p1y = points[(length - 2) * 2 + 1];

        p2x = points[(length - 1) * 2];
        p2y = points[(length - 1) * 2 + 1];

        perpx = -(p1y - p2y);
        perpy = p1x - p2x;

        dist = Math.sqrt(perpx * perpx + perpy * perpy);
        perpx /= dist;
        perpy /= dist;
        perpx *= width;
        perpy *= width;

        verts.push(p2x - perpx * r1, p2y - perpy * r1);
        verts.push(r, g, b, alpha);

        verts.push(p2x + perpx * r2, p2y + perpy * r2);
        verts.push(r, g, b, alpha);

        indices.push(indexStart);

        for (let _i = 0; _i < indexCount; ++_i) {
          indices.push(indexStart++);
        }

        indices.push(indexStart - 1);
      }

      /**
       * Builds a line to draw using the gl.drawArrays(gl.LINES) method
       *
       * Ignored from docs since it is not directly exposed.
       *
       * @ignore
       * @private
       * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
       * @param {object} webGLData - an object containing all the webGL-specific information to create this shape
       */

      /**
       * Builds a line to draw
       *
       * Ignored from docs since it is not directly exposed.
       *
       * @ignore
       * @private
       * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
       * @param {object} webGLData - an object containing all the webGL-specific information to create this shape
       * @param {object} webGLDataNativeLines - an object containing all the webGL-specific information to create nativeLines
       */
      function buildNativeLine(graphicsData, webGLData) {
        let i = 0;
        let points = graphicsData.points;

        if (points.length === 0) return;

        let verts = webGLData.points;
        let length = points.length / 2;

        // sort color
        let color = (0, _utils.hex2rgb)(graphicsData.lineColor);
        let alpha = graphicsData.lineAlpha;
        let r = color[0] * alpha;
        let g = color[1] * alpha;
        let b = color[2] * alpha;

        for (i = 1; i < length; i++) {
          let p1x = points[(i - 1) * 2];
          let p1y = points[(i - 1) * 2 + 1];

          let p2x = points[i * 2];
          let p2y = points[i * 2 + 1];

          verts.push(p1x, p1y);
          verts.push(r, g, b, alpha);

          verts.push(p2x, p2y);
          verts.push(r, g, b, alpha);
        }
      }
      //# sourceMappingURL=buildLine.js.map

      /***/
    },
    ,
    ,
    ,
    ,
    /* 369 */ /* 370 */ /* 371 */ /* 372 */ /* 373 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      /**
       * The Point object represents a location in a two-dimensional coordinate system, where x represents
       * the horizontal axis and y represents the vertical axis.
       *
       * @class
       * @memberof PIXI
       */
      let Point = (function () {
        /**
         * @param {number} [x=0] - position of the point on the x axis
         * @param {number} [y=0] - position of the point on the y axis
         */
        function Point() {
          let x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
          let y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

          _classCallCheck(this, Point);

          /**
           * @member {number}
           * @default 0
           */
          this.x = x;

          /**
           * @member {number}
           * @default 0
           */
          this.y = y;
        }

        /**
         * Creates a clone of this point
         *
         * @return {PIXI.Point} a copy of the point
         */

        Point.prototype.clone = function clone() {
          return new Point(this.x, this.y);
        };

        /**
         * Copies x and y from the given point
         *
         * @param {PIXI.Point} p - The point to copy.
         */

        Point.prototype.copy = function copy(p) {
          this.set(p.x, p.y);
        };

        /**
         * Returns true if the given point is equal to this point
         *
         * @param {PIXI.Point} p - The point to check
         * @returns {boolean} Whether the given point equal to this point
         */

        Point.prototype.equals = function equals(p) {
          return p.x === this.x && p.y === this.y;
        };

        /**
         * Sets the point to a new x and y position.
         * If y is omitted, both x and y will be set to x.
         *
         * @param {number} [x=0] - position of the point on the x axis
         * @param {number} [y=0] - position of the point on the y axis
         */

        Point.prototype.set = function set(x, y) {
          this.x = x || 0;
          this.y = y || (y !== 0 ? this.x : 0);
        };

        return Point;
      })();

      exports.default = Point;
      //# sourceMappingURL=Point.js.map

      /***/
    },
    /* 374 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      let _createClass = (function () {
        function defineProperties(target, props) {
          for (let i = 0; i < props.length; i++) {
            let descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      })();

      let _Point = __webpack_require__(373);

      let _Point2 = _interopRequireDefault(_Point);

      let _const = __webpack_require__(343);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      /**
       * The PixiJS Matrix class as an object, which makes it a lot faster,
       * here is a representation of it :
       * | a | c | tx|
       * | b | d | ty|
       * | 0 | 0 | 1 |
       *
       * @class
       * @memberof PIXI
       */
      let Matrix = (function () {
        /**
         * @param {number} [a=1] - x scale
         * @param {number} [b=0] - x skew
         * @param {number} [c=0] - y skew
         * @param {number} [d=1] - y scale
         * @param {number} [tx=0] - x translation
         * @param {number} [ty=0] - y translation
         */
        function Matrix() {
          let a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
          let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          let c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
          let d = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
          let tx = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
          let ty = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

          _classCallCheck(this, Matrix);

          /**
           * @member {number}
           * @default 1
           */
          this.a = a;

          /**
           * @member {number}
           * @default 0
           */
          this.b = b;

          /**
           * @member {number}
           * @default 0
           */
          this.c = c;

          /**
           * @member {number}
           * @default 1
           */
          this.d = d;

          /**
           * @member {number}
           * @default 0
           */
          this.tx = tx;

          /**
           * @member {number}
           * @default 0
           */
          this.ty = ty;

          this.array = null;
        }

        /**
         * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
         *
         * a = array[0]
         * b = array[1]
         * c = array[3]
         * d = array[4]
         * tx = array[2]
         * ty = array[5]
         *
         * @param {number[]} array - The array that the matrix will be populated from.
         */

        Matrix.prototype.fromArray = function fromArray(array) {
          this.a = array[0];
          this.b = array[1];
          this.c = array[3];
          this.d = array[4];
          this.tx = array[2];
          this.ty = array[5];
        };

        /**
         * sets the matrix properties
         *
         * @param {number} a - Matrix component
         * @param {number} b - Matrix component
         * @param {number} c - Matrix component
         * @param {number} d - Matrix component
         * @param {number} tx - Matrix component
         * @param {number} ty - Matrix component
         *
         * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
         */

        Matrix.prototype.set = function set(a, b, c, d, tx, ty) {
          this.a = a;
          this.b = b;
          this.c = c;
          this.d = d;
          this.tx = tx;
          this.ty = ty;

          return this;
        };

        /**
         * Creates an array from the current Matrix object.
         *
         * @param {boolean} transpose - Whether we need to transpose the matrix or not
         * @param {Float32Array} [out=new Float32Array(9)] - If provided the array will be assigned to out
         * @return {number[]} the newly created array which contains the matrix
         */

        Matrix.prototype.toArray = function toArray(transpose, out) {
          if (!this.array) {
            this.array = new Float32Array(9);
          }

          let array = out || this.array;

          if (transpose) {
            array[0] = this.a;
            array[1] = this.b;
            array[2] = 0;
            array[3] = this.c;
            array[4] = this.d;
            array[5] = 0;
            array[6] = this.tx;
            array[7] = this.ty;
            array[8] = 1;
          } else {
            array[0] = this.a;
            array[1] = this.c;
            array[2] = this.tx;
            array[3] = this.b;
            array[4] = this.d;
            array[5] = this.ty;
            array[6] = 0;
            array[7] = 0;
            array[8] = 1;
          }

          return array;
        };

        /**
         * Get a new position with the current transformation applied.
         * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
         *
         * @param {PIXI.Point} pos - The origin
         * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
         * @return {PIXI.Point} The new point, transformed through this matrix
         */

        Matrix.prototype.apply = function apply(pos, newPos) {
          newPos = newPos || new _Point2.default();

          let x = pos.x;
          let y = pos.y;

          newPos.x = this.a * x + this.c * y + this.tx;
          newPos.y = this.b * x + this.d * y + this.ty;

          return newPos;
        };

        /**
         * Get a new position with the inverse of the current transformation applied.
         * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
         *
         * @param {PIXI.Point} pos - The origin
         * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
         * @return {PIXI.Point} The new point, inverse-transformed through this matrix
         */

        Matrix.prototype.applyInverse = function applyInverse(pos, newPos) {
          newPos = newPos || new _Point2.default();

          let id = 1 / (this.a * this.d + this.c * -this.b);

          let x = pos.x;
          let y = pos.y;

          newPos.x = this.d * id * x + -this.c * id * y + (this.ty * this.c - this.tx * this.d) * id;
          newPos.y = this.a * id * y + -this.b * id * x + (-this.ty * this.a + this.tx * this.b) * id;

          return newPos;
        };

        /**
         * Translates the matrix on the x and y.
         *
         * @param {number} x How much to translate x by
         * @param {number} y How much to translate y by
         * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
         */

        Matrix.prototype.translate = function translate(x, y) {
          this.tx += x;
          this.ty += y;

          return this;
        };

        /**
         * Applies a scale transformation to the matrix.
         *
         * @param {number} x The amount to scale horizontally
         * @param {number} y The amount to scale vertically
         * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
         */

        Matrix.prototype.scale = function scale(x, y) {
          this.a *= x;
          this.d *= y;
          this.c *= x;
          this.b *= y;
          this.tx *= x;
          this.ty *= y;

          return this;
        };

        /**
         * Applies a rotation transformation to the matrix.
         *
         * @param {number} angle - The angle in radians.
         * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
         */

        Matrix.prototype.rotate = function rotate(angle) {
          let cos = Math.cos(angle);
          let sin = Math.sin(angle);

          let a1 = this.a;
          let c1 = this.c;
          let tx1 = this.tx;

          this.a = a1 * cos - this.b * sin;
          this.b = a1 * sin + this.b * cos;
          this.c = c1 * cos - this.d * sin;
          this.d = c1 * sin + this.d * cos;
          this.tx = tx1 * cos - this.ty * sin;
          this.ty = tx1 * sin + this.ty * cos;

          return this;
        };

        /**
         * Appends the given Matrix to this Matrix.
         *
         * @param {PIXI.Matrix} matrix - The matrix to append.
         * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
         */

        Matrix.prototype.append = function append(matrix) {
          let a1 = this.a;
          let b1 = this.b;
          let c1 = this.c;
          let d1 = this.d;

          this.a = matrix.a * a1 + matrix.b * c1;
          this.b = matrix.a * b1 + matrix.b * d1;
          this.c = matrix.c * a1 + matrix.d * c1;
          this.d = matrix.c * b1 + matrix.d * d1;

          this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
          this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;

          return this;
        };

        /**
         * Sets the matrix based on all the available properties
         *
         * @param {number} x - Position on the x axis
         * @param {number} y - Position on the y axis
         * @param {number} pivotX - Pivot on the x axis
         * @param {number} pivotY - Pivot on the y axis
         * @param {number} scaleX - Scale on the x axis
         * @param {number} scaleY - Scale on the y axis
         * @param {number} rotation - Rotation in radians
         * @param {number} skewX - Skew on the x axis
         * @param {number} skewY - Skew on the y axis
         * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
         */

        Matrix.prototype.setTransform = function setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
          this.a = Math.cos(rotation + skewY) * scaleX;
          this.b = Math.sin(rotation + skewY) * scaleX;
          this.c = -Math.sin(rotation - skewX) * scaleY;
          this.d = Math.cos(rotation - skewX) * scaleY;

          this.tx = x - (pivotX * this.a + pivotY * this.c);
          this.ty = y - (pivotX * this.b + pivotY * this.d);

          return this;
        };

        /**
         * Prepends the given Matrix to this Matrix.
         *
         * @param {PIXI.Matrix} matrix - The matrix to prepend
         * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
         */

        Matrix.prototype.prepend = function prepend(matrix) {
          let tx1 = this.tx;

          if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
            let a1 = this.a;
            let c1 = this.c;

            this.a = a1 * matrix.a + this.b * matrix.c;
            this.b = a1 * matrix.b + this.b * matrix.d;
            this.c = c1 * matrix.a + this.d * matrix.c;
            this.d = c1 * matrix.b + this.d * matrix.d;
          }

          this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
          this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;

          return this;
        };

        /**
         * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.
         *
         * @param {PIXI.Transform|PIXI.TransformStatic} transform - The transform to apply the properties to.
         * @return {PIXI.Transform|PIXI.TransformStatic} The transform with the newly applied properties
         */

        Matrix.prototype.decompose = function decompose(transform) {
          // sort out rotation / skew..
          let a = this.a;
          let b = this.b;
          let c = this.c;
          let d = this.d;

          let skewX = -Math.atan2(-c, d);
          let skewY = Math.atan2(b, a);

          let delta = Math.abs(skewX + skewY);

          if (delta < 0.00001 || Math.abs(_const.PI_2 - delta) < 0.00001) {
            transform.rotation = skewY;
            transform.skew.x = transform.skew.y = 0;
          } else {
            transform.rotation = 0;
            transform.skew.x = skewX;
            transform.skew.y = skewY;
          }

          // next set scale
          transform.scale.x = Math.sqrt(a * a + b * b);
          transform.scale.y = Math.sqrt(c * c + d * d);

          // next set position
          transform.position.x = this.tx;
          transform.position.y = this.ty;

          return transform;
        };

        /**
         * Inverts this matrix
         *
         * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
         */

        Matrix.prototype.invert = function invert() {
          let a1 = this.a;
          let b1 = this.b;
          let c1 = this.c;
          let d1 = this.d;
          let tx1 = this.tx;
          let n = a1 * d1 - b1 * c1;

          this.a = d1 / n;
          this.b = -b1 / n;
          this.c = -c1 / n;
          this.d = a1 / n;
          this.tx = (c1 * this.ty - d1 * tx1) / n;
          this.ty = -(a1 * this.ty - b1 * tx1) / n;

          return this;
        };

        /**
         * Resets this Matix to an identity (default) matrix.
         *
         * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
         */

        Matrix.prototype.identity = function identity() {
          this.a = 1;
          this.b = 0;
          this.c = 0;
          this.d = 1;
          this.tx = 0;
          this.ty = 0;

          return this;
        };

        /**
         * Creates a new Matrix object with the same values as this one.
         *
         * @return {PIXI.Matrix} A copy of this matrix. Good for chaining method calls.
         */

        Matrix.prototype.clone = function clone() {
          let matrix = new Matrix();

          matrix.a = this.a;
          matrix.b = this.b;
          matrix.c = this.c;
          matrix.d = this.d;
          matrix.tx = this.tx;
          matrix.ty = this.ty;

          return matrix;
        };

        /**
         * Changes the values of the given matrix to be the same as the ones in this matrix
         *
         * @param {PIXI.Matrix} matrix - The matrix to copy from.
         * @return {PIXI.Matrix} The matrix given in parameter with its values updated.
         */

        Matrix.prototype.copy = function copy(matrix) {
          matrix.a = this.a;
          matrix.b = this.b;
          matrix.c = this.c;
          matrix.d = this.d;
          matrix.tx = this.tx;
          matrix.ty = this.ty;

          return matrix;
        };

        /**
         * A default (identity) matrix
         *
         * @static
         * @const
         */

        _createClass(Matrix, null, [
          {
            key: "IDENTITY",
            get: function get() {
              return new Matrix();
            },

            /**
             * A temp matrix
             *
             * @static
             * @const
             */
          },
          {
            key: "TEMP_MATRIX",
            get: function get() {
              return new Matrix();
            },
          },
        ]);

        return Matrix;
      })();

      exports.default = Matrix;
      //# sourceMappingURL=Matrix.js.map

      /***/
    },
    /* 375 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      let _createClass = (function () {
        function defineProperties(target, props) {
          for (let i = 0; i < props.length; i++) {
            let descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      })();

      let _const = __webpack_require__(343);

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      /**
       * Rectangle object is an area defined by its position, as indicated by its top-left corner
       * point (x, y) and by its width and its height.
       *
       * @class
       * @memberof PIXI
       */
      let Rectangle = (function () {
        /**
         * @param {number} [x=0] - The X coordinate of the upper-left corner of the rectangle
         * @param {number} [y=0] - The Y coordinate of the upper-left corner of the rectangle
         * @param {number} [width=0] - The overall width of this rectangle
         * @param {number} [height=0] - The overall height of this rectangle
         */
        function Rectangle() {
          let x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
          let y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          let width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
          let height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

          _classCallCheck(this, Rectangle);

          /**
           * @member {number}
           * @default 0
           */
          this.x = Number(x);

          /**
           * @member {number}
           * @default 0
           */
          this.y = Number(y);

          /**
           * @member {number}
           * @default 0
           */
          this.width = Number(width);

          /**
           * @member {number}
           * @default 0
           */
          this.height = Number(height);

          /**
           * The type of the object, mainly used to avoid `instanceof` checks
           *
           * @member {number}
           * @readOnly
           * @default PIXI.SHAPES.RECT
           * @see PIXI.SHAPES
           */
          this.type = _const.SHAPES.RECT;
        }

        /**
         * returns the left edge of the rectangle
         *
         * @member {number}
         */

        /**
         * Creates a clone of this Rectangle
         *
         * @return {PIXI.Rectangle} a copy of the rectangle
         */
        Rectangle.prototype.clone = function clone() {
          return new Rectangle(this.x, this.y, this.width, this.height);
        };

        /**
         * Copies another rectangle to this one.
         *
         * @param {PIXI.Rectangle} rectangle - The rectangle to copy.
         * @return {PIXI.Rectangle} Returns itself.
         */

        Rectangle.prototype.copy = function copy(rectangle) {
          this.x = rectangle.x;
          this.y = rectangle.y;
          this.width = rectangle.width;
          this.height = rectangle.height;

          return this;
        };

        /**
         * Checks whether the x and y coordinates given are contained within this Rectangle
         *
         * @param {number} x - The X coordinate of the point to test
         * @param {number} y - The Y coordinate of the point to test
         * @return {boolean} Whether the x/y coordinates are within this Rectangle
         */

        Rectangle.prototype.contains = function contains(x, y) {
          if (this.width <= 0 || this.height <= 0) {
            return false;
          }

          if (x >= this.x && x < this.x + this.width) {
            if (y >= this.y && y < this.y + this.height) {
              return true;
            }
          }

          return false;
        };

        /**
         * Pads the rectangle making it grow in all directions.
         *
         * @param {number} paddingX - The horizontal padding amount.
         * @param {number} [paddingY] - The vertical padding amount.
         */

        Rectangle.prototype.pad = function pad(paddingX, paddingY) {
          paddingX = paddingX || 0;
          paddingY = paddingY || (paddingY !== 0 ? paddingX : 0);

          this.x -= paddingX;
          this.y -= paddingY;

          this.width += paddingX * 2;
          this.height += paddingY * 2;
        };

        /**
         * Fits this rectangle around the passed one.
         *
         * @param {PIXI.Rectangle} rectangle - The rectangle to fit.
         */

        Rectangle.prototype.fit = function fit(rectangle) {
          let x1 = Math.max(this.x, rectangle.x);
          let x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
          let y1 = Math.max(this.y, rectangle.y);
          let y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);

          this.x = x1;
          this.width = Math.max(x2 - x1, 0);
          this.y = y1;
          this.height = Math.max(y2 - y1, 0);
        };

        /**
         * Enlarges this rectangle to include the passed rectangle.
         *
         * @param {PIXI.Rectangle} rectangle - The rectangle to include.
         */

        Rectangle.prototype.enlarge = function enlarge(rectangle) {
          let x1 = Math.min(this.x, rectangle.x);
          let x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
          let y1 = Math.min(this.y, rectangle.y);
          let y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);

          this.x = x1;
          this.width = x2 - x1;
          this.y = y1;
          this.height = y2 - y1;
        };

        /**
         * Enlarges rectangle that way its corners lie on grid
         *
         * @param {number} [resolution=1] resolution
         * @param {number} [eps=0.001] precision
         */

        Rectangle.prototype.ceil = function ceil() {
          let resolution = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
          let eps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.001;

          let x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
          let y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;

          this.x = Math.floor((this.x + eps) * resolution) / resolution;
          this.y = Math.floor((this.y + eps) * resolution) / resolution;

          this.width = x2 - this.x;
          this.height = y2 - this.y;
        };

        _createClass(
          Rectangle,
          [
            {
              key: "left",
              get: function get() {
                return this.x;
              },

              /**
               * returns the right edge of the rectangle
               *
               * @member {number}
               */
            },
            {
              key: "right",
              get: function get() {
                return this.x + this.width;
              },

              /**
               * returns the top edge of the rectangle
               *
               * @member {number}
               */
            },
            {
              key: "top",
              get: function get() {
                return this.y;
              },

              /**
               * returns the bottom edge of the rectangle
               *
               * @member {number}
               */
            },
            {
              key: "bottom",
              get: function get() {
                return this.y + this.height;
              },

              /**
               * A constant empty rectangle.
               *
               * @static
               * @constant
               */
            },
          ],
          [
            {
              key: "EMPTY",
              get: function get() {
                return new Rectangle(0, 0, 0, 0);
              },
            },
          ]
        );

        return Rectangle;
      })();

      exports.default = Rectangle;
      //# sourceMappingURL=Rectangle.js.map

      /***/
    },
    /* 376 */
    /***/ function (module, exports) {
      let mapType = function (gl, type) {
        if (!GL_TABLE) {
          let typeNames = Object.keys(GL_TO_GLSL_TYPES);

          GL_TABLE = {};

          for (let i = 0; i < typeNames.length; ++i) {
            let tn = typeNames[i];
            GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
          }
        }

        return GL_TABLE[type];
      };

      var GL_TABLE = null;

      var GL_TO_GLSL_TYPES = {
        FLOAT: "float",
        FLOAT_VEC2: "vec2",
        FLOAT_VEC3: "vec3",
        FLOAT_VEC4: "vec4",

        INT: "int",
        INT_VEC2: "ivec2",
        INT_VEC3: "ivec3",
        INT_VEC4: "ivec4",

        BOOL: "bool",
        BOOL_VEC2: "bvec2",
        BOOL_VEC3: "bvec3",
        BOOL_VEC4: "bvec4",

        FLOAT_MAT2: "mat2",
        FLOAT_MAT3: "mat3",
        FLOAT_MAT4: "mat4",

        SAMPLER_2D: "sampler2D",
      };

      module.exports = mapType;

      /***/
    },
    /* 377 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      let _math = __webpack_require__(348);

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      /**
       * 'Builder' pattern for bounds rectangles
       * Axis-Aligned Bounding Box
       * It is not a shape! Its mutable thing, no 'EMPTY' or that kind of problems
       *
       * @class
       * @memberof PIXI
       */
      let Bounds = (function () {
        /**
         *
         */
        function Bounds() {
          _classCallCheck(this, Bounds);

          /**
           * @member {number}
           * @default 0
           */
          this.minX = Infinity;

          /**
           * @member {number}
           * @default 0
           */
          this.minY = Infinity;

          /**
           * @member {number}
           * @default 0
           */
          this.maxX = -Infinity;

          /**
           * @member {number}
           * @default 0
           */
          this.maxY = -Infinity;

          this.rect = null;
        }

        /**
         * Checks if bounds are empty.
         *
         * @return {boolean} True if empty.
         */

        Bounds.prototype.isEmpty = function isEmpty() {
          return this.minX > this.maxX || this.minY > this.maxY;
        };

        /**
         * Clears the bounds and resets.
         *
         */

        Bounds.prototype.clear = function clear() {
          this.updateID++;

          this.minX = Infinity;
          this.minY = Infinity;
          this.maxX = -Infinity;
          this.maxY = -Infinity;
        };

        /**
         * Can return Rectangle.EMPTY constant, either construct new rectangle, either use your rectangle
         * It is not guaranteed that it will return tempRect
         *
         * @param {PIXI.Rectangle} rect - temporary object will be used if AABB is not empty
         * @returns {PIXI.Rectangle} A rectangle of the bounds
         */

        Bounds.prototype.getRectangle = function getRectangle(rect) {
          if (this.minX > this.maxX || this.minY > this.maxY) {
            return _math.Rectangle.EMPTY;
          }

          rect = rect || new _math.Rectangle(0, 0, 1, 1);

          rect.x = this.minX;
          rect.y = this.minY;
          rect.width = this.maxX - this.minX;
          rect.height = this.maxY - this.minY;

          return rect;
        };

        /**
         * This function should be inlined when its possible.
         *
         * @param {PIXI.Point} point - The point to add.
         */

        Bounds.prototype.addPoint = function addPoint(point) {
          this.minX = Math.min(this.minX, point.x);
          this.maxX = Math.max(this.maxX, point.x);
          this.minY = Math.min(this.minY, point.y);
          this.maxY = Math.max(this.maxY, point.y);
        };

        /**
         * Adds a quad, not transformed
         *
         * @param {Float32Array} vertices - The verts to add.
         */

        Bounds.prototype.addQuad = function addQuad(vertices) {
          let minX = this.minX;
          let minY = this.minY;
          let maxX = this.maxX;
          let maxY = this.maxY;

          let x = vertices[0];
          let y = vertices[1];

          minX = x < minX ? x : minX;
          minY = y < minY ? y : minY;
          maxX = x > maxX ? x : maxX;
          maxY = y > maxY ? y : maxY;

          x = vertices[2];
          y = vertices[3];
          minX = x < minX ? x : minX;
          minY = y < minY ? y : minY;
          maxX = x > maxX ? x : maxX;
          maxY = y > maxY ? y : maxY;

          x = vertices[4];
          y = vertices[5];
          minX = x < minX ? x : minX;
          minY = y < minY ? y : minY;
          maxX = x > maxX ? x : maxX;
          maxY = y > maxY ? y : maxY;

          x = vertices[6];
          y = vertices[7];
          minX = x < minX ? x : minX;
          minY = y < minY ? y : minY;
          maxX = x > maxX ? x : maxX;
          maxY = y > maxY ? y : maxY;

          this.minX = minX;
          this.minY = minY;
          this.maxX = maxX;
          this.maxY = maxY;
        };

        /**
         * Adds sprite frame, transformed.
         *
         * @param {PIXI.TransformBase} transform - TODO
         * @param {number} x0 - TODO
         * @param {number} y0 - TODO
         * @param {number} x1 - TODO
         * @param {number} y1 - TODO
         */

        Bounds.prototype.addFrame = function addFrame(transform, x0, y0, x1, y1) {
          let matrix = transform.worldTransform;
          let a = matrix.a;
          let b = matrix.b;
          let c = matrix.c;
          let d = matrix.d;
          let tx = matrix.tx;
          let ty = matrix.ty;

          let minX = this.minX;
          let minY = this.minY;
          let maxX = this.maxX;
          let maxY = this.maxY;

          let x = a * x0 + c * y0 + tx;
          let y = b * x0 + d * y0 + ty;

          minX = x < minX ? x : minX;
          minY = y < minY ? y : minY;
          maxX = x > maxX ? x : maxX;
          maxY = y > maxY ? y : maxY;

          x = a * x1 + c * y0 + tx;
          y = b * x1 + d * y0 + ty;
          minX = x < minX ? x : minX;
          minY = y < minY ? y : minY;
          maxX = x > maxX ? x : maxX;
          maxY = y > maxY ? y : maxY;

          x = a * x0 + c * y1 + tx;
          y = b * x0 + d * y1 + ty;
          minX = x < minX ? x : minX;
          minY = y < minY ? y : minY;
          maxX = x > maxX ? x : maxX;
          maxY = y > maxY ? y : maxY;

          x = a * x1 + c * y1 + tx;
          y = b * x1 + d * y1 + ty;
          minX = x < minX ? x : minX;
          minY = y < minY ? y : minY;
          maxX = x > maxX ? x : maxX;
          maxY = y > maxY ? y : maxY;

          this.minX = minX;
          this.minY = minY;
          this.maxX = maxX;
          this.maxY = maxY;
        };

        /**
         * Add an array of vertices
         *
         * @param {PIXI.TransformBase} transform - TODO
         * @param {Float32Array} vertices - TODO
         * @param {number} beginOffset - TODO
         * @param {number} endOffset - TODO
         */

        Bounds.prototype.addVertices = function addVertices(transform, vertices, beginOffset, endOffset) {
          let matrix = transform.worldTransform;
          let a = matrix.a;
          let b = matrix.b;
          let c = matrix.c;
          let d = matrix.d;
          let tx = matrix.tx;
          let ty = matrix.ty;

          let minX = this.minX;
          let minY = this.minY;
          let maxX = this.maxX;
          let maxY = this.maxY;

          for (let i = beginOffset; i < endOffset; i += 2) {
            let rawX = vertices[i];
            let rawY = vertices[i + 1];
            let x = a * rawX + c * rawY + tx;
            let y = d * rawY + b * rawX + ty;

            minX = x < minX ? x : minX;
            minY = y < minY ? y : minY;
            maxX = x > maxX ? x : maxX;
            maxY = y > maxY ? y : maxY;
          }

          this.minX = minX;
          this.minY = minY;
          this.maxX = maxX;
          this.maxY = maxY;
        };

        /**
         * Adds other Bounds
         *
         * @param {PIXI.Bounds} bounds - TODO
         */

        Bounds.prototype.addBounds = function addBounds(bounds) {
          let minX = this.minX;
          let minY = this.minY;
          let maxX = this.maxX;
          let maxY = this.maxY;

          this.minX = bounds.minX < minX ? bounds.minX : minX;
          this.minY = bounds.minY < minY ? bounds.minY : minY;
          this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;
          this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;
        };

        /**
         * Adds other Bounds, masked with Bounds
         *
         * @param {PIXI.Bounds} bounds - TODO
         * @param {PIXI.Bounds} mask - TODO
         */

        Bounds.prototype.addBoundsMask = function addBoundsMask(bounds, mask) {
          let _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX;
          let _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY;
          let _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;
          let _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;

          if (_minX <= _maxX && _minY <= _maxY) {
            let minX = this.minX;
            let minY = this.minY;
            let maxX = this.maxX;
            let maxY = this.maxY;

            this.minX = _minX < minX ? _minX : minX;
            this.minY = _minY < minY ? _minY : minY;
            this.maxX = _maxX > maxX ? _maxX : maxX;
            this.maxY = _maxY > maxY ? _maxY : maxY;
          }
        };

        /**
         * Adds other Bounds, masked with Rectangle
         *
         * @param {PIXI.Bounds} bounds - TODO
         * @param {PIXI.Rectangle} area - TODO
         */

        Bounds.prototype.addBoundsArea = function addBoundsArea(bounds, area) {
          let _minX = bounds.minX > area.x ? bounds.minX : area.x;
          let _minY = bounds.minY > area.y ? bounds.minY : area.y;
          let _maxX = bounds.maxX < area.x + area.width ? bounds.maxX : area.x + area.width;
          let _maxY = bounds.maxY < area.y + area.height ? bounds.maxY : area.y + area.height;

          if (_minX <= _maxX && _minY <= _maxY) {
            let minX = this.minX;
            let minY = this.minY;
            let maxX = this.maxX;
            let maxY = this.maxY;

            this.minX = _minX < minX ? _minX : minX;
            this.minY = _minY < minY ? _minY : minY;
            this.maxX = _maxX > maxX ? _maxX : maxX;
            this.maxY = _maxY > maxY ? _maxY : maxY;
          }
        };

        return Bounds;
      })();

      exports.default = Bounds;
      //# sourceMappingURL=Bounds.js.map

      /***/
    },
    /* 378 */
    /***/ function (module, exports, __webpack_require__) {
      let __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
      !(function (e) {
        let n = /iPhone/i,
          t = /iPod/i,
          r = /iPad/i,
          a = /\bAndroid(?:.+)Mobile\b/i,
          p = /Android/i,
          b = /\bAndroid(?:.+)SD4930UR\b/i,
          l = /\bAndroid(?:.+)(?:KF[A-Z]{2,4})\b/i,
          f = /Windows Phone/i,
          s = /\bWindows(?:.+)ARM\b/i,
          u = /BlackBerry/i,
          c = /BB10/i,
          h = /Opera Mini/i,
          v = /\b(CriOS|Chrome)(?:.+)Mobile/i,
          w = /Mobile(?:.+)Firefox\b/i;
        function m(e, i) {
          return e.test(i);
        }
        function i(e) {
          let i = e || ("undefined" != typeof navigator ? navigator.userAgent : ""),
            o = i.split("[FBAN");
          void 0 !== o[1] && (i = o[0]), void 0 !== (o = i.split("Twitter"))[1] && (i = o[0]);
          let d = {
            apple: {
              phone: m(n, i) && !m(f, i),
              ipod: m(t, i),
              tablet: !m(n, i) && m(r, i) && !m(f, i),
              device: (m(n, i) || m(t, i) || m(r, i)) && !m(f, i),
            },
            amazon: { phone: m(b, i), tablet: !m(b, i) && m(l, i), device: m(b, i) || m(l, i) },
            android: {
              phone: (!m(f, i) && m(b, i)) || (!m(f, i) && m(a, i)),
              tablet: !m(f, i) && !m(b, i) && !m(a, i) && (m(l, i) || m(p, i)),
              device: (!m(f, i) && (m(b, i) || m(l, i) || m(a, i) || m(p, i))) || m(/\bokhttp\b/i, i),
            },
            windows: { phone: m(f, i), tablet: m(s, i), device: m(f, i) || m(s, i) },
            other: {
              blackberry: m(u, i),
              blackberry10: m(c, i),
              opera: m(h, i),
              firefox: m(w, i),
              chrome: m(v, i),
              device: m(u, i) || m(c, i) || m(h, i) || m(w, i) || m(v, i),
            },
          };
          return (
            (d.any = d.apple.device || d.android.device || d.windows.device || d.other.device),
            (d.phone = d.apple.phone || d.android.phone || d.windows.phone),
            (d.tablet = d.apple.tablet || d.android.tablet || d.windows.tablet),
            d
          );
        }
        true && module.exports && "undefined" == typeof window
          ? (module.exports = i)
          : true && module.exports && "undefined" != typeof window
          ? ((module.exports = i()), (module.exports.isMobile = i))
          : true
          ? !((__WEBPACK_AMD_DEFINE_ARRAY__ = []),
            (__WEBPACK_AMD_DEFINE_FACTORY__ = e.isMobile = i()),
            (__WEBPACK_AMD_DEFINE_RESULT__ =
              typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function"
                ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)
                : __WEBPACK_AMD_DEFINE_FACTORY__),
            __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
          : undefined;
      })(this);

      /***/
    },
    /* 379 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      let _math = __webpack_require__(348);

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      /**
       * Generic class to deal with traditional 2D matrix transforms
       *
       * @class
       * @memberof PIXI
       */
      let TransformBase = (function () {
        /**
         *
         */
        function TransformBase() {
          _classCallCheck(this, TransformBase);

          /**
           * The global matrix transform. It can be swapped temporarily by some functions like getLocalBounds()
           *
           * @member {PIXI.Matrix}
           */
          this.worldTransform = new _math.Matrix();

          /**
           * The local matrix transform
           *
           * @member {PIXI.Matrix}
           */
          this.localTransform = new _math.Matrix();

          this._worldID = 0;
          this._parentID = 0;
        }

        /**
         * TransformBase does not have decomposition, so this function wont do anything
         */

        TransformBase.prototype.updateLocalTransform = function updateLocalTransform() {};
        // empty

        /**
         * Updates the values of the object and applies the parent's transform.
         *
         * @param {PIXI.TransformBase} parentTransform - The transform of the parent of this object
         */

        TransformBase.prototype.updateTransform = function updateTransform(parentTransform) {
          let pt = parentTransform.worldTransform;
          let wt = this.worldTransform;
          let lt = this.localTransform;

          // concat the parent matrix with the objects transform.
          wt.a = lt.a * pt.a + lt.b * pt.c;
          wt.b = lt.a * pt.b + lt.b * pt.d;
          wt.c = lt.c * pt.a + lt.d * pt.c;
          wt.d = lt.c * pt.b + lt.d * pt.d;
          wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
          wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;

          this._worldID++;
        };

        return TransformBase;
      })();

      /**
       * Updates the values of the object and applies the parent's transform.
       * @param  parentTransform {PIXI.Transform} The transform of the parent of this object
       *
       */

      exports.default = TransformBase;
      TransformBase.prototype.updateWorldTransform = TransformBase.prototype.updateTransform;

      TransformBase.IDENTITY = new TransformBase();
      //# sourceMappingURL=TransformBase.js.map

      /***/
    },
    /* 380 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      module.exports = earcut;
      module.exports.default = earcut;

      function earcut(data, holeIndices, dim) {
        dim = dim || 2;

        let hasHoles = holeIndices && holeIndices.length,
          outerLen = hasHoles ? holeIndices[0] * dim : data.length,
          outerNode = linkedList(data, 0, outerLen, dim, true),
          triangles = [];

        if (!outerNode || outerNode.next === outerNode.prev) return triangles;

        let minX, minY, maxX, maxY, x, y, invSize;

        if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

        // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
        if (data.length > 80 * dim) {
          minX = maxX = data[0];
          minY = maxY = data[1];

          for (let i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
          }

          // minX, minY and invSize are later used to transform coords into integers for z-order calculation
          invSize = Math.max(maxX - minX, maxY - minY);
          invSize = invSize !== 0 ? 1 / invSize : 0;
        }

        earcutLinked(outerNode, triangles, dim, minX, minY, invSize);

        return triangles;
      }

      // create a circular doubly linked list from polygon points in the specified winding order
      function linkedList(data, start, end, dim, clockwise) {
        let i, last;

        if (clockwise === signedArea(data, start, end, dim) > 0) {
          for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
        } else {
          for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
        }

        if (last && equals(last, last.next)) {
          removeNode(last);
          last = last.next;
        }

        return last;
      }

      // eliminate colinear or duplicate points
      function filterPoints(start, end) {
        if (!start) return start;
        if (!end) end = start;

        let p = start,
          again;
        do {
          again = false;

          if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;
          } else {
            p = p.next;
          }
        } while (again || p !== end);

        return end;
      }

      // main ear slicing loop which triangulates a polygon (given as a linked list)
      function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
        if (!ear) return;

        // interlink polygon nodes in z-order
        if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

        let stop = ear,
          prev,
          next;

        // iterate through ears, slicing them one by one
        while (ear.prev !== ear.next) {
          prev = ear.prev;
          next = ear.next;

          if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);

            removeNode(ear);

            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
          }

          ear = next;

          // if we looped through the whole remaining polygon and can't find any more ears
          if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
              earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

              // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
              ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
              earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

              // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
              splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }

            break;
          }
        }
      }

      // check whether a polygon node forms a valid ear with adjacent nodes
      function isEar(ear) {
        let a = ear.prev,
          b = ear,
          c = ear.next;

        if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

        // now make sure we don't have other points inside the potential ear
        let p = ear.next.next;

        while (p !== ear.prev) {
          if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
          p = p.next;
        }

        return true;
      }

      function isEarHashed(ear, minX, minY, invSize) {
        let a = ear.prev,
          b = ear,
          c = ear.next;

        if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

        // triangle bbox; min & max are calculated like this for speed
        let minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : b.x < c.x ? b.x : c.x,
          minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : b.y < c.y ? b.y : c.y,
          maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : b.x > c.x ? b.x : c.x,
          maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : b.y > c.y ? b.y : c.y;

        // z-order range for the current triangle bbox;
        let minZ = zOrder(minTX, minTY, minX, minY, invSize),
          maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);

        let p = ear.prevZ,
          n = ear.nextZ;

        // look for points inside the triangle in both directions
        while (p && p.z >= minZ && n && n.z <= maxZ) {
          if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
            return false;
          p = p.prevZ;

          if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
            return false;
          n = n.nextZ;
        }

        // look for remaining points in decreasing z-order
        while (p && p.z >= minZ) {
          if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
            return false;
          p = p.prevZ;
        }

        // look for remaining points in increasing z-order
        while (n && n.z <= maxZ) {
          if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
            return false;
          n = n.nextZ;
        }

        return true;
      }

      // go through all polygon nodes and cure small local self-intersections
      function cureLocalIntersections(start, triangles, dim) {
        let p = start;
        do {
          let a = p.prev,
            b = p.next.next;

          if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
          }
          p = p.next;
        } while (p !== start);

        return filterPoints(p);
      }

      // try splitting polygon into two and triangulate them independently
      function splitEarcut(start, triangles, dim, minX, minY, invSize) {
        // look for a valid diagonal that divides the polygon into two
        let a = start;
        do {
          let b = a.next.next;
          while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
              // split the polygon in two by the diagonal
              let c = splitPolygon(a, b);

              // filter colinear points around the cuts
              a = filterPoints(a, a.next);
              c = filterPoints(c, c.next);

              // run earcut on each half
              earcutLinked(a, triangles, dim, minX, minY, invSize);
              earcutLinked(c, triangles, dim, minX, minY, invSize);
              return;
            }
            b = b.next;
          }
          a = a.next;
        } while (a !== start);
      }

      // link every hole into the outer loop, producing a single-ring polygon without holes
      function eliminateHoles(data, holeIndices, outerNode, dim) {
        let queue = [],
          i,
          len,
          start,
          end,
          list;

        for (i = 0, len = holeIndices.length; i < len; i++) {
          start = holeIndices[i] * dim;
          end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
          list = linkedList(data, start, end, dim, false);
          if (list === list.next) list.steiner = true;
          queue.push(getLeftmost(list));
        }

        queue.sort(compareX);

        // process holes from left to right
        for (i = 0; i < queue.length; i++) {
          eliminateHole(queue[i], outerNode);
          outerNode = filterPoints(outerNode, outerNode.next);
        }

        return outerNode;
      }

      function compareX(a, b) {
        return a.x - b.x;
      }

      // find a bridge between vertices that connects hole with an outer ring and and link it
      function eliminateHole(hole, outerNode) {
        outerNode = findHoleBridge(hole, outerNode);
        if (outerNode) {
          let b = splitPolygon(outerNode, hole);

          // filter collinear points around the cuts
          filterPoints(outerNode, outerNode.next);
          filterPoints(b, b.next);
        }
      }

      // David Eberly's algorithm for finding a bridge between hole and outer polygon
      function findHoleBridge(hole, outerNode) {
        let p = outerNode,
          hx = hole.x,
          hy = hole.y,
          qx = -Infinity,
          m;

        // find a segment intersected by a ray from the hole's leftmost point to the left;
        // segment's endpoint with lesser x will be potential connection point
        do {
          if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            let x = p.x + ((hy - p.y) * (p.next.x - p.x)) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
              qx = x;
              if (x === hx) {
                if (hy === p.y) return p;
                if (hy === p.next.y) return p.next;
              }
              m = p.x < p.next.x ? p : p.next;
            }
          }
          p = p.next;
        } while (p !== outerNode);

        if (!m) return null;

        if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint

        // look for points inside the triangle of hole point, segment intersection and endpoint;
        // if there are no points found, we have a valid connection;
        // otherwise choose the point of the minimum angle with the ray as connection point

        let stop = m,
          mx = m.x,
          my = m.y,
          tanMin = Infinity,
          tan;

        p = m;

        do {
          if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if (locallyInside(p, hole) && (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {
              m = p;
              tanMin = tan;
            }
          }

          p = p.next;
        } while (p !== stop);

        return m;
      }

      // whether sector in vertex m contains sector in vertex p in the same coordinates
      function sectorContainsSector(m, p) {
        return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
      }

      // interlink polygon nodes in z-order
      function indexCurve(start, minX, minY, invSize) {
        let p = start;
        do {
          if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
          p.prevZ = p.prev;
          p.nextZ = p.next;
          p = p.next;
        } while (p !== start);

        p.prevZ.nextZ = null;
        p.prevZ = null;

        sortLinked(p);
      }

      // Simon Tatham's linked list merge sort algorithm
      // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
      function sortLinked(list) {
        let i,
          p,
          q,
          e,
          tail,
          numMerges,
          pSize,
          qSize,
          inSize = 1;

        do {
          p = list;
          list = null;
          tail = null;
          numMerges = 0;

          while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
              pSize++;
              q = q.nextZ;
              if (!q) break;
            }
            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {
              if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                e = p;
                p = p.nextZ;
                pSize--;
              } else {
                e = q;
                q = q.nextZ;
                qSize--;
              }

              if (tail) tail.nextZ = e;
              else list = e;

              e.prevZ = tail;
              tail = e;
            }

            p = q;
          }

          tail.nextZ = null;
          inSize *= 2;
        } while (numMerges > 1);

        return list;
      }

      // z-order of a point given coords and inverse of the longer side of data bbox
      function zOrder(x, y, minX, minY, invSize) {
        // coords are transformed into non-negative 15-bit integer range
        x = 32767 * (x - minX) * invSize;
        y = 32767 * (y - minY) * invSize;

        x = (x | (x << 8)) & 0x00ff00ff;
        x = (x | (x << 4)) & 0x0f0f0f0f;
        x = (x | (x << 2)) & 0x33333333;
        x = (x | (x << 1)) & 0x55555555;

        y = (y | (y << 8)) & 0x00ff00ff;
        y = (y | (y << 4)) & 0x0f0f0f0f;
        y = (y | (y << 2)) & 0x33333333;
        y = (y | (y << 1)) & 0x55555555;

        return x | (y << 1);
      }

      // find the leftmost node of a polygon ring
      function getLeftmost(start) {
        let p = start,
          leftmost = start;
        do {
          if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
          p = p.next;
        } while (p !== start);

        return leftmost;
      }

      // check if a point lies within a convex triangle
      function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (
          (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
          (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
          (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0
        );
      }

      // check if a diagonal between two polygon nodes is valid (lies in polygon interior)
      function isValidDiagonal(a, b) {
        return (
          a.next.i !== b.i &&
          a.prev.i !== b.i &&
          !intersectsPolygon(a, b) && // dones't intersect other edges
          ((locallyInside(a, b) &&
            locallyInside(b, a) &&
            middleInside(a, b) && // locally visible
            (area(a.prev, a, b.prev) || area(a, b.prev, b))) || // does not create opposite-facing sectors
            (equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0))
        ); // special zero-length case
      }

      // signed area of a triangle
      function area(p, q, r) {
        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
      }

      // check if two points are equal
      function equals(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
      }

      // check if two segments intersect
      function intersects(p1, q1, p2, q2) {
        let o1 = sign(area(p1, q1, p2));
        let o2 = sign(area(p1, q1, q2));
        let o3 = sign(area(p2, q2, p1));
        let o4 = sign(area(p2, q2, q1));

        if (o1 !== o2 && o3 !== o4) return true; // general case

        if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
        if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
        if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
        if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

        return false;
      }

      // for collinear points p, q, r, check if point q lies on segment pr
      function onSegment(p, q, r) {
        return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
      }

      function sign(num) {
        return num > 0 ? 1 : num < 0 ? -1 : 0;
      }

      // check if a polygon diagonal intersects any polygon segments
      function intersectsPolygon(a, b) {
        let p = a;
        do {
          if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
          p = p.next;
        } while (p !== a);

        return false;
      }

      // check if a polygon diagonal is locally inside the polygon
      function locallyInside(a, b) {
        return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
      }

      // check if the middle point of a polygon diagonal is inside the polygon
      function middleInside(a, b) {
        let p = a,
          inside = false,
          px = (a.x + b.x) / 2,
          py = (a.y + b.y) / 2;
        do {
          if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < ((p.next.x - p.x) * (py - p.y)) / (p.next.y - p.y) + p.x) inside = !inside;
          p = p.next;
        } while (p !== a);

        return inside;
      }

      // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
      // if one belongs to the outer ring and another to a hole, it merges it into a single ring
      function splitPolygon(a, b) {
        let a2 = new Node(a.i, a.x, a.y),
          b2 = new Node(b.i, b.x, b.y),
          an = a.next,
          bp = b.prev;

        a.next = b;
        b.prev = a;

        a2.next = an;
        an.prev = a2;

        b2.next = a2;
        a2.prev = b2;

        bp.next = b2;
        b2.prev = bp;

        return b2;
      }

      // create a node and optionally link it with previous one (in a circular doubly linked list)
      function insertNode(i, x, y, last) {
        let p = new Node(i, x, y);

        if (!last) {
          p.prev = p;
          p.next = p;
        } else {
          p.next = last.next;
          p.prev = last;
          last.next.prev = p;
          last.next = p;
        }
        return p;
      }

      function removeNode(p) {
        p.next.prev = p.prev;
        p.prev.next = p.next;

        if (p.prevZ) p.prevZ.nextZ = p.nextZ;
        if (p.nextZ) p.nextZ.prevZ = p.prevZ;
      }

      function Node(i, x, y) {
        // vertex index in coordinates array
        this.i = i;

        // vertex coordinates
        this.x = x;
        this.y = y;

        // previous and next vertex nodes in a polygon ring
        this.prev = null;
        this.next = null;

        // z-order curve value
        this.z = null;

        // previous and next nodes in z-order
        this.prevZ = null;
        this.nextZ = null;

        // indicates whether this is a steiner point
        this.steiner = false;
      }

      // return a percentage difference between the polygon area and its triangulation area;
      // used to verify correctness of triangulation
      earcut.deviation = function (data, holeIndices, dim, triangles) {
        let hasHoles = holeIndices && holeIndices.length;
        let outerLen = hasHoles ? holeIndices[0] * dim : data.length;

        let polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
        if (hasHoles) {
          for (var i = 0, len = holeIndices.length; i < len; i++) {
            let start = holeIndices[i] * dim;
            let end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
          }
        }

        let trianglesArea = 0;
        for (i = 0; i < triangles.length; i += 3) {
          let a = triangles[i] * dim;
          let b = triangles[i + 1] * dim;
          let c = triangles[i + 2] * dim;
          trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
        }

        return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
      };

      function signedArea(data, start, end, dim) {
        let sum = 0;
        for (let i = start, j = end - dim; i < end; i += dim) {
          sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
          j = i;
        }
        return sum;
      }

      // turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
      earcut.flatten = function (data) {
        let dim = data[0][0].length,
          result = { vertices: [], holes: [], dimensions: dim },
          holeIndex = 0;

        for (let i = 0; i < data.length; i++) {
          for (let j = 0; j < data[i].length; j++) {
            for (let d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
          }
          if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
          }
        }
        return result;
      };

      /***/
    },
    /* 381 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      let _createClass = (function () {
        function defineProperties(target, props) {
          for (let i = 0; i < props.length; i++) {
            let descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      })();

      let _math = __webpack_require__(348);

      let _utils = __webpack_require__(345);

      let _const = __webpack_require__(343);

      let _Texture = __webpack_require__(353);

      let _Texture2 = _interopRequireDefault(_Texture);

      let _Container2 = __webpack_require__(358);

      let _Container3 = _interopRequireDefault(_Container2);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: { value: subClass, enumerable: false, writable: true, configurable: true },
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass);
      }

      let tempPoint = new _math.Point();

      /**
       * The Sprite object is the base for all textured objects that are rendered to the screen
       *
       * A sprite can be created directly from an image like this:
       *
       * ```js
       * let sprite = new PIXI.Sprite.fromImage('assets/image.png');
       * ```
       *
       * The more efficient way to create sprites is using a {@link PIXI.Spritesheet}:
       *
       * ```js
       * PIXI.loader.add("assets/spritesheet.json").load(setup);
       *
       * function setup() {
       *   let sheet = PIXI.loader.resources["assets/spritesheet.json"].spritesheet;
       *   let sprite = new PIXI.Sprite(sheet.textures["image.png"]);
       *   ...
       * }
       * ```
       *
       * @class
       * @extends PIXI.Container
       * @memberof PIXI
       */

      let Sprite = (function (_Container) {
        _inherits(Sprite, _Container);

        /**
         * @param {PIXI.Texture} texture - The texture for this sprite
         */
        function Sprite(texture) {
          _classCallCheck(this, Sprite);

          /**
           * The anchor sets the origin point of the texture.
           * The default is 0,0 or taken from the {@link PIXI.Texture#defaultAnchor|Texture}
           * passed to the constructor. A value of 0,0 means the texture's origin is the top left.
           * Setting the anchor to 0.5,0.5 means the texture's origin is centered.
           * Setting the anchor to 1,1 would mean the texture's origin point will be the bottom right corner.
           * Note: Updating the {@link PIXI.Texture#defaultAnchor} after a Texture is
           * created does _not_ update the Sprite's anchor values.
           *
           * @member {PIXI.ObservablePoint}
           * @private
           */
          let _this = _possibleConstructorReturn(this, _Container.call(this));

          _this._anchor = new _math.ObservablePoint(
            _this._onAnchorUpdate,
            _this,
            texture ? texture.defaultAnchor.x : 0,
            texture ? texture.defaultAnchor.y : 0
          );

          /**
           * The texture that the sprite is using
           *
           * @private
           * @member {PIXI.Texture}
           */
          _this._texture = null;

          /**
           * The width of the sprite (this is initially set by the texture)
           *
           * @private
           * @member {number}
           */
          _this._width = 0;

          /**
           * The height of the sprite (this is initially set by the texture)
           *
           * @private
           * @member {number}
           */
          _this._height = 0;

          /**
           * The tint applied to the sprite. This is a hex value. A value of 0xFFFFFF will remove any tint effect.
           *
           * @private
           * @member {number}
           * @default 0xFFFFFF
           */
          _this._tint = null;
          _this._tintRGB = null;
          _this.tint = 0xffffff;

          /**
           * The blend mode to be applied to the sprite. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
           *
           * @member {number}
           * @default PIXI.BLEND_MODES.NORMAL
           * @see PIXI.BLEND_MODES
           */
          _this.blendMode = _const.BLEND_MODES.NORMAL;

          /**
           * The shader that will be used to render the sprite. Set to null to remove a current shader.
           *
           * @member {PIXI.Filter|PIXI.Shader}
           */
          _this.shader = null;

          /**
           * An internal cached value of the tint.
           *
           * @private
           * @member {number}
           * @default 0xFFFFFF
           */
          _this.cachedTint = 0xffffff;

          // call texture setter
          _this.texture = texture || _Texture2.default.EMPTY;

          /**
           * this is used to store the vertex data of the sprite (basically a quad)
           *
           * @private
           * @member {Float32Array}
           */
          _this.vertexData = new Float32Array(8);

          /**
           * This is used to calculate the bounds of the object IF it is a trimmed sprite
           *
           * @private
           * @member {Float32Array}
           */
          _this.vertexTrimmedData = null;

          _this._transformID = -1;
          _this._textureID = -1;

          _this._transformTrimmedID = -1;
          _this._textureTrimmedID = -1;

          /**
           * Plugin that is responsible for rendering this element.
           * Allows to customize the rendering process without overriding '_renderWebGL' & '_renderCanvas' methods.
           *
           * @member {string}
           * @default 'sprite'
           */
          _this.pluginName = "sprite";
          return _this;
        }

        /**
         * When the texture is updated, this event will fire to update the scale and frame
         *
         * @private
         */

        Sprite.prototype._onTextureUpdate = function _onTextureUpdate() {
          this._textureID = -1;
          this._textureTrimmedID = -1;
          this.cachedTint = 0xffffff;

          // so if _width is 0 then width was not set..
          if (this._width) {
            this.scale.x = ((0, _utils.sign)(this.scale.x) * this._width) / this._texture.orig.width;
          }

          if (this._height) {
            this.scale.y = ((0, _utils.sign)(this.scale.y) * this._height) / this._texture.orig.height;
          }
        };

        /**
         * Called when the anchor position updates.
         *
         * @private
         */

        Sprite.prototype._onAnchorUpdate = function _onAnchorUpdate() {
          this._transformID = -1;
          this._transformTrimmedID = -1;
        };

        /**
         * calculates worldTransform * vertices, store it in vertexData
         */

        Sprite.prototype.calculateVertices = function calculateVertices() {
          if (this._transformID === this.transform._worldID && this._textureID === this._texture._updateID) {
            return;
          }

          this._transformID = this.transform._worldID;
          this._textureID = this._texture._updateID;

          // set the vertex data

          let texture = this._texture;
          let wt = this.transform.worldTransform;
          let a = wt.a;
          let b = wt.b;
          let c = wt.c;
          let d = wt.d;
          let tx = wt.tx;
          let ty = wt.ty;
          let vertexData = this.vertexData;
          let trim = texture.trim;
          let orig = texture.orig;
          let anchor = this._anchor;

          let w0 = 0;
          let w1 = 0;
          let h0 = 0;
          let h1 = 0;

          if (trim) {
            // if the sprite is trimmed and is not a tilingsprite then we need to add the extra
            // space before transforming the sprite coords.
            w1 = trim.x - anchor._x * orig.width;
            w0 = w1 + trim.width;

            h1 = trim.y - anchor._y * orig.height;
            h0 = h1 + trim.height;
          } else {
            w1 = -anchor._x * orig.width;
            w0 = w1 + orig.width;

            h1 = -anchor._y * orig.height;
            h0 = h1 + orig.height;
          }

          // xy
          vertexData[0] = a * w1 + c * h1 + tx;
          vertexData[1] = d * h1 + b * w1 + ty;

          // xy
          vertexData[2] = a * w0 + c * h1 + tx;
          vertexData[3] = d * h1 + b * w0 + ty;

          // xy
          vertexData[4] = a * w0 + c * h0 + tx;
          vertexData[5] = d * h0 + b * w0 + ty;

          // xy
          vertexData[6] = a * w1 + c * h0 + tx;
          vertexData[7] = d * h0 + b * w1 + ty;
        };

        /**
         * calculates worldTransform * vertices for a non texture with a trim. store it in vertexTrimmedData
         * This is used to ensure that the true width and height of a trimmed texture is respected
         */

        Sprite.prototype.calculateTrimmedVertices = function calculateTrimmedVertices() {
          if (!this.vertexTrimmedData) {
            this.vertexTrimmedData = new Float32Array(8);
          } else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) {
            return;
          }

          this._transformTrimmedID = this.transform._worldID;
          this._textureTrimmedID = this._texture._updateID;

          // lets do some special trim code!
          let texture = this._texture;
          let vertexData = this.vertexTrimmedData;
          let orig = texture.orig;
          let anchor = this._anchor;

          // lets calculate the new untrimmed bounds..
          let wt = this.transform.worldTransform;
          let a = wt.a;
          let b = wt.b;
          let c = wt.c;
          let d = wt.d;
          let tx = wt.tx;
          let ty = wt.ty;

          let w1 = -anchor._x * orig.width;
          let w0 = w1 + orig.width;

          let h1 = -anchor._y * orig.height;
          let h0 = h1 + orig.height;

          // xy
          vertexData[0] = a * w1 + c * h1 + tx;
          vertexData[1] = d * h1 + b * w1 + ty;

          // xy
          vertexData[2] = a * w0 + c * h1 + tx;
          vertexData[3] = d * h1 + b * w0 + ty;

          // xy
          vertexData[4] = a * w0 + c * h0 + tx;
          vertexData[5] = d * h0 + b * w0 + ty;

          // xy
          vertexData[6] = a * w1 + c * h0 + tx;
          vertexData[7] = d * h0 + b * w1 + ty;
        };

        /**
         *
         * Renders the object using the WebGL renderer
         *
         * @private
         * @param {PIXI.WebGLRenderer} renderer - The webgl renderer to use.
         */

        Sprite.prototype._renderWebGL = function _renderWebGL(renderer) {
          this.calculateVertices();

          renderer.setObjectRenderer(renderer.plugins[this.pluginName]);
          renderer.plugins[this.pluginName].render(this);
        };

        /**
         * Renders the object using the Canvas renderer
         *
         * @private
         * @param {PIXI.CanvasRenderer} renderer - The renderer
         */

        Sprite.prototype._renderCanvas = function _renderCanvas(renderer) {
          renderer.plugins[this.pluginName].render(this);
        };

        /**
         * Updates the bounds of the sprite.
         *
         * @private
         */

        Sprite.prototype._calculateBounds = function _calculateBounds() {
          let trim = this._texture.trim;
          let orig = this._texture.orig;

          // First lets check to see if the current texture has a trim..
          if (!trim || (trim.width === orig.width && trim.height === orig.height)) {
            // no trim! lets use the usual calculations..
            this.calculateVertices();
            this._bounds.addQuad(this.vertexData);
          } else {
            // lets calculate a special trimmed bounds...
            this.calculateTrimmedVertices();
            this._bounds.addQuad(this.vertexTrimmedData);
          }
        };

        /**
         * Gets the local bounds of the sprite object.
         *
         * @param {PIXI.Rectangle} rect - The output rectangle.
         * @return {PIXI.Rectangle} The bounds.
         */

        Sprite.prototype.getLocalBounds = function getLocalBounds(rect) {
          // we can do a fast local bounds if the sprite has no children!
          if (this.children.length === 0) {
            this._bounds.minX = this._texture.orig.width * -this._anchor._x;
            this._bounds.minY = this._texture.orig.height * -this._anchor._y;
            this._bounds.maxX = this._texture.orig.width * (1 - this._anchor._x);
            this._bounds.maxY = this._texture.orig.height * (1 - this._anchor._y);

            if (!rect) {
              if (!this._localBoundsRect) {
                this._localBoundsRect = new _math.Rectangle();
              }

              rect = this._localBoundsRect;
            }

            return this._bounds.getRectangle(rect);
          }

          return _Container.prototype.getLocalBounds.call(this, rect);
        };

        /**
         * Tests if a point is inside this sprite
         *
         * @param {PIXI.Point} point - the point to test
         * @return {boolean} the result of the test
         */

        Sprite.prototype.containsPoint = function containsPoint(point) {
          this.worldTransform.applyInverse(point, tempPoint);

          let width = this._texture.orig.width;
          let height = this._texture.orig.height;
          let x1 = -width * this.anchor.x;
          let y1 = 0;

          if (tempPoint.x >= x1 && tempPoint.x < x1 + width) {
            y1 = -height * this.anchor.y;

            if (tempPoint.y >= y1 && tempPoint.y < y1 + height) {
              return true;
            }
          }

          return false;
        };

        /**
         * Destroys this sprite and optionally its texture and children
         *
         * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
         *  have been set to that value
         * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
         *      method called as well. 'options' will be passed on to those calls.
         * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well
         * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well
         */

        Sprite.prototype.destroy = function destroy(options) {
          _Container.prototype.destroy.call(this, options);

          this._texture.off("update", this._onTextureUpdate, this);

          this._anchor = null;

          let destroyTexture = typeof options === "boolean" ? options : options && options.texture;

          if (destroyTexture) {
            let destroyBaseTexture = typeof options === "boolean" ? options : options && options.baseTexture;

            this._texture.destroy(!!destroyBaseTexture);
          }

          this._texture = null;
          this.shader = null;
        };

        // some helper functions..

        /**
         * Helper function that creates a new sprite based on the source you provide.
         * The source can be - frame id, image url, video url, canvas element, video element, base texture
         *
         * @static
         * @param {number|string|PIXI.BaseTexture|HTMLCanvasElement|HTMLVideoElement} source Source to create texture from
         * @return {PIXI.Sprite} The newly created sprite
         */

        Sprite.from = function from(source) {
          return new Sprite(_Texture2.default.from(source));
        };

        /**
         * Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId
         * The frame ids are created when a Texture packer file has been loaded
         *
         * @static
         * @param {string} frameId - The frame Id of the texture in the cache
         * @return {PIXI.Sprite} A new Sprite using a texture from the texture cache matching the frameId
         */

        Sprite.fromFrame = function fromFrame(frameId) {
          let texture = _utils.TextureCache[frameId];

          if (!texture) {
            throw new Error('The frameId "' + frameId + '" does not exist in the texture cache');
          }

          return new Sprite(texture);
        };

        /**
         * Helper function that creates a sprite that will contain a texture based on an image url
         * If the image is not in the texture cache it will be loaded
         *
         * @static
         * @param {string} imageId - The image url of the texture
         * @param {boolean} [crossorigin=(auto)] - if you want to specify the cross-origin parameter
         * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - if you want to specify the scale mode,
         *  see {@link PIXI.SCALE_MODES} for possible values
         * @return {PIXI.Sprite} A new Sprite using a texture from the texture cache matching the image id
         */

        Sprite.fromImage = function fromImage(imageId, crossorigin, scaleMode) {
          return new Sprite(_Texture2.default.fromImage(imageId, crossorigin, scaleMode));
        };

        /**
         * The width of the sprite, setting this will actually modify the scale to achieve the value set
         *
         * @member {number}
         */

        _createClass(Sprite, [
          {
            key: "width",
            get: function get() {
              return Math.abs(this.scale.x) * this._texture.orig.width;
            },
            set: function set(
              value // eslint-disable-line require-jsdoc
            ) {
              let s = (0, _utils.sign)(this.scale.x) || 1;

              this.scale.x = (s * value) / this._texture.orig.width;
              this._width = value;
            },

            /**
             * The height of the sprite, setting this will actually modify the scale to achieve the value set
             *
             * @member {number}
             */
          },
          {
            key: "height",
            get: function get() {
              return Math.abs(this.scale.y) * this._texture.orig.height;
            },
            set: function set(
              value // eslint-disable-line require-jsdoc
            ) {
              let s = (0, _utils.sign)(this.scale.y) || 1;

              this.scale.y = (s * value) / this._texture.orig.height;
              this._height = value;
            },

            /**
             * The anchor sets the origin point of the texture.
             * The default is 0,0 or taken from the {@link PIXI.Texture|Texture} passed to the constructor.
             * Setting the texture at a later point of time does not change the anchor.
             *
             * 0,0 means the texture's origin is the top left, 0.5,0.5 is the center, 1,1 the bottom right corner.
             *
             * @member {PIXI.ObservablePoint}
             */
          },
          {
            key: "anchor",
            get: function get() {
              return this._anchor;
            },
            set: function set(
              value // eslint-disable-line require-jsdoc
            ) {
              this._anchor.copy(value);
            },

            /**
             * The tint applied to the sprite. This is a hex value.
             * A value of 0xFFFFFF will remove any tint effect.
             *
             * @member {number}
             * @default 0xFFFFFF
             */
          },
          {
            key: "tint",
            get: function get() {
              return this._tint;
            },
            set: function set(
              value // eslint-disable-line require-jsdoc
            ) {
              this._tint = value;
              this._tintRGB = (value >> 16) + (value & 0xff00) + ((value & 0xff) << 16);
            },

            /**
             * The texture that the sprite is using
             *
             * @member {PIXI.Texture}
             */
          },
          {
            key: "texture",
            get: function get() {
              return this._texture;
            },
            set: function set(
              value // eslint-disable-line require-jsdoc
            ) {
              if (this._texture === value) {
                return;
              }

              this._texture = value || _Texture2.default.EMPTY;
              this.cachedTint = 0xffffff;

              this._textureID = -1;
              this._textureTrimmedID = -1;

              if (value) {
                // wait for the texture to load
                if (value.baseTexture.hasLoaded) {
                  this._onTextureUpdate();
                } else {
                  value.once("update", this._onTextureUpdate, this);
                }
              }
            },
          },
        ]);

        return Sprite;
      })(_Container3.default);

      exports.default = Sprite;
      //# sourceMappingURL=Sprite.js.map

      /***/
    },
    /* 382 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";
      /**
       * Bit twiddling hacks for JavaScript.
       *
       * Author: Mikola Lysenko
       *
       * Ported from Stanford bit twiddling hack library:
       *    http://graphics.stanford.edu/~seander/bithacks.html
       */

      "use restrict";

      //Number of bits in an integer
      let INT_BITS = 32;

      //Constants
      exports.INT_BITS = INT_BITS;
      exports.INT_MAX = 0x7fffffff;
      exports.INT_MIN = -1 << (INT_BITS - 1);

      //Returns -1, 0, +1 depending on sign of x
      exports.sign = function (v) {
        return (v > 0) - (v < 0);
      };

      //Computes absolute value of integer
      exports.abs = function (v) {
        let mask = v >> (INT_BITS - 1);
        return (v ^ mask) - mask;
      };

      //Computes minimum of integers x and y
      exports.min = function (x, y) {
        return y ^ ((x ^ y) & -(x < y));
      };

      //Computes maximum of integers x and y
      exports.max = function (x, y) {
        return x ^ ((x ^ y) & -(x < y));
      };

      //Checks if a number is a power of two
      exports.isPow2 = function (v) {
        return !(v & (v - 1)) && !!v;
      };

      //Computes log base 2 of v
      exports.log2 = function (v) {
        let r, shift;
        r = (v > 0xffff) << 4;
        v >>>= r;
        shift = (v > 0xff) << 3;
        v >>>= shift;
        r |= shift;
        shift = (v > 0xf) << 2;
        v >>>= shift;
        r |= shift;
        shift = (v > 0x3) << 1;
        v >>>= shift;
        r |= shift;
        return r | (v >> 1);
      };

      //Computes log base 10 of v
      exports.log10 = function (v) {
        return v >= 1000000000
          ? 9
          : v >= 100000000
          ? 8
          : v >= 10000000
          ? 7
          : v >= 1000000
          ? 6
          : v >= 100000
          ? 5
          : v >= 10000
          ? 4
          : v >= 1000
          ? 3
          : v >= 100
          ? 2
          : v >= 10
          ? 1
          : 0;
      };

      //Counts number of bits
      exports.popCount = function (v) {
        v = v - ((v >>> 1) & 0x55555555);
        v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);
        return (((v + (v >>> 4)) & 0xf0f0f0f) * 0x1010101) >>> 24;
      };

      //Counts number of trailing zeros
      function countTrailingZeros(v) {
        let c = 32;
        v &= -v;
        if (v) c--;
        if (v & 0x0000ffff) c -= 16;
        if (v & 0x00ff00ff) c -= 8;
        if (v & 0x0f0f0f0f) c -= 4;
        if (v & 0x33333333) c -= 2;
        if (v & 0x55555555) c -= 1;
        return c;
      }
      exports.countTrailingZeros = countTrailingZeros;

      //Rounds to next power of 2
      exports.nextPow2 = function (v) {
        v += v === 0;
        --v;
        v |= v >>> 1;
        v |= v >>> 2;
        v |= v >>> 4;
        v |= v >>> 8;
        v |= v >>> 16;
        return v + 1;
      };

      //Rounds down to previous power of 2
      exports.prevPow2 = function (v) {
        v |= v >>> 1;
        v |= v >>> 2;
        v |= v >>> 4;
        v |= v >>> 8;
        v |= v >>> 16;
        return v - (v >>> 1);
      };

      //Computes parity of word
      exports.parity = function (v) {
        v ^= v >>> 16;
        v ^= v >>> 8;
        v ^= v >>> 4;
        v &= 0xf;
        return (0x6996 >>> v) & 1;
      };

      let REVERSE_TABLE = new Array(256);

      (function (tab) {
        for (let i = 0; i < 256; ++i) {
          let v = i,
            r = i,
            s = 7;
          for (v >>>= 1; v; v >>>= 1) {
            r <<= 1;
            r |= v & 1;
            --s;
          }
          tab[i] = (r << s) & 0xff;
        }
      })(REVERSE_TABLE);

      //Reverse bits in a 32 bit word
      exports.reverse = function (v) {
        return (
          (REVERSE_TABLE[v & 0xff] << 24) |
          (REVERSE_TABLE[(v >>> 8) & 0xff] << 16) |
          (REVERSE_TABLE[(v >>> 16) & 0xff] << 8) |
          REVERSE_TABLE[(v >>> 24) & 0xff]
        );
      };

      //Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
      exports.interleave2 = function (x, y) {
        x &= 0xffff;
        x = (x | (x << 8)) & 0x00ff00ff;
        x = (x | (x << 4)) & 0x0f0f0f0f;
        x = (x | (x << 2)) & 0x33333333;
        x = (x | (x << 1)) & 0x55555555;

        y &= 0xffff;
        y = (y | (y << 8)) & 0x00ff00ff;
        y = (y | (y << 4)) & 0x0f0f0f0f;
        y = (y | (y << 2)) & 0x33333333;
        y = (y | (y << 1)) & 0x55555555;

        return x | (y << 1);
      };

      //Extracts the nth interleaved component
      exports.deinterleave2 = function (v, n) {
        v = (v >>> n) & 0x55555555;
        v = (v | (v >>> 1)) & 0x33333333;
        v = (v | (v >>> 2)) & 0x0f0f0f0f;
        v = (v | (v >>> 4)) & 0x00ff00ff;
        v = (v | (v >>> 16)) & 0x000ffff;
        return (v << 16) >> 16;
      };

      //Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
      exports.interleave3 = function (x, y, z) {
        x &= 0x3ff;
        x = (x | (x << 16)) & 4278190335;
        x = (x | (x << 8)) & 251719695;
        x = (x | (x << 4)) & 3272356035;
        x = (x | (x << 2)) & 1227133513;

        y &= 0x3ff;
        y = (y | (y << 16)) & 4278190335;
        y = (y | (y << 8)) & 251719695;
        y = (y | (y << 4)) & 3272356035;
        y = (y | (y << 2)) & 1227133513;
        x |= y << 1;

        z &= 0x3ff;
        z = (z | (z << 16)) & 4278190335;
        z = (z | (z << 8)) & 251719695;
        z = (z | (z << 4)) & 3272356035;
        z = (z | (z << 2)) & 1227133513;

        return x | (z << 2);
      };

      //Extracts nth interleaved component of a 3-tuple
      exports.deinterleave3 = function (v, n) {
        v = (v >>> n) & 1227133513;
        v = (v | (v >>> 2)) & 3272356035;
        v = (v | (v >>> 4)) & 251719695;
        v = (v | (v >>> 8)) & 4278190335;
        v = (v | (v >>> 16)) & 0x3ff;
        return (v << 22) >> 22;
      };

      //Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
      exports.nextCombination = function (v) {
        let t = v | (v - 1);
        return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1));
      };

      /***/
    },
    /* 383 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;
      exports.Ticker = exports.shared = undefined;

      let _Ticker = __webpack_require__(498);

      let _Ticker2 = _interopRequireDefault(_Ticker);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      /**
       * The shared ticker instance used by {@link PIXI.extras.AnimatedSprite}.
       * and by {@link PIXI.interaction.InteractionManager}.
       * The property {@link PIXI.ticker.Ticker#autoStart} is set to `true`
       * for this instance. Please follow the examples for usage, including
       * how to opt-out of auto-starting the shared ticker.
       *
       * @example
       * let ticker = PIXI.ticker.shared;
       * // Set this to prevent starting this ticker when listeners are added.
       * // By default this is true only for the PIXI.ticker.shared instance.
       * ticker.autoStart = false;
       * // FYI, call this to ensure the ticker is stopped. It should be stopped
       * // if you have not attempted to render anything yet.
       * ticker.stop();
       * // Call this when you are ready for a running shared ticker.
       * ticker.start();
       *
       * @example
       * // You may use the shared ticker to render...
       * let renderer = PIXI.autoDetectRenderer(800, 600);
       * let stage = new PIXI.Container();
       * let interactionManager = PIXI.interaction.InteractionManager(renderer);
       * document.body.appendChild(renderer.view);
       * ticker.add(function (time) {
       *     renderer.render(stage);
       * });
       *
       * @example
       * // Or you can just update it manually.
       * ticker.autoStart = false;
       * ticker.stop();
       * function animate(time) {
       *     ticker.update(time);
       *     renderer.render(stage);
       *     requestAnimationFrame(animate);
       * }
       * animate(performance.now());
       *
       * @type {PIXI.ticker.Ticker}
       * @memberof PIXI.ticker
       */
      let shared = new _Ticker2.default();

      shared.autoStart = true;
      shared.destroy = function () {
        // protect destroying shared ticker
        // this is used by other internal systems
        // like AnimatedSprite and InteractionManager
      };

      /**
       * This namespace contains an API for interacting with PIXI's internal global update loop.
       *
       * This ticker is used for rendering, {@link PIXI.extras.AnimatedSprite AnimatedSprite},
       * {@link PIXI.interaction.InteractionManager InteractionManager} and many other time-based PIXI systems.
       * @example
       * const ticker = new PIXI.ticker.Ticker();
       * ticker.stop();
       * ticker.add((deltaTime) => {
       *   // do something every frame
       * });
       * ticker.start();
       * @namespace PIXI.ticker
       */
      exports.shared = shared;
      exports.Ticker = _Ticker2.default;
      //# sourceMappingURL=index.js.map

      /***/
    },
    /* 384 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      let _BaseRenderTexture = __webpack_require__(412);

      let _BaseRenderTexture2 = _interopRequireDefault(_BaseRenderTexture);

      let _Texture2 = __webpack_require__(353);

      let _Texture3 = _interopRequireDefault(_Texture2);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: { value: subClass, enumerable: false, writable: true, configurable: true },
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass);
      }

      /**
       * A RenderTexture is a special texture that allows any PixiJS display object to be rendered to it.
       *
       * __Hint__: All DisplayObjects (i.e. Sprites) that render to a RenderTexture should be preloaded
       * otherwise black rectangles will be drawn instead.
       *
       * A RenderTexture takes a snapshot of any Display Object given to its render method. For example:
       *
       * ```js
       * let renderer = PIXI.autoDetectRenderer(1024, 1024);
       * let renderTexture = PIXI.RenderTexture.create(800, 600);
       * let sprite = PIXI.Sprite.fromImage("spinObj_01.png");
       *
       * sprite.position.x = 800/2;
       * sprite.position.y = 600/2;
       * sprite.anchor.x = 0.5;
       * sprite.anchor.y = 0.5;
       *
       * renderer.render(sprite, renderTexture);
       * ```
       *
       * The Sprite in this case will be rendered using its local transform. To render this sprite at 0,0
       * you can clear the transform
       *
       * ```js
       *
       * sprite.setTransform()
       *
       * let renderTexture = new PIXI.RenderTexture.create(100, 100);
       *
       * renderer.render(sprite, renderTexture);  // Renders to center of RenderTexture
       * ```
       *
       * @class
       * @extends PIXI.Texture
       * @memberof PIXI
       */
      let RenderTexture = (function (_Texture) {
        _inherits(RenderTexture, _Texture);

        /**
         * @param {PIXI.BaseRenderTexture} baseRenderTexture - The renderer used for this RenderTexture
         * @param {PIXI.Rectangle} [frame] - The rectangle frame of the texture to show
         */
        function RenderTexture(baseRenderTexture, frame) {
          _classCallCheck(this, RenderTexture);

          // support for legacy..
          let _legacyRenderer = null;

          if (!(baseRenderTexture instanceof _BaseRenderTexture2.default)) {
            /* eslint-disable prefer-rest-params, no-console */
            let width = arguments[1];
            let height = arguments[2];
            let scaleMode = arguments[3];
            let resolution = arguments[4];

            // we have an old render texture..
            console.warn("Please use RenderTexture.create(" + width + ", " + height + ") instead of the ctor directly.");
            _legacyRenderer = arguments[0];
            /* eslint-enable prefer-rest-params, no-console */

            frame = null;
            baseRenderTexture = new _BaseRenderTexture2.default(width, height, scaleMode, resolution);
          }

          /**
           * The base texture object that this texture uses
           *
           * @member {BaseTexture}
           */

          let _this = _possibleConstructorReturn(this, _Texture.call(this, baseRenderTexture, frame));

          _this.legacyRenderer = _legacyRenderer;

          /**
           * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.
           *
           * @member {boolean}
           */
          _this.valid = true;

          _this._updateUvs();
          return _this;
        }

        /**
         * Resizes the RenderTexture.
         *
         * @param {number} width - The width to resize to.
         * @param {number} height - The height to resize to.
         * @param {boolean} doNotResizeBaseTexture - Should the baseTexture.width and height values be resized as well?
         */

        RenderTexture.prototype.resize = function resize(width, height, doNotResizeBaseTexture) {
          width = Math.ceil(width);
          height = Math.ceil(height);

          // TODO - could be not required..
          this.valid = width > 0 && height > 0;

          this._frame.width = this.orig.width = width;
          this._frame.height = this.orig.height = height;

          if (!doNotResizeBaseTexture) {
            this.baseTexture.resize(width, height);
          }

          this._updateUvs();
        };

        /**
         * A short hand way of creating a render texture.
         *
         * @param {number} [width=100] - The width of the render texture
         * @param {number} [height=100] - The height of the render texture
         * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
         * @param {number} [resolution=1] - The resolution / device pixel ratio of the texture being generated
         * @return {PIXI.RenderTexture} The new render texture
         */

        RenderTexture.create = function create(width, height, scaleMode, resolution) {
          return new RenderTexture(new _BaseRenderTexture2.default(width, height, scaleMode, resolution));
        };

        return RenderTexture;
      })(_Texture3.default);

      exports.default = RenderTexture;
      //# sourceMappingURL=RenderTexture.js.map

      /***/
    },
    /* 385 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;
      exports.default = createIndicesForQuads;
      /**
       * Generic Mask Stack data structure
       *
       * @memberof PIXI
       * @function createIndicesForQuads
       * @private
       * @param {number} size - Number of quads
       * @return {Uint16Array} indices
       */
      function createIndicesForQuads(size) {
        // the total number of indices in our array, there are 6 points per quad.

        let totalIndices = size * 6;

        let indices = new Uint16Array(totalIndices);

        // fill the indices with the quads to draw
        for (let i = 0, j = 0; i < totalIndices; i += 6, j += 4) {
          indices[i + 0] = j + 0;
          indices[i + 1] = j + 1;
          indices[i + 2] = j + 2;
          indices[i + 3] = j + 0;
          indices[i + 4] = j + 2;
          indices[i + 5] = j + 3;
        }

        return indices;
      }
      //# sourceMappingURL=createIndicesForQuads.js.map

      /***/
    },
    /* 386 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;
      exports.Resource = undefined;

      let _createClass = (function () {
        function defineProperties(target, props) {
          for (let i = 0; i < props.length; i++) {
            let descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      })();

      let _parseUri = __webpack_require__(437);

      let _parseUri2 = _interopRequireDefault(_parseUri);

      let _miniSignals = __webpack_require__(436);

      let _miniSignals2 = _interopRequireDefault(_miniSignals);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      // tests if CORS is supported in XHR, if not we need to use XDR
      let useXdr = !!(window.XDomainRequest && !("withCredentials" in new XMLHttpRequest()));
      let tempAnchor = null;

      // some status constants
      let STATUS_NONE = 0;
      let STATUS_OK = 200;
      let STATUS_EMPTY = 204;
      let STATUS_IE_BUG_EMPTY = 1223;
      let STATUS_TYPE_OK = 2;

      // noop
      function _noop() {} /* empty */

      /**
       * Manages the state and loading of a resource and all child resources.
       *
       * @class
       */

      let Resource = (exports.Resource = (function () {
        /**
         * Sets the load type to be used for a specific extension.
         *
         * @static
         * @param {string} extname - The extension to set the type for, e.g. "png" or "fnt"
         * @param {Resource.LOAD_TYPE} loadType - The load type to set it to.
         */
        Resource.setExtensionLoadType = function setExtensionLoadType(extname, loadType) {
          setExtMap(Resource._loadTypeMap, extname, loadType);
        };

        /**
         * Sets the load type to be used for a specific extension.
         *
         * @static
         * @param {string} extname - The extension to set the type for, e.g. "png" or "fnt"
         * @param {Resource.XHR_RESPONSE_TYPE} xhrType - The xhr type to set it to.
         */

        Resource.setExtensionXhrType = function setExtensionXhrType(extname, xhrType) {
          setExtMap(Resource._xhrTypeMap, extname, xhrType);
        };

        /**
         * @param {string} name - The name of the resource to load.
         * @param {string|string[]} url - The url for this resource, for audio/video loads you can pass
         *      an array of sources.
         * @param {object} [options] - The options for the load.
         * @param {string|boolean} [options.crossOrigin] - Is this request cross-origin? Default is to
         *      determine automatically.
         * @param {number} [options.timeout=0] - A timeout in milliseconds for the load. If the load takes
         *      longer than this time it is cancelled and the load is considered a failure. If this value is
         *      set to `0` then there is no explicit timeout.
         * @param {Resource.LOAD_TYPE} [options.loadType=Resource.LOAD_TYPE.XHR] - How should this resource
         *      be loaded?
         * @param {Resource.XHR_RESPONSE_TYPE} [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] - How
         *      should the data being loaded be interpreted when using XHR?
         * @param {Resource.IMetadata} [options.metadata] - Extra configuration for middleware and the Resource object.
         */

        function Resource(name, url, options) {
          _classCallCheck(this, Resource);

          if (typeof name !== "string" || typeof url !== "string") {
            throw new Error("Both name and url are required for constructing a resource.");
          }

          options = options || {};

          /**
           * The state flags of this resource.
           *
           * @private
           * @member {number}
           */
          this._flags = 0;

          // set data url flag, needs to be set early for some _determineX checks to work.
          this._setFlag(Resource.STATUS_FLAGS.DATA_URL, url.indexOf("data:") === 0);

          /**
           * The name of this resource.
           *
           * @readonly
           * @member {string}
           */
          this.name = name;

          /**
           * The url used to load this resource.
           *
           * @readonly
           * @member {string}
           */
          this.url = url;

          /**
           * The extension used to load this resource.
           *
           * @readonly
           * @member {string}
           */
          this.extension = this._getExtension();

          /**
           * The data that was loaded by the resource.
           *
           * @member {any}
           */
          this.data = null;

          /**
           * Is this request cross-origin? If unset, determined automatically.
           *
           * @member {string}
           */
          this.crossOrigin = options.crossOrigin === true ? "anonymous" : options.crossOrigin;

          /**
           * A timeout in milliseconds for the load. If the load takes longer than this time
           * it is cancelled and the load is considered a failure. If this value is set to `0`
           * then there is no explicit timeout.
           *
           * @member {number}
           */
          this.timeout = options.timeout || 0;

          /**
           * The method of loading to use for this resource.
           *
           * @member {Resource.LOAD_TYPE}
           */
          this.loadType = options.loadType || this._determineLoadType();

          /**
           * The type used to load the resource via XHR. If unset, determined automatically.
           *
           * @member {string}
           */
          this.xhrType = options.xhrType;

          /**
           * Extra info for middleware, and controlling specifics about how the resource loads.
           *
           * Note that if you pass in a `loadElement`, the Resource class takes ownership of it.
           * Meaning it will modify it as it sees fit.
           *
           * @member {Resource.IMetadata}
           */
          this.metadata = options.metadata || {};

          /**
           * The error that occurred while loading (if any).
           *
           * @readonly
           * @member {Error}
           */
          this.error = null;

          /**
           * The XHR object that was used to load this resource. This is only set
           * when `loadType` is `Resource.LOAD_TYPE.XHR`.
           *
           * @readonly
           * @member {XMLHttpRequest}
           */
          this.xhr = null;

          /**
           * The child resources this resource owns.
           *
           * @readonly
           * @member {Resource[]}
           */
          this.children = [];

          /**
           * The resource type.
           *
           * @readonly
           * @member {Resource.TYPE}
           */
          this.type = Resource.TYPE.UNKNOWN;

          /**
           * The progress chunk owned by this resource.
           *
           * @readonly
           * @member {number}
           */
          this.progressChunk = 0;

          /**
           * The `dequeue` method that will be used a storage place for the async queue dequeue method
           * used privately by the loader.
           *
           * @private
           * @member {function}
           */
          this._dequeue = _noop;

          /**
           * Used a storage place for the on load binding used privately by the loader.
           *
           * @private
           * @member {function}
           */
          this._onLoadBinding = null;

          /**
           * The timer for element loads to check if they timeout.
           *
           * @private
           * @member {number}
           */
          this._elementTimer = 0;

          /**
           * The `complete` function bound to this resource's context.
           *
           * @private
           * @member {function}
           */
          this._boundComplete = this.complete.bind(this);

          /**
           * The `_onError` function bound to this resource's context.
           *
           * @private
           * @member {function}
           */
          this._boundOnError = this._onError.bind(this);

          /**
           * The `_onProgress` function bound to this resource's context.
           *
           * @private
           * @member {function}
           */
          this._boundOnProgress = this._onProgress.bind(this);

          /**
           * The `_onTimeout` function bound to this resource's context.
           *
           * @private
           * @member {function}
           */
          this._boundOnTimeout = this._onTimeout.bind(this);

          // xhr callbacks
          this._boundXhrOnError = this._xhrOnError.bind(this);
          this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this);
          this._boundXhrOnAbort = this._xhrOnAbort.bind(this);
          this._boundXhrOnLoad = this._xhrOnLoad.bind(this);

          /**
           * Dispatched when the resource beings to load.
           *
           * The callback looks like {@link Resource.OnStartSignal}.
           *
           * @member {Signal<Resource.OnStartSignal>}
           */
          this.onStart = new _miniSignals2.default();

          /**
           * Dispatched each time progress of this resource load updates.
           * Not all resources types and loader systems can support this event
           * so sometimes it may not be available. If the resource
           * is being loaded on a modern browser, using XHR, and the remote server
           * properly sets Content-Length headers, then this will be available.
           *
           * The callback looks like {@link Resource.OnProgressSignal}.
           *
           * @member {Signal<Resource.OnProgressSignal>}
           */
          this.onProgress = new _miniSignals2.default();

          /**
           * Dispatched once this resource has loaded, if there was an error it will
           * be in the `error` property.
           *
           * The callback looks like {@link Resource.OnCompleteSignal}.
           *
           * @member {Signal<Resource.OnCompleteSignal>}
           */
          this.onComplete = new _miniSignals2.default();

          /**
           * Dispatched after this resource has had all the *after* middleware run on it.
           *
           * The callback looks like {@link Resource.OnCompleteSignal}.
           *
           * @member {Signal<Resource.OnCompleteSignal>}
           */
          this.onAfterMiddleware = new _miniSignals2.default();
        }

        /**
         * When the resource starts to load.
         *
         * @memberof Resource
         * @callback OnStartSignal
         * @param {Resource} resource - The resource that the event happened on.
         */

        /**
         * When the resource reports loading progress.
         *
         * @memberof Resource
         * @callback OnProgressSignal
         * @param {Resource} resource - The resource that the event happened on.
         * @param {number} percentage - The progress of the load in the range [0, 1].
         */

        /**
         * When the resource finishes loading.
         *
         * @memberof Resource
         * @callback OnCompleteSignal
         * @param {Resource} resource - The resource that the event happened on.
         */

        /**
         * @memberof Resource
         * @typedef {object} IMetadata
         * @property {HTMLImageElement|HTMLAudioElement|HTMLVideoElement} [loadElement=null] - The
         *      element to use for loading, instead of creating one.
         * @property {boolean} [skipSource=false] - Skips adding source(s) to the load element. This
         *      is useful if you want to pass in a `loadElement` that you already added load sources to.
         * @property {string|string[]} [mimeType] - The mime type to use for the source element
         *      of a video/audio elment. If the urls are an array, you can pass this as an array as well
         *      where each index is the mime type to use for the corresponding url index.
         */

        /**
         * Stores whether or not this url is a data url.
         *
         * @readonly
         * @member {boolean}
         */

        /**
         * Marks the resource as complete.
         *
         */
        Resource.prototype.complete = function complete() {
          this._clearEvents();
          this._finish();
        };

        /**
         * Aborts the loading of this resource, with an optional message.
         *
         * @param {string} message - The message to use for the error
         */

        Resource.prototype.abort = function abort(message) {
          // abort can be called multiple times, ignore subsequent calls.
          if (this.error) {
            return;
          }

          // store error
          this.error = new Error(message);

          // clear events before calling aborts
          this._clearEvents();

          // abort the actual loading
          if (this.xhr) {
            this.xhr.abort();
          } else if (this.xdr) {
            this.xdr.abort();
          } else if (this.data) {
            // single source
            if (this.data.src) {
              this.data.src = Resource.EMPTY_GIF;
            }
            // multi-source
            else {
              while (this.data.firstChild) {
                this.data.removeChild(this.data.firstChild);
              }
            }
          }

          // done now.
          this._finish();
        };

        /**
         * Kicks off loading of this resource. This method is asynchronous.
         *
         * @param {Resource.OnCompleteSignal} [cb] - Optional callback to call once the resource is loaded.
         */

        Resource.prototype.load = function load(cb) {
          let _this = this;

          if (this.isLoading) {
            return;
          }

          if (this.isComplete) {
            if (cb) {
              setTimeout(function () {
                return cb(_this);
              }, 1);
            }

            return;
          } else if (cb) {
            this.onComplete.once(cb);
          }

          this._setFlag(Resource.STATUS_FLAGS.LOADING, true);

          this.onStart.dispatch(this);

          // if unset, determine the value
          if (this.crossOrigin === false || typeof this.crossOrigin !== "string") {
            this.crossOrigin = this._determineCrossOrigin(this.url);
          }

          switch (this.loadType) {
            case Resource.LOAD_TYPE.IMAGE:
              this.type = Resource.TYPE.IMAGE;
              this._loadElement("image");
              break;

            case Resource.LOAD_TYPE.AUDIO:
              this.type = Resource.TYPE.AUDIO;
              this._loadSourceElement("audio");
              break;

            case Resource.LOAD_TYPE.VIDEO:
              this.type = Resource.TYPE.VIDEO;
              this._loadSourceElement("video");
              break;

            case Resource.LOAD_TYPE.XHR:
            /* falls through */
            default:
              if (useXdr && this.crossOrigin) {
                this._loadXdr();
              } else {
                this._loadXhr();
              }
              break;
          }
        };

        /**
         * Checks if the flag is set.
         *
         * @private
         * @param {number} flag - The flag to check.
         * @return {boolean} True if the flag is set.
         */

        Resource.prototype._hasFlag = function _hasFlag(flag) {
          return (this._flags & flag) !== 0;
        };

        /**
         * (Un)Sets the flag.
         *
         * @private
         * @param {number} flag - The flag to (un)set.
         * @param {boolean} value - Whether to set or (un)set the flag.
         */

        Resource.prototype._setFlag = function _setFlag(flag, value) {
          this._flags = value ? this._flags | flag : this._flags & ~flag;
        };

        /**
         * Clears all the events from the underlying loading source.
         *
         * @private
         */

        Resource.prototype._clearEvents = function _clearEvents() {
          clearTimeout(this._elementTimer);

          if (this.data && this.data.removeEventListener) {
            this.data.removeEventListener("error", this._boundOnError, false);
            this.data.removeEventListener("load", this._boundComplete, false);
            this.data.removeEventListener("progress", this._boundOnProgress, false);
            this.data.removeEventListener("canplaythrough", this._boundComplete, false);
          }

          if (this.xhr) {
            if (this.xhr.removeEventListener) {
              this.xhr.removeEventListener("error", this._boundXhrOnError, false);
              this.xhr.removeEventListener("timeout", this._boundXhrOnTimeout, false);
              this.xhr.removeEventListener("abort", this._boundXhrOnAbort, false);
              this.xhr.removeEventListener("progress", this._boundOnProgress, false);
              this.xhr.removeEventListener("load", this._boundXhrOnLoad, false);
            } else {
              this.xhr.onerror = null;
              this.xhr.ontimeout = null;
              this.xhr.onprogress = null;
              this.xhr.onload = null;
            }
          }
        };

        /**
         * Finalizes the load.
         *
         * @private
         */

        Resource.prototype._finish = function _finish() {
          if (this.isComplete) {
            throw new Error("Complete called again for an already completed resource.");
          }

          this._setFlag(Resource.STATUS_FLAGS.COMPLETE, true);
          this._setFlag(Resource.STATUS_FLAGS.LOADING, false);

          this.onComplete.dispatch(this);
        };

        /**
         * Loads this resources using an element that has a single source,
         * like an HTMLImageElement.
         *
         * @private
         * @param {string} type - The type of element to use.
         */

        Resource.prototype._loadElement = function _loadElement(type) {
          if (this.metadata.loadElement) {
            this.data = this.metadata.loadElement;
          } else if (type === "image" && typeof window.Image !== "undefined") {
            this.data = new Image();
          } else {
            this.data = document.createElement(type);
          }

          if (this.crossOrigin) {
            this.data.crossOrigin = this.crossOrigin;
          }

          if (!this.metadata.skipSource) {
            this.data.src = this.url;
          }

          this.data.addEventListener("error", this._boundOnError, false);
          this.data.addEventListener("load", this._boundComplete, false);
          this.data.addEventListener("progress", this._boundOnProgress, false);

          if (this.timeout) {
            this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);
          }
        };

        /**
         * Loads this resources using an element that has multiple sources,
         * like an HTMLAudioElement or HTMLVideoElement.
         *
         * @private
         * @param {string} type - The type of element to use.
         */

        Resource.prototype._loadSourceElement = function _loadSourceElement(type) {
          if (this.metadata.loadElement) {
            this.data = this.metadata.loadElement;
          } else if (type === "audio" && typeof window.Audio !== "undefined") {
            this.data = new Audio();
          } else {
            this.data = document.createElement(type);
          }

          if (this.data === null) {
            this.abort("Unsupported element: " + type);

            return;
          }

          if (this.crossOrigin) {
            this.data.crossOrigin = this.crossOrigin;
          }

          if (!this.metadata.skipSource) {
            // support for CocoonJS Canvas+ runtime, lacks document.createElement('source')
            if (navigator.isCocoonJS) {
              this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;
            } else if (Array.isArray(this.url)) {
              let mimeTypes = this.metadata.mimeType;

              for (let i = 0; i < this.url.length; ++i) {
                this.data.appendChild(this._createSource(type, this.url[i], Array.isArray(mimeTypes) ? mimeTypes[i] : mimeTypes));
              }
            } else {
              let _mimeTypes = this.metadata.mimeType;

              this.data.appendChild(this._createSource(type, this.url, Array.isArray(_mimeTypes) ? _mimeTypes[0] : _mimeTypes));
            }
          }

          this.data.addEventListener("error", this._boundOnError, false);
          this.data.addEventListener("load", this._boundComplete, false);
          this.data.addEventListener("progress", this._boundOnProgress, false);
          this.data.addEventListener("canplaythrough", this._boundComplete, false);

          this.data.load();

          if (this.timeout) {
            this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);
          }
        };

        /**
         * Loads this resources using an XMLHttpRequest.
         *
         * @private
         */

        Resource.prototype._loadXhr = function _loadXhr() {
          // if unset, determine the value
          if (typeof this.xhrType !== "string") {
            this.xhrType = this._determineXhrType();
          }

          let xhr = (this.xhr = new XMLHttpRequest());

          // set the request type and url
          xhr.open("GET", this.url, true);

          xhr.timeout = this.timeout;

          // load json as text and parse it ourselves. We do this because some browsers
          // *cough* safari *cough* can't deal with it.
          if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON || this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {
            xhr.responseType = Resource.XHR_RESPONSE_TYPE.TEXT;
          } else {
            xhr.responseType = this.xhrType;
          }

          xhr.addEventListener("error", this._boundXhrOnError, false);
          xhr.addEventListener("timeout", this._boundXhrOnTimeout, false);
          xhr.addEventListener("abort", this._boundXhrOnAbort, false);
          xhr.addEventListener("progress", this._boundOnProgress, false);
          xhr.addEventListener("load", this._boundXhrOnLoad, false);

          xhr.send();
        };

        /**
         * Loads this resources using an XDomainRequest. This is here because we need to support IE9 (gross).
         *
         * @private
         */

        Resource.prototype._loadXdr = function _loadXdr() {
          // if unset, determine the value
          if (typeof this.xhrType !== "string") {
            this.xhrType = this._determineXhrType();
          }

          let xdr = (this.xhr = new XDomainRequest()); // eslint-disable-line no-undef

          // XDomainRequest has a few quirks. Occasionally it will abort requests
          // A way to avoid this is to make sure ALL callbacks are set even if not used
          // More info here: http://stackoverflow.com/questions/15786966/xdomainrequest-aborts-post-on-ie-9
          xdr.timeout = this.timeout || 5000; // XDR needs a timeout value or it breaks in IE9

          xdr.onerror = this._boundXhrOnError;
          xdr.ontimeout = this._boundXhrOnTimeout;
          xdr.onprogress = this._boundOnProgress;
          xdr.onload = this._boundXhrOnLoad;

          xdr.open("GET", this.url, true);

          // Note: The xdr.send() call is wrapped in a timeout to prevent an
          // issue with the interface where some requests are lost if multiple
          // XDomainRequests are being sent at the same time.
          // Some info here: https://github.com/photonstorm/phaser/issues/1248
          setTimeout(function () {
            return xdr.send();
          }, 1);
        };

        /**
         * Creates a source used in loading via an element.
         *
         * @private
         * @param {string} type - The element type (video or audio).
         * @param {string} url - The source URL to load from.
         * @param {string} [mime] - The mime type of the video
         * @return {HTMLSourceElement} The source element.
         */

        Resource.prototype._createSource = function _createSource(type, url, mime) {
          if (!mime) {
            mime = type + "/" + this._getExtension(url);
          }

          let source = document.createElement("source");

          source.src = url;
          source.type = mime;

          return source;
        };

        /**
         * Called if a load errors out.
         *
         * @param {Event} event - The error event from the element that emits it.
         * @private
         */

        Resource.prototype._onError = function _onError(event) {
          this.abort("Failed to load element using: " + event.target.nodeName);
        };

        /**
         * Called if a load progress event fires for an element or xhr/xdr.
         *
         * @private
         * @param {XMLHttpRequestProgressEvent|Event} event - Progress event.
         */

        Resource.prototype._onProgress = function _onProgress(event) {
          if (event && event.lengthComputable) {
            this.onProgress.dispatch(this, event.loaded / event.total);
          }
        };

        /**
         * Called if a timeout event fires for an element.
         *
         * @private
         */

        Resource.prototype._onTimeout = function _onTimeout() {
          this.abort("Load timed out.");
        };

        /**
         * Called if an error event fires for xhr/xdr.
         *
         * @private
         */

        Resource.prototype._xhrOnError = function _xhrOnError() {
          let xhr = this.xhr;

          this.abort(reqType(xhr) + " Request failed. Status: " + xhr.status + ', text: "' + xhr.statusText + '"');
        };

        /**
         * Called if an error event fires for xhr/xdr.
         *
         * @private
         */

        Resource.prototype._xhrOnTimeout = function _xhrOnTimeout() {
          let xhr = this.xhr;

          this.abort(reqType(xhr) + " Request timed out.");
        };

        /**
         * Called if an abort event fires for xhr/xdr.
         *
         * @private
         */

        Resource.prototype._xhrOnAbort = function _xhrOnAbort() {
          let xhr = this.xhr;

          this.abort(reqType(xhr) + " Request was aborted by the user.");
        };

        /**
         * Called when data successfully loads from an xhr/xdr request.
         *
         * @private
         * @param {XMLHttpRequestLoadEvent|Event} event - Load event
         */

        Resource.prototype._xhrOnLoad = function _xhrOnLoad() {
          let xhr = this.xhr;
          let text = "";
          let status = typeof xhr.status === "undefined" ? STATUS_OK : xhr.status; // XDR has no `.status`, assume 200.

          // responseText is accessible only if responseType is '' or 'text' and on older browsers
          if (xhr.responseType === "" || xhr.responseType === "text" || typeof xhr.responseType === "undefined") {
            text = xhr.responseText;
          }

          // status can be 0 when using the `file://` protocol so we also check if a response is set.
          // If it has a response, we assume 200; otherwise a 0 status code with no contents is an aborted request.
          if (status === STATUS_NONE && (text.length > 0 || xhr.responseType === Resource.XHR_RESPONSE_TYPE.BUFFER)) {
            status = STATUS_OK;
          }
          // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
          else if (status === STATUS_IE_BUG_EMPTY) {
            status = STATUS_EMPTY;
          }

          let statusType = (status / 100) | 0;

          if (statusType === STATUS_TYPE_OK) {
            // if text, just return it
            if (this.xhrType === Resource.XHR_RESPONSE_TYPE.TEXT) {
              this.data = text;
              this.type = Resource.TYPE.TEXT;
            }
            // if json, parse into json object
            else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON) {
              try {
                this.data = JSON.parse(text);
                this.type = Resource.TYPE.JSON;
              } catch (e) {
                this.abort("Error trying to parse loaded json: " + e);

                return;
              }
            }
            // if xml, parse into an xml document or div element
            else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {
              try {
                if (window.DOMParser) {
                  let domparser = new DOMParser();

                  this.data = domparser.parseFromString(text, "text/xml");
                } else {
                  let div = document.createElement("div");

                  div.innerHTML = text;

                  this.data = div;
                }

                this.type = Resource.TYPE.XML;
              } catch (e) {
                this.abort("Error trying to parse loaded xml: " + e);

                return;
              }
            }
            // other types just return the response
            else {
              this.data = xhr.response || text;
            }
          } else {
            this.abort("[" + xhr.status + "] " + xhr.statusText + ": " + xhr.responseURL);

            return;
          }

          this.complete();
        };

        /**
         * Sets the `crossOrigin` property for this resource based on if the url
         * for this resource is cross-origin. If crossOrigin was manually set, this
         * function does nothing.
         *
         * @private
         * @param {string} url - The url to test.
         * @param {object} [loc=window.location] - The location object to test against.
         * @return {string} The crossOrigin value to use (or empty string for none).
         */

        Resource.prototype._determineCrossOrigin = function _determineCrossOrigin(url, loc) {
          // data: and javascript: urls are considered same-origin
          if (url.indexOf("data:") === 0) {
            return "";
          }

          // A sandboxed iframe without the 'allow-same-origin' attribute will have a special
          // origin designed not to match window.location.origin, and will always require
          // crossOrigin requests regardless of whether the location matches.
          if (window.origin !== window.location.origin) {
            return "anonymous";
          }

          // default is window.location
          loc = loc || window.location;

          if (!tempAnchor) {
            tempAnchor = document.createElement("a");
          }

          // let the browser determine the full href for the url of this resource and then
          // parse with the node url lib, we can't use the properties of the anchor element
          // because they don't work in IE9 :(
          tempAnchor.href = url;
          url = (0, _parseUri2.default)(tempAnchor.href, { strictMode: true });

          let samePort = (!url.port && loc.port === "") || url.port === loc.port;
          let protocol = url.protocol ? url.protocol + ":" : "";

          // if cross origin
          if (url.host !== loc.hostname || !samePort || protocol !== loc.protocol) {
            return "anonymous";
          }

          return "";
        };

        /**
         * Determines the responseType of an XHR request based on the extension of the
         * resource being loaded.
         *
         * @private
         * @return {Resource.XHR_RESPONSE_TYPE} The responseType to use.
         */

        Resource.prototype._determineXhrType = function _determineXhrType() {
          return Resource._xhrTypeMap[this.extension] || Resource.XHR_RESPONSE_TYPE.TEXT;
        };

        /**
         * Determines the loadType of a resource based on the extension of the
         * resource being loaded.
         *
         * @private
         * @return {Resource.LOAD_TYPE} The loadType to use.
         */

        Resource.prototype._determineLoadType = function _determineLoadType() {
          return Resource._loadTypeMap[this.extension] || Resource.LOAD_TYPE.XHR;
        };

        /**
         * Extracts the extension (sans '.') of the file being loaded by the resource.
         *
         * @private
         * @return {string} The extension.
         */

        Resource.prototype._getExtension = function _getExtension() {
          let url = this.url;
          let ext = "";

          if (this.isDataUrl) {
            let slashIndex = url.indexOf("/");

            ext = url.substring(slashIndex + 1, url.indexOf(";", slashIndex));
          } else {
            let queryStart = url.indexOf("?");
            let hashStart = url.indexOf("#");
            let index = Math.min(queryStart > -1 ? queryStart : url.length, hashStart > -1 ? hashStart : url.length);

            url = url.substring(0, index);
            ext = url.substring(url.lastIndexOf(".") + 1);
          }

          return ext.toLowerCase();
        };

        /**
         * Determines the mime type of an XHR request based on the responseType of
         * resource being loaded.
         *
         * @private
         * @param {Resource.XHR_RESPONSE_TYPE} type - The type to get a mime type for.
         * @return {string} The mime type to use.
         */

        Resource.prototype._getMimeFromXhrType = function _getMimeFromXhrType(type) {
          switch (type) {
            case Resource.XHR_RESPONSE_TYPE.BUFFER:
              return "application/octet-binary";

            case Resource.XHR_RESPONSE_TYPE.BLOB:
              return "application/blob";

            case Resource.XHR_RESPONSE_TYPE.DOCUMENT:
              return "application/xml";

            case Resource.XHR_RESPONSE_TYPE.JSON:
              return "application/json";

            case Resource.XHR_RESPONSE_TYPE.DEFAULT:
            case Resource.XHR_RESPONSE_TYPE.TEXT:
            /* falls through */
            default:
              return "text/plain";
          }
        };

        _createClass(Resource, [
          {
            key: "isDataUrl",
            get: function get() {
              return this._hasFlag(Resource.STATUS_FLAGS.DATA_URL);
            },

            /**
             * Describes if this resource has finished loading. Is true when the resource has completely
             * loaded.
             *
             * @readonly
             * @member {boolean}
             */
          },
          {
            key: "isComplete",
            get: function get() {
              return this._hasFlag(Resource.STATUS_FLAGS.COMPLETE);
            },

            /**
             * Describes if this resource is currently loading. Is true when the resource starts loading,
             * and is false again when complete.
             *
             * @readonly
             * @member {boolean}
             */
          },
          {
            key: "isLoading",
            get: function get() {
              return this._hasFlag(Resource.STATUS_FLAGS.LOADING);
            },
          },
        ]);

        return Resource;
      })());

      /**
       * The types of resources a resource could represent.
       *
       * @static
       * @readonly
       * @enum {number}
       */

      Resource.STATUS_FLAGS = {
        NONE: 0,
        DATA_URL: 1 << 0,
        COMPLETE: 1 << 1,
        LOADING: 1 << 2,
      };

      /**
       * The types of resources a resource could represent.
       *
       * @static
       * @readonly
       * @enum {number}
       */
      Resource.TYPE = {
        UNKNOWN: 0,
        JSON: 1,
        XML: 2,
        IMAGE: 3,
        AUDIO: 4,
        VIDEO: 5,
        TEXT: 6,
      };

      /**
       * The types of loading a resource can use.
       *
       * @static
       * @readonly
       * @enum {number}
       */
      Resource.LOAD_TYPE = {
        /** Uses XMLHttpRequest to load the resource. */
        XHR: 1,
        /** Uses an `Image` object to load the resource. */
        IMAGE: 2,
        /** Uses an `Audio` object to load the resource. */
        AUDIO: 3,
        /** Uses a `Video` object to load the resource. */
        VIDEO: 4,
      };

      /**
       * The XHR ready states, used internally.
       *
       * @static
       * @readonly
       * @enum {string}
       */
      Resource.XHR_RESPONSE_TYPE = {
        /** string */
        DEFAULT: "text",
        /** ArrayBuffer */
        BUFFER: "arraybuffer",
        /** Blob */
        BLOB: "blob",
        /** Document */
        DOCUMENT: "document",
        /** Object */
        JSON: "json",
        /** String */
        TEXT: "text",
      };

      Resource._loadTypeMap = {
        // images
        gif: Resource.LOAD_TYPE.IMAGE,
        png: Resource.LOAD_TYPE.IMAGE,
        bmp: Resource.LOAD_TYPE.IMAGE,
        jpg: Resource.LOAD_TYPE.IMAGE,
        jpeg: Resource.LOAD_TYPE.IMAGE,
        tif: Resource.LOAD_TYPE.IMAGE,
        tiff: Resource.LOAD_TYPE.IMAGE,
        webp: Resource.LOAD_TYPE.IMAGE,
        tga: Resource.LOAD_TYPE.IMAGE,
        svg: Resource.LOAD_TYPE.IMAGE,
        "svg+xml": Resource.LOAD_TYPE.IMAGE, // for SVG data urls

        // audio
        mp3: Resource.LOAD_TYPE.AUDIO,
        ogg: Resource.LOAD_TYPE.AUDIO,
        wav: Resource.LOAD_TYPE.AUDIO,

        // videos
        mp4: Resource.LOAD_TYPE.VIDEO,
        webm: Resource.LOAD_TYPE.VIDEO,
      };

      Resource._xhrTypeMap = {
        // xml
        xhtml: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
        html: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
        htm: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
        xml: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
        tmx: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
        svg: Resource.XHR_RESPONSE_TYPE.DOCUMENT,

        // This was added to handle Tiled Tileset XML, but .tsx is also a TypeScript React Component.
        // Since it is way less likely for people to be loading TypeScript files instead of Tiled files,
        // this should probably be fine.
        tsx: Resource.XHR_RESPONSE_TYPE.DOCUMENT,

        // images
        gif: Resource.XHR_RESPONSE_TYPE.BLOB,
        png: Resource.XHR_RESPONSE_TYPE.BLOB,
        bmp: Resource.XHR_RESPONSE_TYPE.BLOB,
        jpg: Resource.XHR_RESPONSE_TYPE.BLOB,
        jpeg: Resource.XHR_RESPONSE_TYPE.BLOB,
        tif: Resource.XHR_RESPONSE_TYPE.BLOB,
        tiff: Resource.XHR_RESPONSE_TYPE.BLOB,
        webp: Resource.XHR_RESPONSE_TYPE.BLOB,
        tga: Resource.XHR_RESPONSE_TYPE.BLOB,

        // json
        json: Resource.XHR_RESPONSE_TYPE.JSON,

        // text
        text: Resource.XHR_RESPONSE_TYPE.TEXT,
        txt: Resource.XHR_RESPONSE_TYPE.TEXT,

        // fonts
        ttf: Resource.XHR_RESPONSE_TYPE.BUFFER,
        otf: Resource.XHR_RESPONSE_TYPE.BUFFER,
      };

      // We can't set the `src` attribute to empty string, so on abort we set it to this 1px transparent gif
      Resource.EMPTY_GIF = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==";

      /**
       * Quick helper to set a value on one of the extension maps. Ensures there is no
       * dot at the start of the extension.
       *
       * @ignore
       * @param {object} map - The map to set on.
       * @param {string} extname - The extension (or key) to set.
       * @param {number} val - The value to set.
       */
      function setExtMap(map, extname, val) {
        if (extname && extname.indexOf(".") === 0) {
          extname = extname.substring(1);
        }

        if (!extname) {
          return;
        }

        map[extname] = val;
      }

      /**
       * Quick helper to get string xhr type.
       *
       * @ignore
       * @param {XMLHttpRequest|XDomainRequest} xhr - The request to check.
       * @return {string} The type.
       */
      function reqType(xhr) {
        return xhr.toString().replace("object ", "");
      }

      // Backwards compat
      if (true) {
        module.exports.default = Resource; // eslint-disable-line no-undef
      }
      //# sourceMappingURL=Resource.js.map

      /***/
    },
    /* 387 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      let _core = __webpack_require__(344);

      let core = _interopRequireWildcard(_core);

      let _CountLimiter = __webpack_require__(443);

      let _CountLimiter2 = _interopRequireDefault(_CountLimiter);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          let newObj = {};
          if (obj != null) {
            for (let key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }
          newObj.default = obj;
          return newObj;
        }
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      let SharedTicker = core.ticker.shared;

      /**
       * Default number of uploads per frame using prepare plugin.
       *
       * @static
       * @memberof PIXI.settings
       * @name UPLOADS_PER_FRAME
       * @type {number}
       * @default 4
       */
      core.settings.UPLOADS_PER_FRAME = 4;

      /**
       * The prepare manager provides functionality to upload content to the GPU. BasePrepare handles
       * basic queuing functionality and is extended by {@link PIXI.prepare.WebGLPrepare} and {@link PIXI.prepare.CanvasPrepare}
       * to provide preparation capabilities specific to their respective renderers.
       *
       * @example
       * // Create a sprite
       * const sprite = new PIXI.Sprite.fromImage('something.png');
       *
       * // Load object into GPU
       * app.renderer.plugins.prepare.upload(sprite, () => {
       *
       *     //Texture(s) has been uploaded to GPU
       *     app.stage.addChild(sprite);
       *
       * })
       *
       * @abstract
       * @class
       * @memberof PIXI.prepare
       */

      let BasePrepare = (function () {
        /**
         * @param {PIXI.SystemRenderer} renderer - A reference to the current renderer
         */
        function BasePrepare(renderer) {
          let _this = this;

          _classCallCheck(this, BasePrepare);

          /**
           * The limiter to be used to control how quickly items are prepared.
           * @type {PIXI.prepare.CountLimiter|PIXI.prepare.TimeLimiter}
           */
          this.limiter = new _CountLimiter2.default(core.settings.UPLOADS_PER_FRAME);

          /**
           * Reference to the renderer.
           * @type {PIXI.SystemRenderer}
           * @protected
           */
          this.renderer = renderer;

          /**
           * The only real difference between CanvasPrepare and WebGLPrepare is what they pass
           * to upload hooks. That different parameter is stored here.
           * @type {PIXI.prepare.CanvasPrepare|PIXI.WebGLRenderer}
           * @protected
           */
          this.uploadHookHelper = null;

          /**
           * Collection of items to uploads at once.
           * @type {Array<*>}
           * @private
           */
          this.queue = [];

          /**
           * Collection of additional hooks for finding assets.
           * @type {Array<Function>}
           * @private
           */
          this.addHooks = [];

          /**
           * Collection of additional hooks for processing assets.
           * @type {Array<Function>}
           * @private
           */
          this.uploadHooks = [];

          /**
           * Callback to call after completed.
           * @type {Array<Function>}
           * @private
           */
          this.completes = [];

          /**
           * If prepare is ticking (running).
           * @type {boolean}
           * @private
           */
          this.ticking = false;

          /**
           * 'bound' call for prepareItems().
           * @type {Function}
           * @private
           */
          this.delayedTick = function () {
            // unlikely, but in case we were destroyed between tick() and delayedTick()
            if (!_this.queue) {
              return;
            }
            _this.prepareItems();
          };

          // hooks to find the correct texture
          this.registerFindHook(findText);
          this.registerFindHook(findTextStyle);
          this.registerFindHook(findMultipleBaseTextures);
          this.registerFindHook(findBaseTexture);
          this.registerFindHook(findTexture);

          // upload hooks
          this.registerUploadHook(drawText);
          this.registerUploadHook(calculateTextStyle);
        }

        /**
         * Upload all the textures and graphics to the GPU.
         *
         * @param {Function|PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text} item -
         *        Either the container or display object to search for items to upload, the items to upload themselves,
         *        or the callback function, if items have been added using `prepare.add`.
         * @param {Function} [done] - Optional callback when all queued uploads have completed
         */

        BasePrepare.prototype.upload = function upload(item, done) {
          if (typeof item === "function") {
            done = item;
            item = null;
          }

          // If a display object, search for items
          // that we could upload
          if (item) {
            this.add(item);
          }

          // Get the items for upload from the display
          if (this.queue.length) {
            if (done) {
              this.completes.push(done);
            }

            if (!this.ticking) {
              this.ticking = true;
              SharedTicker.addOnce(this.tick, this, core.UPDATE_PRIORITY.UTILITY);
            }
          } else if (done) {
            done();
          }
        };

        /**
         * Handle tick update
         *
         * @private
         */

        BasePrepare.prototype.tick = function tick() {
          setTimeout(this.delayedTick, 0);
        };

        /**
         * Actually prepare items. This is handled outside of the tick because it will take a while
         * and we do NOT want to block the current animation frame from rendering.
         *
         * @private
         */

        BasePrepare.prototype.prepareItems = function prepareItems() {
          this.limiter.beginFrame();
          // Upload the graphics
          while (this.queue.length && this.limiter.allowedToUpload()) {
            let item = this.queue[0];
            let uploaded = false;

            if (item && !item._destroyed) {
              for (let i = 0, len = this.uploadHooks.length; i < len; i++) {
                if (this.uploadHooks[i](this.uploadHookHelper, item)) {
                  this.queue.shift();
                  uploaded = true;
                  break;
                }
              }
            }

            if (!uploaded) {
              this.queue.shift();
            }
          }

          // We're finished
          if (!this.queue.length) {
            this.ticking = false;

            let completes = this.completes.slice(0);

            this.completes.length = 0;

            for (let _i = 0, _len = completes.length; _i < _len; _i++) {
              completes[_i]();
            }
          } else {
            // if we are not finished, on the next rAF do this again
            SharedTicker.addOnce(this.tick, this, core.UPDATE_PRIORITY.UTILITY);
          }
        };

        /**
         * Adds hooks for finding items.
         *
         * @param {Function} addHook - Function call that takes two parameters: `item:*, queue:Array`
         *          function must return `true` if it was able to add item to the queue.
         * @return {PIXI.BasePrepare} Instance of plugin for chaining.
         */

        BasePrepare.prototype.registerFindHook = function registerFindHook(addHook) {
          if (addHook) {
            this.addHooks.push(addHook);
          }

          return this;
        };

        /**
         * Adds hooks for uploading items.
         *
         * @param {Function} uploadHook - Function call that takes two parameters: `prepare:CanvasPrepare, item:*` and
         *          function must return `true` if it was able to handle upload of item.
         * @return {PIXI.BasePrepare} Instance of plugin for chaining.
         */

        BasePrepare.prototype.registerUploadHook = function registerUploadHook(uploadHook) {
          if (uploadHook) {
            this.uploadHooks.push(uploadHook);
          }

          return this;
        };

        /**
         * Manually add an item to the uploading queue.
         *
         * @param {PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text|*} item - Object to
         *        add to the queue
         * @return {PIXI.CanvasPrepare} Instance of plugin for chaining.
         */

        BasePrepare.prototype.add = function add(item) {
          // Add additional hooks for finding elements on special
          // types of objects that
          for (let i = 0, len = this.addHooks.length; i < len; i++) {
            if (this.addHooks[i](item, this.queue)) {
              break;
            }
          }

          // Get childen recursively
          if (item instanceof core.Container) {
            for (let _i2 = item.children.length - 1; _i2 >= 0; _i2--) {
              this.add(item.children[_i2]);
            }
          }

          return this;
        };

        /**
         * Destroys the plugin, don't use after this.
         *
         */

        BasePrepare.prototype.destroy = function destroy() {
          if (this.ticking) {
            SharedTicker.remove(this.tick, this);
          }
          this.ticking = false;
          this.addHooks = null;
          this.uploadHooks = null;
          this.renderer = null;
          this.completes = null;
          this.queue = null;
          this.limiter = null;
          this.uploadHookHelper = null;
        };

        return BasePrepare;
      })();

      /**
       * Built-in hook to find multiple textures from objects like AnimatedSprites.
       *
       * @private
       * @param {PIXI.DisplayObject} item - Display object to check
       * @param {Array<*>} queue - Collection of items to upload
       * @return {boolean} if a PIXI.Texture object was found.
       */

      exports.default = BasePrepare;
      function findMultipleBaseTextures(item, queue) {
        let result = false;

        // Objects with mutliple textures
        if (item && item._textures && item._textures.length) {
          for (let i = 0; i < item._textures.length; i++) {
            if (item._textures[i] instanceof core.Texture) {
              let baseTexture = item._textures[i].baseTexture;

              if (queue.indexOf(baseTexture) === -1) {
                queue.push(baseTexture);
                result = true;
              }
            }
          }
        }

        return result;
      }

      /**
       * Built-in hook to find BaseTextures from Sprites.
       *
       * @private
       * @param {PIXI.DisplayObject} item - Display object to check
       * @param {Array<*>} queue - Collection of items to upload
       * @return {boolean} if a PIXI.Texture object was found.
       */
      function findBaseTexture(item, queue) {
        // Objects with textures, like Sprites/Text
        if (item instanceof core.BaseTexture) {
          if (queue.indexOf(item) === -1) {
            queue.push(item);
          }

          return true;
        }

        return false;
      }

      /**
       * Built-in hook to find textures from objects.
       *
       * @private
       * @param {PIXI.DisplayObject} item - Display object to check
       * @param {Array<*>} queue - Collection of items to upload
       * @return {boolean} if a PIXI.Texture object was found.
       */
      function findTexture(item, queue) {
        if (item._texture && item._texture instanceof core.Texture) {
          let texture = item._texture.baseTexture;

          if (queue.indexOf(texture) === -1) {
            queue.push(texture);
          }

          return true;
        }

        return false;
      }

      /**
       * Built-in hook to draw PIXI.Text to its texture.
       *
       * @private
       * @param {PIXI.WebGLRenderer|PIXI.CanvasPrepare} helper - Not used by this upload handler
       * @param {PIXI.DisplayObject} item - Item to check
       * @return {boolean} If item was uploaded.
       */
      function drawText(helper, item) {
        if (item instanceof core.Text) {
          // updating text will return early if it is not dirty
          item.updateText(true);

          return true;
        }

        return false;
      }

      /**
       * Built-in hook to calculate a text style for a PIXI.Text object.
       *
       * @private
       * @param {PIXI.WebGLRenderer|PIXI.CanvasPrepare} helper - Not used by this upload handler
       * @param {PIXI.DisplayObject} item - Item to check
       * @return {boolean} If item was uploaded.
       */
      function calculateTextStyle(helper, item) {
        if (item instanceof core.TextStyle) {
          let font = item.toFontString();

          core.TextMetrics.measureFont(font);

          return true;
        }

        return false;
      }

      /**
       * Built-in hook to find Text objects.
       *
       * @private
       * @param {PIXI.DisplayObject} item - Display object to check
       * @param {Array<*>} queue - Collection of items to upload
       * @return {boolean} if a PIXI.Text object was found.
       */
      function findText(item, queue) {
        if (item instanceof core.Text) {
          // push the text style to prepare it - this can be really expensive
          if (queue.indexOf(item.style) === -1) {
            queue.push(item.style);
          }
          // also push the text object so that we can render it (to canvas/texture) if needed
          if (queue.indexOf(item) === -1) {
            queue.push(item);
          }
          // also push the Text's texture for upload to GPU
          let texture = item._texture.baseTexture;

          if (queue.indexOf(texture) === -1) {
            queue.push(texture);
          }

          return true;
        }

        return false;
      }

      /**
       * Built-in hook to find TextStyle objects.
       *
       * @private
       * @param {PIXI.TextStyle} item - Display object to check
       * @param {Array<*>} queue - Collection of items to upload
       * @return {boolean} if a PIXI.TextStyle object was found.
       */
      function findTextStyle(item, queue) {
        if (item instanceof core.TextStyle) {
          if (queue.indexOf(item) === -1) {
            queue.push(item);
          }

          return true;
        }

        return false;
      }
      //# sourceMappingURL=BasePrepare.js.map

      /***/
    },
    ,
    ,
    ,
    ,
    ,
    /* 388 */ /* 389 */ /* 390 */ /* 391 */ /* 392 */ /* 393 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      let _createClass = (function () {
        function defineProperties(target, props) {
          for (let i = 0; i < props.length; i++) {
            let descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      })();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      /**
       * The Point object represents a location in a two-dimensional coordinate system, where x represents
       * the horizontal axis and y represents the vertical axis.
       * An observable point is a point that triggers a callback when the point's position is changed.
       *
       * @class
       * @memberof PIXI
       */
      let ObservablePoint = (function () {
        /**
         * @param {Function} cb - callback when changed
         * @param {object} scope - owner of callback
         * @param {number} [x=0] - position of the point on the x axis
         * @param {number} [y=0] - position of the point on the y axis
         */
        function ObservablePoint(cb, scope) {
          let x = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
          let y = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

          _classCallCheck(this, ObservablePoint);

          this._x = x;
          this._y = y;

          this.cb = cb;
          this.scope = scope;
        }

        /**
         * Creates a clone of this point.
         * The callback and scope params can be overidden otherwise they will default
         * to the clone object's values.
         *
         * @override
         * @param {Function} [cb=null] - callback when changed
         * @param {object} [scope=null] - owner of callback
         * @return {PIXI.ObservablePoint} a copy of the point
         */

        ObservablePoint.prototype.clone = function clone() {
          let cb = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          let scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

          let _cb = cb || this.cb;
          let _scope = scope || this.scope;

          return new ObservablePoint(_cb, _scope, this._x, this._y);
        };

        /**
         * Sets the point to a new x and y position.
         * If y is omitted, both x and y will be set to x.
         *
         * @param {number} [x=0] - position of the point on the x axis
         * @param {number} [y=0] - position of the point on the y axis
         */

        ObservablePoint.prototype.set = function set(x, y) {
          let _x = x || 0;
          let _y = y || (y !== 0 ? _x : 0);

          if (this._x !== _x || this._y !== _y) {
            this._x = _x;
            this._y = _y;
            this.cb.call(this.scope);
          }
        };

        /**
         * Copies the data from another point
         *
         * @param {PIXI.Point|PIXI.ObservablePoint} point - point to copy from
         */

        ObservablePoint.prototype.copy = function copy(point) {
          if (this._x !== point.x || this._y !== point.y) {
            this._x = point.x;
            this._y = point.y;
            this.cb.call(this.scope);
          }
        };

        /**
         * Returns true if the given point is equal to this point
         *
         * @param {PIXI.Point|PIXI.ObservablePoint} p - The point to check
         * @returns {boolean} Whether the given point equal to this point
         */

        ObservablePoint.prototype.equals = function equals(p) {
          return p.x === this._x && p.y === this._y;
        };

        /**
         * The position of the displayObject on the x axis relative to the local coordinates of the parent.
         *
         * @member {number}
         */

        _createClass(ObservablePoint, [
          {
            key: "x",
            get: function get() {
              return this._x;
            },
            set: function set(
              value // eslint-disable-line require-jsdoc
            ) {
              if (this._x !== value) {
                this._x = value;
                this.cb.call(this.scope);
              }
            },

            /**
             * The position of the displayObject on the x axis relative to the local coordinates of the parent.
             *
             * @member {number}
             */
          },
          {
            key: "y",
            get: function get() {
              return this._y;
            },
            set: function set(
              value // eslint-disable-line require-jsdoc
            ) {
              if (this._y !== value) {
                this._y = value;
                this.cb.call(this.scope);
              }
            },
          },
        ]);

        return ObservablePoint;
      })();

      exports.default = ObservablePoint;
      //# sourceMappingURL=ObservablePoint.js.map

      /***/
    },
    /* 394 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      let _Matrix = __webpack_require__(374);

      let _Matrix2 = _interopRequireDefault(_Matrix);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      let ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1]; // Your friendly neighbour https://en.wikipedia.org/wiki/Dihedral_group of order 16

      let uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
      let vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
      let vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
      let tempMatrices = [];

      let mul = [];

      function signum(x) {
        if (x < 0) {
          return -1;
        }
        if (x > 0) {
          return 1;
        }

        return 0;
      }

      function init() {
        for (let i = 0; i < 16; i++) {
          let row = [];

          mul.push(row);

          for (let j = 0; j < 16; j++) {
            let _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]);
            let _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]);
            let _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]);
            let _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]);

            for (let k = 0; k < 16; k++) {
              if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {
                row.push(k);
                break;
              }
            }
          }
        }

        for (let _i = 0; _i < 16; _i++) {
          let mat = new _Matrix2.default();

          mat.set(ux[_i], uy[_i], vx[_i], vy[_i], 0, 0);
          tempMatrices.push(mat);
        }
      }

      init();

      /**
       * Implements Dihedral Group D_8, see [group D4]{@link http://mathworld.wolfram.com/DihedralGroupD4.html},
       * D8 is the same but with diagonals. Used for texture rotations.
       *
       * Vector xX(i), xY(i) is U-axis of sprite with rotation i
       * Vector yY(i), yY(i) is V-axis of sprite with rotation i
       * Rotations: 0 grad (0), 90 grad (2), 180 grad (4), 270 grad (6)
       * Mirrors: vertical (8), main diagonal (10), horizontal (12), reverse diagonal (14)
       * This is the small part of gameofbombs.com portal system. It works.
       *
       * @author Ivan @ivanpopelyshev
       * @class
       * @memberof PIXI
       */
      var GroupD8 = {
        E: 0,
        SE: 1,
        S: 2,
        SW: 3,
        W: 4,
        NW: 5,
        N: 6,
        NE: 7,
        MIRROR_VERTICAL: 8,
        MIRROR_HORIZONTAL: 12,
        uX: function uX(ind) {
          return ux[ind];
        },
        uY: function uY(ind) {
          return uy[ind];
        },
        vX: function vX(ind) {
          return vx[ind];
        },
        vY: function vY(ind) {
          return vy[ind];
        },
        inv: function inv(rotation) {
          if (rotation & 8) {
            return rotation & 15;
          }

          return -rotation & 7;
        },
        add: function add(rotationSecond, rotationFirst) {
          return mul[rotationSecond][rotationFirst];
        },
        sub: function sub(rotationSecond, rotationFirst) {
          return mul[rotationSecond][GroupD8.inv(rotationFirst)];
        },

        /**
         * Adds 180 degrees to rotation. Commutative operation.
         *
         * @memberof PIXI.GroupD8
         * @param {number} rotation - The number to rotate.
         * @returns {number} rotated number
         */
        rotate180: function rotate180(rotation) {
          return rotation ^ 4;
        },

        /**
         * Direction of main vector can be horizontal, vertical or diagonal.
         * Some objects work with vertical directions different.
         *
         * @memberof PIXI.GroupD8
         * @param {number} rotation - The number to check.
         * @returns {boolean} Whether or not the direction is vertical
         */
        isVertical: function isVertical(rotation) {
          return (rotation & 3) === 2;
        },

        /**
         * @memberof PIXI.GroupD8
         * @param {number} dx - TODO
         * @param {number} dy - TODO
         *
         * @return {number} TODO
         */
        byDirection: function byDirection(dx, dy) {
          if (Math.abs(dx) * 2 <= Math.abs(dy)) {
            if (dy >= 0) {
              return GroupD8.S;
            }

            return GroupD8.N;
          } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
            if (dx > 0) {
              return GroupD8.E;
            }

            return GroupD8.W;
          } else if (dy > 0) {
            if (dx > 0) {
              return GroupD8.SE;
            }

            return GroupD8.SW;
          } else if (dx > 0) {
            return GroupD8.NE;
          }

          return GroupD8.NW;
        },

        /**
         * Helps sprite to compensate texture packer rotation.
         *
         * @memberof PIXI.GroupD8
         * @param {PIXI.Matrix} matrix - sprite world matrix
         * @param {number} rotation - The rotation factor to use.
         * @param {number} tx - sprite anchoring
         * @param {number} ty - sprite anchoring
         */
        matrixAppendRotationInv: function matrixAppendRotationInv(matrix, rotation) {
          let tx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
          let ty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

          // Packer used "rotation", we use "inv(rotation)"
          let mat = tempMatrices[GroupD8.inv(rotation)];

          mat.tx = tx;
          mat.ty = ty;
          matrix.append(mat);
        },
      };

      exports.default = GroupD8;
      //# sourceMappingURL=GroupD8.js.map

      /***/
    },
    /* 395 */
    /***/ function (module, exports) {
      // var GL_MAP = {};

      /**
       * @param gl {WebGLRenderingContext} The current WebGL context
       * @param attribs {*}
       * @param state {*}
       */
      let setVertexAttribArrays = function (gl, attribs, state) {
        let i;
        if (state) {
          let tempAttribState = state.tempAttribState,
            attribState = state.attribState;

          for (i = 0; i < tempAttribState.length; i++) {
            tempAttribState[i] = false;
          }

          // set the new attribs
          for (i = 0; i < attribs.length; i++) {
            tempAttribState[attribs[i].attribute.location] = true;
          }

          for (i = 0; i < attribState.length; i++) {
            if (attribState[i] !== tempAttribState[i]) {
              attribState[i] = tempAttribState[i];

              if (state.attribState[i]) {
                gl.enableVertexAttribArray(i);
              } else {
                gl.disableVertexAttribArray(i);
              }
            }
          }
        } else {
          for (i = 0; i < attribs.length; i++) {
            let attrib = attribs[i];
            gl.enableVertexAttribArray(attrib.attribute.location);
          }
        }
      };

      module.exports = setVertexAttribArrays;

      /***/
    },
    /* 396 */
    /***/ function (module, exports) {
      /**
       * Helper class to create a WebGL Texture
       *
       * @class
       * @memberof PIXI.glCore
       * @param gl {WebGLRenderingContext} The current WebGL context
       * @param width {number} the width of the texture
       * @param height {number} the height of the texture
       * @param format {number} the pixel format of the texture. defaults to gl.RGBA
       * @param type {number} the gl type of the texture. defaults to gl.UNSIGNED_BYTE
       */
      let Texture = function (gl, width, height, format, type) {
        /**
         * The current WebGL rendering context
         *
         * @member {WebGLRenderingContext}
         */
        this.gl = gl;

        /**
         * The WebGL texture
         *
         * @member {WebGLTexture}
         */
        this.texture = gl.createTexture();

        /**
         * If mipmapping was used for this texture, enable and disable with enableMipmap()
         *
         * @member {Boolean}
         */
        // some settings..
        this.mipmap = false;

        /**
         * Set to true to enable pre-multiplied alpha
         *
         * @member {Boolean}
         */
        this.premultiplyAlpha = false;

        /**
         * The width of texture
         *
         * @member {Number}
         */
        this.width = width || -1;
        /**
         * The height of texture
         *
         * @member {Number}
         */
        this.height = height || -1;

        /**
         * The pixel format of the texture. defaults to gl.RGBA
         *
         * @member {Number}
         */
        this.format = format || gl.RGBA;

        /**
         * The gl type of the texture. defaults to gl.UNSIGNED_BYTE
         *
         * @member {Number}
         */
        this.type = type || gl.UNSIGNED_BYTE;
      };

      /**
       * Uploads this texture to the GPU
       * @param source {HTMLImageElement|ImageData|HTMLVideoElement} the source image of the texture
       */
      Texture.prototype.upload = function (source) {
        this.bind();

        let gl = this.gl;

        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);

        let newWidth = source.videoWidth || source.width;
        let newHeight = source.videoHeight || source.height;

        if (newHeight !== this.height || newWidth !== this.width) {
          gl.texImage2D(gl.TEXTURE_2D, 0, this.format, this.format, this.type, source);
        } else {
          gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.format, this.type, source);
        }

        // if the source is a video, we need to use the videoWidth / videoHeight properties as width / height will be incorrect.
        this.width = newWidth;
        this.height = newHeight;
      };

      let FLOATING_POINT_AVAILABLE = false;

      /**
       * Use a data source and uploads this texture to the GPU
       * @param data {TypedArray} the data to upload to the texture
       * @param width {number} the new width of the texture
       * @param height {number} the new height of the texture
       */
      Texture.prototype.uploadData = function (data, width, height) {
        this.bind();

        let gl = this.gl;

        if (data instanceof Float32Array) {
          if (!FLOATING_POINT_AVAILABLE) {
            let ext = gl.getExtension("OES_texture_float");

            if (ext) {
              FLOATING_POINT_AVAILABLE = true;
            } else {
              throw new Error("floating point textures not available");
            }
          }

          this.type = gl.FLOAT;
        } else {
          // TODO support for other types
          this.type = this.type || gl.UNSIGNED_BYTE;
        }

        // what type of data?
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);

        if (width !== this.width || height !== this.height) {
          gl.texImage2D(gl.TEXTURE_2D, 0, this.format, width, height, 0, this.format, this.type, data || null);
        } else {
          gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, this.format, this.type, data || null);
        }

        this.width = width;
        this.height = height;

        //	texSubImage2D
      };

      /**
       * Binds the texture
       * @param  location
       */
      Texture.prototype.bind = function (location) {
        let gl = this.gl;

        if (location !== undefined) {
          gl.activeTexture(gl.TEXTURE0 + location);
        }

        gl.bindTexture(gl.TEXTURE_2D, this.texture);
      };

      /**
       * Unbinds the texture
       */
      Texture.prototype.unbind = function () {
        let gl = this.gl;
        gl.bindTexture(gl.TEXTURE_2D, null);
      };

      /**
       * @param linear {Boolean} if we want to use linear filtering or nearest neighbour interpolation
       */
      Texture.prototype.minFilter = function (linear) {
        let gl = this.gl;

        this.bind();

        if (this.mipmap) {
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, linear ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
        } else {
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, linear ? gl.LINEAR : gl.NEAREST);
        }
      };

      /**
       * @param linear {Boolean} if we want to use linear filtering or nearest neighbour interpolation
       */
      Texture.prototype.magFilter = function (linear) {
        let gl = this.gl;

        this.bind();

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, linear ? gl.LINEAR : gl.NEAREST);
      };

      /**
       * Enables mipmapping
       */
      Texture.prototype.enableMipmap = function () {
        let gl = this.gl;

        this.bind();

        this.mipmap = true;

        gl.generateMipmap(gl.TEXTURE_2D);
      };

      /**
       * Enables linear filtering
       */
      Texture.prototype.enableLinearScaling = function () {
        this.minFilter(true);
        this.magFilter(true);
      };

      /**
       * Enables nearest neighbour interpolation
       */
      Texture.prototype.enableNearestScaling = function () {
        this.minFilter(false);
        this.magFilter(false);
      };

      /**
       * Enables clamping on the texture so WebGL will not repeat it
       */
      Texture.prototype.enableWrapClamp = function () {
        let gl = this.gl;

        this.bind();

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      };

      /**
       * Enable tiling on the texture
       */
      Texture.prototype.enableWrapRepeat = function () {
        let gl = this.gl;

        this.bind();

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
      };

      Texture.prototype.enableWrapMirrorRepeat = function () {
        let gl = this.gl;

        this.bind();

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT);
      };

      /**
       * Destroys this texture
       */
      Texture.prototype.destroy = function () {
        let gl = this.gl;
        //TODO
        gl.deleteTexture(this.texture);
      };

      /**
       * @static
       * @param gl {WebGLRenderingContext} The current WebGL context
       * @param source {HTMLImageElement|ImageData} the source image of the texture
       * @param premultiplyAlpha {Boolean} If we want to use pre-multiplied alpha
       */
      Texture.fromSource = function (gl, source, premultiplyAlpha) {
        let texture = new Texture(gl);
        texture.premultiplyAlpha = premultiplyAlpha || false;
        texture.upload(source);

        return texture;
      };

      /**
       * @static
       * @param gl {WebGLRenderingContext} The current WebGL context
       * @param data {TypedArray} the data to upload to the texture
       * @param width {number} the new width of the texture
       * @param height {number} the new height of the texture
       */
      Texture.fromData = function (gl, data, width, height) {
        //console.log(data, width, height);
        let texture = new Texture(gl);
        texture.uploadData(data, width, height);

        return texture;
      };

      module.exports = Texture;

      /***/
    },
    /* 397 */
    /***/ function (module, exports) {
      /**
       * @class
       * @memberof PIXI.glCore.shader
       * @param gl {WebGLRenderingContext} The current WebGL context {WebGLProgram}
       * @param vertexSrc {string|string[]} The vertex shader source as an array of strings.
       * @param fragmentSrc {string|string[]} The fragment shader source as an array of strings.
       * @param attributeLocations {Object} An attribute location map that lets you manually set the attribute locations
       * @return {WebGLProgram} the shader program
       */
      let compileProgram = function (gl, vertexSrc, fragmentSrc, attributeLocations) {
        let glVertShader = compileShader(gl, gl.VERTEX_SHADER, vertexSrc);
        let glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentSrc);

        let program = gl.createProgram();

        gl.attachShader(program, glVertShader);
        gl.attachShader(program, glFragShader);

        // optionally, set the attributes manually for the program rather than letting WebGL decide..
        if (attributeLocations) {
          for (let i in attributeLocations) {
            gl.bindAttribLocation(program, attributeLocations[i], i);
          }
        }

        gl.linkProgram(program);

        // if linking fails, then log and cleanup
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          console.error("Pixi.js Error: Could not initialize shader.");
          console.error("gl.VALIDATE_STATUS", gl.getProgramParameter(program, gl.VALIDATE_STATUS));
          console.error("gl.getError()", gl.getError());

          // if there is a program info log, log it
          if (gl.getProgramInfoLog(program) !== "") {
            console.warn("Pixi.js Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));
          }

          gl.deleteProgram(program);
          program = null;
        }

        // clean up some shaders
        gl.deleteShader(glVertShader);
        gl.deleteShader(glFragShader);

        return program;
      };

      /**
       * @private
       * @param gl {WebGLRenderingContext} The current WebGL context {WebGLProgram}
       * @param type {Number} the type, can be either VERTEX_SHADER or FRAGMENT_SHADER
       * @param vertexSrc {string|string[]} The vertex shader source as an array of strings.
       * @return {WebGLShader} the shader
       */
      var compileShader = function (gl, type, src) {
        let shader = gl.createShader(type);

        gl.shaderSource(shader, src);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.log(gl.getShaderInfoLog(shader));
          return null;
        }

        return shader;
      };

      module.exports = compileProgram;

      /***/
    },
    /* 398 */
    /***/ function (module, exports, __webpack_require__) {
      let mapType = __webpack_require__(376);
      let mapSize = __webpack_require__(399);

      /**
       * Extracts the attributes
       * @class
       * @memberof PIXI.glCore.shader
       * @param gl {WebGLRenderingContext} The current WebGL rendering context
       * @param program {WebGLProgram} The shader program to get the attributes from
       * @return attributes {Object}
       */
      let extractAttributes = function (gl, program) {
        let attributes = {};

        let totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);

        for (let i = 0; i < totalAttributes; i++) {
          let attribData = gl.getActiveAttrib(program, i);
          let type = mapType(gl, attribData.type);

          attributes[attribData.name] = {
            type: type,
            size: mapSize(type),
            location: gl.getAttribLocation(program, attribData.name),
            //TODO - make an attribute object
            pointer: pointer,
          };
        }

        return attributes;
      };

      var pointer = function (type, normalized, stride, start) {
        // console.log(this.location)
        gl.vertexAttribPointer(this.location, this.size, type || gl.FLOAT, normalized || false, stride || 0, start || 0);
      };

      module.exports = extractAttributes;

      /***/
    },
    /* 399 */
    /***/ function (module, exports) {
      /**
       * @class
       * @memberof PIXI.glCore.shader
       * @param type {String}
       * @return {Number}
       */
      let mapSize = function (type) {
        return GLSL_TO_SIZE[type];
      };

      var GLSL_TO_SIZE = {
        float: 1,
        vec2: 2,
        vec3: 3,
        vec4: 4,

        int: 1,
        ivec2: 2,
        ivec3: 3,
        ivec4: 4,

        bool: 1,
        bvec2: 2,
        bvec3: 3,
        bvec4: 4,

        mat2: 4,
        mat3: 9,
        mat4: 16,

        sampler2D: 1,
      };

      module.exports = mapSize;

      /***/
    },
    /* 400 */
    /***/ function (module, exports, __webpack_require__) {
      let mapType = __webpack_require__(376);
      let defaultValue = __webpack_require__(401);

      /**
       * Extracts the uniforms
       * @class
       * @memberof PIXI.glCore.shader
       * @param gl {WebGLRenderingContext} The current WebGL rendering context
       * @param program {WebGLProgram} The shader program to get the uniforms from
       * @return uniforms {Object}
       */
      let extractUniforms = function (gl, program) {
        let uniforms = {};

        let totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

        for (let i = 0; i < totalUniforms; i++) {
          let uniformData = gl.getActiveUniform(program, i);
          let name = uniformData.name.replace(/\[.*?\]/, "");
          let type = mapType(gl, uniformData.type);

          uniforms[name] = {
            type: type,
            size: uniformData.size,
            location: gl.getUniformLocation(program, name),
            value: defaultValue(type, uniformData.size),
          };
        }

        return uniforms;
      };

      module.exports = extractUniforms;

      /***/
    },
    /* 401 */
    /***/ function (module, exports) {
      /**
       * @class
       * @memberof PIXI.glCore.shader
       * @param type {String} Type of value
       * @param size {Number}
       */
      let defaultValue = function (type, size) {
        switch (type) {
          case "float":
            return 0;

          case "vec2":
            return new Float32Array(2 * size);

          case "vec3":
            return new Float32Array(3 * size);

          case "vec4":
            return new Float32Array(4 * size);

          case "int":
          case "sampler2D":
            return 0;

          case "ivec2":
            return new Int32Array(2 * size);

          case "ivec3":
            return new Int32Array(3 * size);

          case "ivec4":
            return new Int32Array(4 * size);

          case "bool":
            return false;

          case "bvec2":
            return booleanArray(2 * size);

          case "bvec3":
            return booleanArray(3 * size);

          case "bvec4":
            return booleanArray(4 * size);

          case "mat2":
            return new Float32Array([1, 0, 0, 1]);

          case "mat3":
            return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);

          case "mat4":
            return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
        }
      };

      var booleanArray = function (size) {
        let array = new Array(size);

        for (let i = 0; i < array.length; i++) {
          array[i] = false;
        }

        return array;
      };

      module.exports = defaultValue;

      /***/
    },
    /* 402 */
    /***/ function (module, exports) {
      /**
       * Sets the float precision on the shader. If the precision is already present this function will do nothing
       * @param {string} src       the shader source
       * @param {string} precision The float precision of the shader. Options are 'lowp', 'mediump' or 'highp'.
       *
       * @return {string} modified shader source
       */
      let setPrecision = function (src, precision) {
        if (src.substring(0, 9) !== "precision") {
          return "precision " + precision + " float;\n" + src;
        }

        return src;
      };

      module.exports = setPrecision;

      /***/
    },
    /* 403 */
    /***/ function (module, exports) {
      /**
       * Extracts the attributes
       * @class
       * @memberof PIXI.glCore.shader
       * @param gl {WebGLRenderingContext} The current WebGL rendering context
       * @param uniforms {Array} @mat ?
       * @return attributes {Object}
       */
      let generateUniformAccessObject = function (gl, uniformData) {
        // this is the object we will be sending back.
        // an object hierachy will be created for structs
        let uniforms = { data: {} };

        uniforms.gl = gl;

        let uniformKeys = Object.keys(uniformData);

        for (let i = 0; i < uniformKeys.length; i++) {
          let fullName = uniformKeys[i];

          let nameTokens = fullName.split(".");
          let name = nameTokens[nameTokens.length - 1];

          let uniformGroup = getUniformGroup(nameTokens, uniforms);

          let uniform = uniformData[fullName];
          uniformGroup.data[name] = uniform;

          uniformGroup.gl = gl;

          Object.defineProperty(uniformGroup, name, {
            get: generateGetter(name),
            set: generateSetter(name, uniform),
          });
        }

        return uniforms;
      };

      var generateGetter = function (name) {
        return function () {
          return this.data[name].value;
        };
      };

      let GLSL_SINGLE_SETTERS = {
        float: function setSingleFloat(gl, location, value) {
          gl.uniform1f(location, value);
        },
        vec2: function setSingleVec2(gl, location, value) {
          gl.uniform2f(location, value[0], value[1]);
        },
        vec3: function setSingleVec3(gl, location, value) {
          gl.uniform3f(location, value[0], value[1], value[2]);
        },
        vec4: function setSingleVec4(gl, location, value) {
          gl.uniform4f(location, value[0], value[1], value[2], value[3]);
        },

        int: function setSingleInt(gl, location, value) {
          gl.uniform1i(location, value);
        },
        ivec2: function setSingleIvec2(gl, location, value) {
          gl.uniform2i(location, value[0], value[1]);
        },
        ivec3: function setSingleIvec3(gl, location, value) {
          gl.uniform3i(location, value[0], value[1], value[2]);
        },
        ivec4: function setSingleIvec4(gl, location, value) {
          gl.uniform4i(location, value[0], value[1], value[2], value[3]);
        },

        bool: function setSingleBool(gl, location, value) {
          gl.uniform1i(location, value);
        },
        bvec2: function setSingleBvec2(gl, location, value) {
          gl.uniform2i(location, value[0], value[1]);
        },
        bvec3: function setSingleBvec3(gl, location, value) {
          gl.uniform3i(location, value[0], value[1], value[2]);
        },
        bvec4: function setSingleBvec4(gl, location, value) {
          gl.uniform4i(location, value[0], value[1], value[2], value[3]);
        },

        mat2: function setSingleMat2(gl, location, value) {
          gl.uniformMatrix2fv(location, false, value);
        },
        mat3: function setSingleMat3(gl, location, value) {
          gl.uniformMatrix3fv(location, false, value);
        },
        mat4: function setSingleMat4(gl, location, value) {
          gl.uniformMatrix4fv(location, false, value);
        },

        sampler2D: function setSingleSampler2D(gl, location, value) {
          gl.uniform1i(location, value);
        },
      };

      let GLSL_ARRAY_SETTERS = {
        float: function setFloatArray(gl, location, value) {
          gl.uniform1fv(location, value);
        },
        vec2: function setVec2Array(gl, location, value) {
          gl.uniform2fv(location, value);
        },
        vec3: function setVec3Array(gl, location, value) {
          gl.uniform3fv(location, value);
        },
        vec4: function setVec4Array(gl, location, value) {
          gl.uniform4fv(location, value);
        },
        int: function setIntArray(gl, location, value) {
          gl.uniform1iv(location, value);
        },
        ivec2: function setIvec2Array(gl, location, value) {
          gl.uniform2iv(location, value);
        },
        ivec3: function setIvec3Array(gl, location, value) {
          gl.uniform3iv(location, value);
        },
        ivec4: function setIvec4Array(gl, location, value) {
          gl.uniform4iv(location, value);
        },
        bool: function setBoolArray(gl, location, value) {
          gl.uniform1iv(location, value);
        },
        bvec2: function setBvec2Array(gl, location, value) {
          gl.uniform2iv(location, value);
        },
        bvec3: function setBvec3Array(gl, location, value) {
          gl.uniform3iv(location, value);
        },
        bvec4: function setBvec4Array(gl, location, value) {
          gl.uniform4iv(location, value);
        },
        sampler2D: function setSampler2DArray(gl, location, value) {
          gl.uniform1iv(location, value);
        },
      };

      function generateSetter(name, uniform) {
        return function (value) {
          this.data[name].value = value;
          let location = this.data[name].location;
          if (uniform.size === 1) {
            GLSL_SINGLE_SETTERS[uniform.type](this.gl, location, value);
          } else {
            // glslSetArray(gl, location, type, value) {
            GLSL_ARRAY_SETTERS[uniform.type](this.gl, location, value);
          }
        };
      }

      function getUniformGroup(nameTokens, uniform) {
        let cur = uniform;

        for (let i = 0; i < nameTokens.length - 1; i++) {
          let o = cur[nameTokens[i]] || { data: {} };
          cur[nameTokens[i]] = o;
          cur = o;
        }

        return cur;
      }

      module.exports = generateUniformAccessObject;

      /***/
    },
    /* 404 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      let _createClass = (function () {
        function defineProperties(target, props) {
          for (let i = 0; i < props.length; i++) {
            let descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      })();

      let _eventemitter = __webpack_require__(354);

      let _eventemitter2 = _interopRequireDefault(_eventemitter);

      let _const = __webpack_require__(343);

      let _settings = __webpack_require__(346);

      let _settings2 = _interopRequireDefault(_settings);

      let _TransformStatic = __webpack_require__(405);

      let _TransformStatic2 = _interopRequireDefault(_TransformStatic);

      let _Transform = __webpack_require__(406);

      let _Transform2 = _interopRequireDefault(_Transform);

      let _Bounds = __webpack_require__(377);

      let _Bounds2 = _interopRequireDefault(_Bounds);

      let _math = __webpack_require__(348);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: { value: subClass, enumerable: false, writable: true, configurable: true },
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass);
      }

      // _tempDisplayObjectParent = new DisplayObject();

      /**
       * The base class for all objects that are rendered on the screen.
       * This is an abstract class and should not be used on its own rather it should be extended.
       *
       * @class
       * @extends EventEmitter
       * @memberof PIXI
       */
      let DisplayObject = (function (_EventEmitter) {
        _inherits(DisplayObject, _EventEmitter);

        /**
         *
         */
        function DisplayObject() {
          _classCallCheck(this, DisplayObject);

          let _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

          let TransformClass = _settings2.default.TRANSFORM_MODE === _const.TRANSFORM_MODE.STATIC ? _TransformStatic2.default : _Transform2.default;

          _this.tempDisplayObjectParent = null;

          // TODO: need to create Transform from factory
          /**
           * World transform and local transform of this object.
           * This will become read-only later, please do not assign anything there unless you know what are you doing
           *
           * @member {PIXI.TransformBase}
           */
          _this.transform = new TransformClass();

          /**
           * The opacity of the object.
           *
           * @member {number}
           */
          _this.alpha = 1;

          /**
           * The visibility of the object. If false the object will not be drawn, and
           * the updateTransform function will not be called.
           *
           * Only affects recursive calls from parent. You can ask for bounds or call updateTransform manually
           *
           * @member {boolean}
           */
          _this.visible = true;

          /**
           * Can this object be rendered, if false the object will not be drawn but the updateTransform
           * methods will still be called.
           *
           * Only affects recursive calls from parent. You can ask for bounds manually
           *
           * @member {boolean}
           */
          _this.renderable = true;

          /**
           * The display object container that contains this display object.
           *
           * @member {PIXI.Container}
           * @readonly
           */
          _this.parent = null;

          /**
           * The multiplied alpha of the displayObject
           *
           * @member {number}
           * @readonly
           */
          _this.worldAlpha = 1;

          /**
           * The area the filter is applied to. This is used as more of an optimisation
           * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle
           *
           * Also works as an interaction mask
           *
           * @member {PIXI.Rectangle}
           */
          _this.filterArea = null;

          _this._filters = null;
          _this._enabledFilters = null;

          /**
           * The bounds object, this is used to calculate and store the bounds of the displayObject
           *
           * @member {PIXI.Rectangle}
           * @private
           */
          _this._bounds = new _Bounds2.default();
          _this._boundsID = 0;
          _this._lastBoundsID = -1;
          _this._boundsRect = null;
          _this._localBoundsRect = null;

          /**
           * The original, cached mask of the object
           *
           * @member {PIXI.Graphics|PIXI.Sprite}
           * @private
           */
          _this._mask = null;

          /**
           * If the object has been destroyed via destroy(). If true, it should not be used.
           *
           * @member {boolean}
           * @private
           * @readonly
           */
          _this._destroyed = false;

          /**
           * Fired when this DisplayObject is added to a Container.
           *
           * @event PIXI.DisplayObject#added
           * @param {PIXI.Container} container - The container added to.
           */

          /**
           * Fired when this DisplayObject is removed from a Container.
           *
           * @event PIXI.DisplayObject#removed
           * @param {PIXI.Container} container - The container removed from.
           */
          return _this;
        }

        /**
         * @private
         * @member {PIXI.DisplayObject}
         */

        /**
         * Updates the object transform for rendering
         *
         * TODO - Optimization pass!
         */
        DisplayObject.prototype.updateTransform = function updateTransform() {
          this.transform.updateTransform(this.parent.transform);
          // multiply the alphas..
          this.worldAlpha = this.alpha * this.parent.worldAlpha;

          this._bounds.updateID++;
        };

        /**
         * recursively updates transform of all objects from the root to this one
         * internal function for toLocal()
         */

        DisplayObject.prototype._recursivePostUpdateTransform = function _recursivePostUpdateTransform() {
          if (this.parent) {
            this.parent._recursivePostUpdateTransform();
            this.transform.updateTransform(this.parent.transform);
          } else {
            this.transform.updateTransform(this._tempDisplayObjectParent.transform);
          }
        };

        /**
         * Retrieves the bounds of the displayObject as a rectangle object.
         *
         * @param {boolean} skipUpdate - setting to true will stop the transforms of the scene graph from
         *  being updated. This means the calculation returned MAY be out of date BUT will give you a
         *  nice performance boost
         * @param {PIXI.Rectangle} rect - Optional rectangle to store the result of the bounds calculation
         * @return {PIXI.Rectangle} the rectangular bounding area
         */

        DisplayObject.prototype.getBounds = function getBounds(skipUpdate, rect) {
          if (!skipUpdate) {
            if (!this.parent) {
              this.parent = this._tempDisplayObjectParent;
              this.updateTransform();
              this.parent = null;
            } else {
              this._recursivePostUpdateTransform();
              this.updateTransform();
            }
          }

          if (this._boundsID !== this._lastBoundsID) {
            this.calculateBounds();
          }

          if (!rect) {
            if (!this._boundsRect) {
              this._boundsRect = new _math.Rectangle();
            }

            rect = this._boundsRect;
          }

          return this._bounds.getRectangle(rect);
        };

        /**
         * Retrieves the local bounds of the displayObject as a rectangle object
         *
         * @param {PIXI.Rectangle} [rect] - Optional rectangle to store the result of the bounds calculation
         * @return {PIXI.Rectangle} the rectangular bounding area
         */

        DisplayObject.prototype.getLocalBounds = function getLocalBounds(rect) {
          let transformRef = this.transform;
          let parentRef = this.parent;

          this.parent = null;
          this.transform = this._tempDisplayObjectParent.transform;

          if (!rect) {
            if (!this._localBoundsRect) {
              this._localBoundsRect = new _math.Rectangle();
            }

            rect = this._localBoundsRect;
          }

          let bounds = this.getBounds(false, rect);

          this.parent = parentRef;
          this.transform = transformRef;

          return bounds;
        };

        /**
         * Calculates the global position of the display object
         *
         * @param {PIXI.Point} position - The world origin to calculate from
         * @param {PIXI.Point} [point] - A Point object in which to store the value, optional
         *  (otherwise will create a new Point)
         * @param {boolean} [skipUpdate=false] - Should we skip the update transform.
         * @return {PIXI.Point} A point object representing the position of this object
         */

        DisplayObject.prototype.toGlobal = function toGlobal(position, point) {
          let skipUpdate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

          if (!skipUpdate) {
            this._recursivePostUpdateTransform();

            // this parent check is for just in case the item is a root object.
            // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly
            // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)
            if (!this.parent) {
              this.parent = this._tempDisplayObjectParent;
              this.displayObjectUpdateTransform();
              this.parent = null;
            } else {
              this.displayObjectUpdateTransform();
            }
          }

          // don't need to update the lot
          return this.worldTransform.apply(position, point);
        };

        /**
         * Calculates the local position of the display object relative to another point
         *
         * @param {PIXI.Point} position - The world origin to calculate from
         * @param {PIXI.DisplayObject} [from] - The DisplayObject to calculate the global position from
         * @param {PIXI.Point} [point] - A Point object in which to store the value, optional
         *  (otherwise will create a new Point)
         * @param {boolean} [skipUpdate=false] - Should we skip the update transform
         * @return {PIXI.Point} A point object representing the position of this object
         */

        DisplayObject.prototype.toLocal = function toLocal(position, from, point, skipUpdate) {
          if (from) {
            position = from.toGlobal(position, point, skipUpdate);
          }

          if (!skipUpdate) {
            this._recursivePostUpdateTransform();

            // this parent check is for just in case the item is a root object.
            // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly
            // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)
            if (!this.parent) {
              this.parent = this._tempDisplayObjectParent;
              this.displayObjectUpdateTransform();
              this.parent = null;
            } else {
              this.displayObjectUpdateTransform();
            }
          }

          // simply apply the matrix..
          return this.worldTransform.applyInverse(position, point);
        };

        /**
         * Renders the object using the WebGL renderer
         *
         * @param {PIXI.WebGLRenderer} renderer - The renderer
         */

        DisplayObject.prototype.renderWebGL = function renderWebGL(
          renderer // eslint-disable-line no-unused-vars
        ) {};
        // OVERWRITE;

        /**
         * Renders the object using the Canvas renderer
         *
         * @param {PIXI.CanvasRenderer} renderer - The renderer
         */

        DisplayObject.prototype.renderCanvas = function renderCanvas(
          renderer // eslint-disable-line no-unused-vars
        ) {};
        // OVERWRITE;

        /**
         * Set the parent Container of this DisplayObject
         *
         * @param {PIXI.Container} container - The Container to add this DisplayObject to
         * @return {PIXI.Container} The Container that this DisplayObject was added to
         */

        DisplayObject.prototype.setParent = function setParent(container) {
          if (!container || !container.addChild) {
            throw new Error("setParent: Argument must be a Container");
          }

          container.addChild(this);

          return container;
        };

        /**
         * Convenience function to set the position, scale, skew and pivot at once.
         *
         * @param {number} [x=0] - The X position
         * @param {number} [y=0] - The Y position
         * @param {number} [scaleX=1] - The X scale value
         * @param {number} [scaleY=1] - The Y scale value
         * @param {number} [rotation=0] - The rotation
         * @param {number} [skewX=0] - The X skew value
         * @param {number} [skewY=0] - The Y skew value
         * @param {number} [pivotX=0] - The X pivot value
         * @param {number} [pivotY=0] - The Y pivot value
         * @return {PIXI.DisplayObject} The DisplayObject instance
         */

        DisplayObject.prototype.setTransform = function setTransform() {
          let x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
          let y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          let scaleX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
          let scaleY = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
          let rotation = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
          let skewX = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
          let skewY = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
          let pivotX = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
          let pivotY = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;

          this.position.x = x;
          this.position.y = y;
          this.scale.x = !scaleX ? 1 : scaleX;
          this.scale.y = !scaleY ? 1 : scaleY;
          this.rotation = rotation;
          this.skew.x = skewX;
          this.skew.y = skewY;
          this.pivot.x = pivotX;
          this.pivot.y = pivotY;

          return this;
        };

        /**
         * Base destroy method for generic display objects. This will automatically
         * remove the display object from its parent Container as well as remove
         * all current event listeners and internal references. Do not use a DisplayObject
         * after calling `destroy`.
         *
         */

        DisplayObject.prototype.destroy = function destroy() {
          this.removeAllListeners();
          if (this.parent) {
            this.parent.removeChild(this);
          }
          this.transform = null;

          this.parent = null;

          this._bounds = null;
          this._currentBounds = null;
          this._mask = null;

          this.filterArea = null;

          this.interactive = false;
          this.interactiveChildren = false;

          this._destroyed = true;
        };

        /**
         * The position of the displayObject on the x axis relative to the local coordinates of the parent.
         * An alias to position.x
         *
         * @member {number}
         */

        _createClass(DisplayObject, [
          {
            key: "_tempDisplayObjectParent",
            get: function get() {
              if (this.tempDisplayObjectParent === null) {
                this.tempDisplayObjectParent = new DisplayObject();
              }

              return this.tempDisplayObjectParent;
            },
          },
          {
            key: "x",
            get: function get() {
              return this.position.x;
            },
            set: function set(
              value // eslint-disable-line require-jsdoc
            ) {
              this.transform.position.x = value;
            },

            /**
             * The position of the displayObject on the y axis relative to the local coordinates of the parent.
             * An alias to position.y
             *
             * @member {number}
             */
          },
          {
            key: "y",
            get: function get() {
              return this.position.y;
            },
            set: function set(
              value // eslint-disable-line require-jsdoc
            ) {
              this.transform.position.y = value;
            },

            /**
             * Current transform of the object based on world (parent) factors
             *
             * @member {PIXI.Matrix}
             * @readonly
             */
          },
          {
            key: "worldTransform",
            get: function get() {
              return this.transform.worldTransform;
            },

            /**
             * Current transform of the object based on local factors: position, scale, other stuff
             *
             * @member {PIXI.Matrix}
             * @readonly
             */
          },
          {
            key: "localTransform",
            get: function get() {
              return this.transform.localTransform;
            },

            /**
             * The coordinate of the object relative to the local coordinates of the parent.
             * Assignment by value since pixi-v4.
             *
             * @member {PIXI.Point|PIXI.ObservablePoint}
             */
          },
          {
            key: "position",
            get: function get() {
              return this.transform.position;
            },
            set: function set(
              value // eslint-disable-line require-jsdoc
            ) {
              this.transform.position.copy(value);
            },

            /**
             * The scale factor of the object.
             * Assignment by value since pixi-v4.
             *
             * @member {PIXI.Point|PIXI.ObservablePoint}
             */
          },
          {
            key: "scale",
            get: function get() {
              return this.transform.scale;
            },
            set: function set(
              value // eslint-disable-line require-jsdoc
            ) {
              this.transform.scale.copy(value);
            },

            /**
             * The pivot point of the displayObject that it rotates around.
             * Assignment by value since pixi-v4.
             *
             * @member {PIXI.Point|PIXI.ObservablePoint}
             */
          },
          {
            key: "pivot",
            get: function get() {
              return this.transform.pivot;
            },
            set: function set(
              value // eslint-disable-line require-jsdoc
            ) {
              this.transform.pivot.copy(value);
            },

            /**
             * The skew factor for the object in radians.
             * Assignment by value since pixi-v4.
             *
             * @member {PIXI.ObservablePoint}
             */
          },
          {
            key: "skew",
            get: function get() {
              return this.transform.skew;
            },
            set: function set(
              value // eslint-disable-line require-jsdoc
            ) {
              this.transform.skew.copy(value);
            },

            /**
             * The rotation of the object in radians.
             *
             * @member {number}
             */
          },
          {
            key: "rotation",
            get: function get() {
              return this.transform.rotation;
            },
            set: function set(
              value // eslint-disable-line require-jsdoc
            ) {
              this.transform.rotation = value;
            },

            /**
             * Indicates if the object is globally visible.
             *
             * @member {boolean}
             * @readonly
             */
          },
          {
            key: "worldVisible",
            get: function get() {
              let item = this;

              do {
                if (!item.visible) {
                  return false;
                }

                item = item.parent;
              } while (item);

              return true;
            },

            /**
             * Sets a mask for the displayObject. A mask is an object that limits the visibility of an
             * object to the shape of the mask applied to it. In PIXI a regular mask must be a
             * PIXI.Graphics or a PIXI.Sprite object. This allows for much faster masking in canvas as it
             * utilises shape clipping. To remove a mask, set this property to null.
             *
             * @todo For the moment, PIXI.CanvasRenderer doesn't support PIXI.Sprite as mask.
             *
             * @member {PIXI.Graphics|PIXI.Sprite}
             */
          },
          {
            key: "mask",
            get: function get() {
              return this._mask;
            },
            set: function set(
              value // eslint-disable-line require-jsdoc
            ) {
              if (this._mask) {
                this._mask.renderable = true;
                this._mask.isMask = false;
              }

              this._mask = value;

              if (this._mask) {
                this._mask.renderable = false;
                this._mask.isMask = true;
              }
            },

            /**
             * Sets the filters for the displayObject.
             * * IMPORTANT: This is a webGL only feature and will be ignored by the canvas renderer.
             * To remove filters simply set this property to 'null'
             *
             * @member {PIXI.Filter[]}
             */
          },
          {
            key: "filters",
            get: function get() {
              return this._filters && this._filters.slice();
            },
            set: function set(
              value // eslint-disable-line require-jsdoc
            ) {
              this._filters = value && value.slice();
            },
          },
        ]);

        return DisplayObject;
      })(_eventemitter2.default);

      // performance increase to avoid using call.. (10x faster)

      exports.default = DisplayObject;
      DisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;
      //# sourceMappingURL=DisplayObject.js.map

      /***/
    },
    /* 405 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      let _createClass = (function () {
        function defineProperties(target, props) {
          for (let i = 0; i < props.length; i++) {
            let descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      })();

      let _math = __webpack_require__(348);

      let _TransformBase2 = __webpack_require__(379);

      let _TransformBase3 = _interopRequireDefault(_TransformBase2);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: { value: subClass, enumerable: false, writable: true, configurable: true },
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass);
      }

      /**
       * Transform that takes care about its versions
       *
       * @class
       * @extends PIXI.TransformBase
       * @memberof PIXI
       */
      let TransformStatic = (function (_TransformBase) {
        _inherits(TransformStatic, _TransformBase);

        /**
         *
         */
        function TransformStatic() {
          _classCallCheck(this, TransformStatic);

          /**
           * The coordinate of the object relative to the local coordinates of the parent.
           *
           * @member {PIXI.ObservablePoint}
           */
          let _this = _possibleConstructorReturn(this, _TransformBase.call(this));

          _this.position = new _math.ObservablePoint(_this.onChange, _this, 0, 0);

          /**
           * The scale factor of the object.
           *
           * @member {PIXI.ObservablePoint}
           */
          _this.scale = new _math.ObservablePoint(_this.onChange, _this, 1, 1);

          /**
           * The pivot point of the displayObject that it rotates around.
           *
           * @member {PIXI.ObservablePoint}
           */
          _this.pivot = new _math.ObservablePoint(_this.onChange, _this, 0, 0);

          /**
           * The skew amount, on the x and y axis.
           *
           * @member {PIXI.ObservablePoint}
           */
          _this.skew = new _math.ObservablePoint(_this.updateSkew, _this, 0, 0);

          _this._rotation = 0;

          _this._cx = 1; // cos rotation + skewY;
          _this._sx = 0; // sin rotation + skewY;
          _this._cy = 0; // cos rotation + Math.PI/2 - skewX;
          _this._sy = 1; // sin rotation + Math.PI/2 - skewX;

          _this._localID = 0;
          _this._currentLocalID = 0;
          return _this;
        }

        /**
         * Called when a value changes.
         *
         * @private
         */

        TransformStatic.prototype.onChange = function onChange() {
          this._localID++;
        };

        /**
         * Called when skew or rotation changes
         *
         * @private
         */

        TransformStatic.prototype.updateSkew = function updateSkew() {
          this._cx = Math.cos(this._rotation + this.skew._y);
          this._sx = Math.sin(this._rotation + this.skew._y);
          this._cy = -Math.sin(this._rotation - this.skew._x); // cos, added PI/2
          this._sy = Math.cos(this._rotation - this.skew._x); // sin, added PI/2

          this._localID++;
        };

        /**
         * Updates only local matrix
         */

        TransformStatic.prototype.updateLocalTransform = function updateLocalTransform() {
          let lt = this.localTransform;

          if (this._localID !== this._currentLocalID) {
            // get the matrix values of the displayobject based on its transform properties..
            lt.a = this._cx * this.scale._x;
            lt.b = this._sx * this.scale._x;
            lt.c = this._cy * this.scale._y;
            lt.d = this._sy * this.scale._y;

            lt.tx = this.position._x - (this.pivot._x * lt.a + this.pivot._y * lt.c);
            lt.ty = this.position._y - (this.pivot._x * lt.b + this.pivot._y * lt.d);
            this._currentLocalID = this._localID;

            // force an update..
            this._parentID = -1;
          }
        };

        /**
         * Updates the values of the object and applies the parent's transform.
         *
         * @param {PIXI.Transform} parentTransform - The transform of the parent of this object
         */

        TransformStatic.prototype.updateTransform = function updateTransform(parentTransform) {
          let lt = this.localTransform;

          if (this._localID !== this._currentLocalID) {
            // get the matrix values of the displayobject based on its transform properties..
            lt.a = this._cx * this.scale._x;
            lt.b = this._sx * this.scale._x;
            lt.c = this._cy * this.scale._y;
            lt.d = this._sy * this.scale._y;

            lt.tx = this.position._x - (this.pivot._x * lt.a + this.pivot._y * lt.c);
            lt.ty = this.position._y - (this.pivot._x * lt.b + this.pivot._y * lt.d);
            this._currentLocalID = this._localID;

            // force an update..
            this._parentID = -1;
          }

          if (this._parentID !== parentTransform._worldID) {
            // concat the parent matrix with the objects transform.
            let pt = parentTransform.worldTransform;
            let wt = this.worldTransform;

            wt.a = lt.a * pt.a + lt.b * pt.c;
            wt.b = lt.a * pt.b + lt.b * pt.d;
            wt.c = lt.c * pt.a + lt.d * pt.c;
            wt.d = lt.c * pt.b + lt.d * pt.d;
            wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
            wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;

            this._parentID = parentTransform._worldID;

            // update the id of the transform..
            this._worldID++;
          }
        };

        /**
         * Decomposes a matrix and sets the transforms properties based on it.
         *
         * @param {PIXI.Matrix} matrix - The matrix to decompose
         */

        TransformStatic.prototype.setFromMatrix = function setFromMatrix(matrix) {
          matrix.decompose(this);
          this._localID++;
        };

        /**
         * The rotation of the object in radians.
         *
         * @member {number}
         */

        _createClass(TransformStatic, [
          {
            key: "rotation",
            get: function get() {
              return this._rotation;
            },
            set: function set(
              value // eslint-disable-line require-jsdoc
            ) {
              if (this._rotation !== value) {
                this._rotation = value;
                this.updateSkew();
              }
            },
          },
        ]);

        return TransformStatic;
      })(_TransformBase3.default);

      exports.default = TransformStatic;
      //# sourceMappingURL=TransformStatic.js.map

      /***/
    },
    /* 406 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      let _createClass = (function () {
        function defineProperties(target, props) {
          for (let i = 0; i < props.length; i++) {
            let descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      })();

      let _math = __webpack_require__(348);

      let _TransformBase2 = __webpack_require__(379);

      let _TransformBase3 = _interopRequireDefault(_TransformBase2);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: { value: subClass, enumerable: false, writable: true, configurable: true },
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass);
      }

      /**
       * Generic class to deal with traditional 2D matrix transforms
       * local transformation is calculated from position,scale,skew and rotation
       *
       * @class
       * @extends PIXI.TransformBase
       * @memberof PIXI
       */
      let Transform = (function (_TransformBase) {
        _inherits(Transform, _TransformBase);

        /**
         *
         */
        function Transform() {
          _classCallCheck(this, Transform);

          /**
           * The coordinate of the object relative to the local coordinates of the parent.
           *
           * @member {PIXI.Point}
           */
          let _this = _possibleConstructorReturn(this, _TransformBase.call(this));

          _this.position = new _math.Point(0, 0);

          /**
           * The scale factor of the object.
           *
           * @member {PIXI.Point}
           */
          _this.scale = new _math.Point(1, 1);

          /**
           * The skew amount, on the x and y axis.
           *
           * @member {PIXI.ObservablePoint}
           */
          _this.skew = new _math.ObservablePoint(_this.updateSkew, _this, 0, 0);

          /**
           * The pivot point of the displayObject that it rotates around.
           *
           * @member {PIXI.Point}
           */
          _this.pivot = new _math.Point(0, 0);

          /**
           * The rotation value of the object, in radians
           *
           * @member {Number}
           * @private
           */
          _this._rotation = 0;

          _this._cx = 1; // cos rotation + skewY;
          _this._sx = 0; // sin rotation + skewY;
          _this._cy = 0; // cos rotation + Math.PI/2 - skewX;
          _this._sy = 1; // sin rotation + Math.PI/2 - skewX;
          return _this;
        }

        /**
         * Updates the skew values when the skew or rotation changes.
         *
         * @private
         */

        Transform.prototype.updateSkew = function updateSkew() {
          this._cx = Math.cos(this._rotation + this.skew._y);
          this._sx = Math.sin(this._rotation + this.skew._y);
          this._cy = -Math.sin(this._rotation - this.skew._x); // cos, added PI/2
          this._sy = Math.cos(this._rotation - this.skew._x); // sin, added PI/2
        };

        /**
         * Updates only local matrix
         */

        Transform.prototype.updateLocalTransform = function updateLocalTransform() {
          let lt = this.localTransform;

          lt.a = this._cx * this.scale.x;
          lt.b = this._sx * this.scale.x;
          lt.c = this._cy * this.scale.y;
          lt.d = this._sy * this.scale.y;

          lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
          lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
        };

        /**
         * Updates the values of the object and applies the parent's transform.
         *
         * @param {PIXI.Transform} parentTransform - The transform of the parent of this object
         */

        Transform.prototype.updateTransform = function updateTransform(parentTransform) {
          let lt = this.localTransform;

          lt.a = this._cx * this.scale.x;
          lt.b = this._sx * this.scale.x;
          lt.c = this._cy * this.scale.y;
          lt.d = this._sy * this.scale.y;

          lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
          lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);

          // concat the parent matrix with the objects transform.
          let pt = parentTransform.worldTransform;
          let wt = this.worldTransform;

          wt.a = lt.a * pt.a + lt.b * pt.c;
          wt.b = lt.a * pt.b + lt.b * pt.d;
          wt.c = lt.c * pt.a + lt.d * pt.c;
          wt.d = lt.c * pt.b + lt.d * pt.d;
          wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
          wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;

          this._worldID++;
        };

        /**
         * Decomposes a matrix and sets the transforms properties based on it.
         *
         * @param {PIXI.Matrix} matrix - The matrix to decompose
         */

        Transform.prototype.setFromMatrix = function setFromMatrix(matrix) {
          matrix.decompose(this);
        };

        /**
         * The rotation of the object in radians.
         *
         * @member {number}
         */

        _createClass(Transform, [
          {
            key: "rotation",
            get: function get() {
              return this._rotation;
            },
            set: function set(
              value // eslint-disable-line require-jsdoc
            ) {
              this._rotation = value;
              this.updateSkew();
            },
          },
        ]);

        return Transform;
      })(_TransformBase3.default);

      exports.default = Transform;
      //# sourceMappingURL=Transform.js.map

      /***/
    },
    /* 407 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;
      exports.default = determineCrossOrigin;

      let _url2 = __webpack_require__(408);

      let _url3 = _interopRequireDefault(_url2);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      let tempAnchor = void 0;

      /**
       * Sets the `crossOrigin` property for this resource based on if the url
       * for this resource is cross-origin. If crossOrigin was manually set, this
       * function does nothing.
       * Nipped from the resource loader!
       *
       * @ignore
       * @param {string} url - The url to test.
       * @param {object} [loc=window.location] - The location object to test against.
       * @return {string} The crossOrigin value to use (or empty string for none).
       */
      function determineCrossOrigin(url) {
        let loc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window.location;

        // data: and javascript: urls are considered same-origin
        if (url.indexOf("data:") === 0) {
          return "";
        }

        // default is window.location
        loc = loc || window.location;

        if (!tempAnchor) {
          tempAnchor = document.createElement("a");
        }

        // let the browser determine the full href for the url of this resource and then
        // parse with the node url lib, we can't use the properties of the anchor element
        // because they don't work in IE9 :(
        tempAnchor.href = url;
        url = _url3.default.parse(tempAnchor.href);

        let samePort = (!url.port && loc.port === "") || url.port === loc.port;

        // if cross origin
        if (url.hostname !== loc.hostname || !samePort || url.protocol !== loc.protocol) {
          return "anonymous";
        }

        return "";
      }
      //# sourceMappingURL=determineCrossOrigin.js.map

      /***/
    },
    /* 408 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";
      // Copyright Joyent, Inc. and other Node contributors.
      //
      // Permission is hereby granted, free of charge, to any person obtaining a
      // copy of this software and associated documentation files (the
      // "Software"), to deal in the Software without restriction, including
      // without limitation the rights to use, copy, modify, merge, publish,
      // distribute, sublicense, and/or sell copies of the Software, and to permit
      // persons to whom the Software is furnished to do so, subject to the
      // following conditions:
      //
      // The above copyright notice and this permission notice shall be included
      // in all copies or substantial portions of the Software.
      //
      // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
      // USE OR OTHER DEALINGS IN THE SOFTWARE.

      let punycode = __webpack_require__(492);
      let util = __webpack_require__(494);

      exports.parse = urlParse;
      exports.resolve = urlResolve;
      exports.resolveObject = urlResolveObject;
      exports.format = urlFormat;

      exports.Url = Url;

      function Url() {
        this.protocol = null;
        this.slashes = null;
        this.auth = null;
        this.host = null;
        this.port = null;
        this.hostname = null;
        this.hash = null;
        this.search = null;
        this.query = null;
        this.pathname = null;
        this.path = null;
        this.href = null;
      }

      // Reference: RFC 3986, RFC 1808, RFC 2396

      // define these here so at least they only have to be
      // compiled once on the first module load.
      let protocolPattern = /^([a-z0-9.+-]+:)/i,
        portPattern = /:[0-9]*$/,
        // Special case for a simple path URL
        simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
        // RFC 2396: characters reserved for delimiting URLs.
        // We actually just auto-escape these.
        delims = ["<", ">", '"', "`", " ", "\r", "\n", "\t"],
        // RFC 2396: characters not allowed for various reasons.
        unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims),
        // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
        autoEscape = ["'"].concat(unwise),
        // Characters that are never ever allowed in a hostname.
        // Note that any invalid chars are also handled, but these
        // are the ones that are *expected* to be seen, so we fast-path
        // them.
        nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape),
        hostEndingChars = ["/", "?", "#"],
        hostnameMaxLen = 255,
        hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
        hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
        // protocols that can allow "unsafe" and "unwise" chars.
        unsafeProtocol = {
          javascript: true,
          "javascript:": true,
        },
        // protocols that never have a hostname.
        hostlessProtocol = {
          javascript: true,
          "javascript:": true,
        },
        // protocols that always contain a // bit.
        slashedProtocol = {
          http: true,
          https: true,
          ftp: true,
          gopher: true,
          file: true,
          "http:": true,
          "https:": true,
          "ftp:": true,
          "gopher:": true,
          "file:": true,
        },
        querystring = __webpack_require__(495);

      function urlParse(url, parseQueryString, slashesDenoteHost) {
        if (url && util.isObject(url) && url instanceof Url) return url;

        let u = new Url();
        u.parse(url, parseQueryString, slashesDenoteHost);
        return u;
      }

      Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
        if (!util.isString(url)) {
          throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
        }

        // Copy chrome, IE, opera backslash-handling behavior.
        // Back slashes before the query string get converted to forward slashes
        // See: https://code.google.com/p/chromium/issues/detail?id=25916
        let queryIndex = url.indexOf("?"),
          splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#",
          uSplit = url.split(splitter),
          slashRegex = /\\/g;
        uSplit[0] = uSplit[0].replace(slashRegex, "/");
        url = uSplit.join(splitter);

        let rest = url;

        // trim before proceeding.
        // This is to support parse stuff like "  http://foo.com  \n"
        rest = rest.trim();

        if (!slashesDenoteHost && url.split("#").length === 1) {
          // Try fast path regexp
          let simplePath = simplePathPattern.exec(rest);
          if (simplePath) {
            this.path = rest;
            this.href = rest;
            this.pathname = simplePath[1];
            if (simplePath[2]) {
              this.search = simplePath[2];
              if (parseQueryString) {
                this.query = querystring.parse(this.search.substr(1));
              } else {
                this.query = this.search.substr(1);
              }
            } else if (parseQueryString) {
              this.search = "";
              this.query = {};
            }
            return this;
          }
        }

        let proto = protocolPattern.exec(rest);
        if (proto) {
          proto = proto[0];
          var lowerProto = proto.toLowerCase();
          this.protocol = lowerProto;
          rest = rest.substr(proto.length);
        }

        // figure out if it's got a host
        // user@server is *always* interpreted as a hostname, and url
        // resolution will treat //foo/bar as host=foo,path=bar because that's
        // how the browser resolves relative URLs.
        if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
          var slashes = rest.substr(0, 2) === "//";
          if (slashes && !(proto && hostlessProtocol[proto])) {
            rest = rest.substr(2);
            this.slashes = true;
          }
        }

        if (!hostlessProtocol[proto] && (slashes || (proto && !slashedProtocol[proto]))) {
          // there's a hostname.
          // the first instance of /, ?, ;, or # ends the host.
          //
          // If there is an @ in the hostname, then non-host chars *are* allowed
          // to the left of the last @ sign, unless some host-ending character
          // comes *before* the @-sign.
          // URLs are obnoxious.
          //
          // ex:
          // http://a@b@c/ => user:a@b host:c
          // http://a@b?@c => user:a host:c path:/?@c

          // v0.12 TODO(isaacs): This is not quite how Chrome does things.
          // Review our test case against browsers more comprehensively.

          // find the first instance of any hostEndingChars
          let hostEnd = -1;
          for (var i = 0; i < hostEndingChars.length; i++) {
            var hec = rest.indexOf(hostEndingChars[i]);
            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
          }

          // at this point, either we have an explicit point where the
          // auth portion cannot go past, or the last @ char is the decider.
          let auth, atSign;
          if (hostEnd === -1) {
            // atSign can be anywhere.
            atSign = rest.lastIndexOf("@");
          } else {
            // atSign must be in auth portion.
            // http://a@b/c@d => host:b auth:a path:/c@d
            atSign = rest.lastIndexOf("@", hostEnd);
          }

          // Now we have a portion which is definitely the auth.
          // Pull that off.
          if (atSign !== -1) {
            auth = rest.slice(0, atSign);
            rest = rest.slice(atSign + 1);
            this.auth = decodeURIComponent(auth);
          }

          // the host is the remaining to the left of the first non-host char
          hostEnd = -1;
          for (var i = 0; i < nonHostChars.length; i++) {
            var hec = rest.indexOf(nonHostChars[i]);
            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
          }
          // if we still have not hit it, then the entire thing is a host.
          if (hostEnd === -1) hostEnd = rest.length;

          this.host = rest.slice(0, hostEnd);
          rest = rest.slice(hostEnd);

          // pull out port.
          this.parseHost();

          // we've indicated that there is a hostname,
          // so even if it's empty, it has to be present.
          this.hostname = this.hostname || "";

          // if hostname begins with [ and ends with ]
          // assume that it's an IPv6 address.
          let ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";

          // validate a little.
          if (!ipv6Hostname) {
            let hostparts = this.hostname.split(/\./);
            for (var i = 0, l = hostparts.length; i < l; i++) {
              let part = hostparts[i];
              if (!part) continue;
              if (!part.match(hostnamePartPattern)) {
                let newpart = "";
                for (let j = 0, k = part.length; j < k; j++) {
                  if (part.charCodeAt(j) > 127) {
                    // we replace non-ASCII char with a temporary placeholder
                    // we need this to make sure size of hostname is not
                    // broken by replacing non-ASCII by nothing
                    newpart += "x";
                  } else {
                    newpart += part[j];
                  }
                }
                // we test again with ASCII char only
                if (!newpart.match(hostnamePartPattern)) {
                  let validParts = hostparts.slice(0, i);
                  let notHost = hostparts.slice(i + 1);
                  let bit = part.match(hostnamePartStart);
                  if (bit) {
                    validParts.push(bit[1]);
                    notHost.unshift(bit[2]);
                  }
                  if (notHost.length) {
                    rest = "/" + notHost.join(".") + rest;
                  }
                  this.hostname = validParts.join(".");
                  break;
                }
              }
            }
          }

          if (this.hostname.length > hostnameMaxLen) {
            this.hostname = "";
          } else {
            // hostnames are always lower case.
            this.hostname = this.hostname.toLowerCase();
          }

          if (!ipv6Hostname) {
            // IDNA Support: Returns a punycoded representation of "domain".
            // It only converts parts of the domain name that
            // have non-ASCII characters, i.e. it doesn't matter if
            // you call it with a domain that already is ASCII-only.
            this.hostname = punycode.toASCII(this.hostname);
          }

          var p = this.port ? ":" + this.port : "";
          let h = this.hostname || "";
          this.host = h + p;
          this.href += this.host;

          // strip [ and ] from the hostname
          // the host field still retains them, though
          if (ipv6Hostname) {
            this.hostname = this.hostname.substr(1, this.hostname.length - 2);
            if (rest[0] !== "/") {
              rest = "/" + rest;
            }
          }
        }

        // now rest is set to the post-host stuff.
        // chop off any delim chars.
        if (!unsafeProtocol[lowerProto]) {
          // First, make 100% sure that any "autoEscape" chars get
          // escaped, even if encodeURIComponent doesn't think they
          // need to be.
          for (var i = 0, l = autoEscape.length; i < l; i++) {
            let ae = autoEscape[i];
            if (rest.indexOf(ae) === -1) continue;
            let esc = encodeURIComponent(ae);
            if (esc === ae) {
              esc = escape(ae);
            }
            rest = rest.split(ae).join(esc);
          }
        }

        // chop off from the tail first.
        let hash = rest.indexOf("#");
        if (hash !== -1) {
          // got a fragment string.
          this.hash = rest.substr(hash);
          rest = rest.slice(0, hash);
        }
        let qm = rest.indexOf("?");
        if (qm !== -1) {
          this.search = rest.substr(qm);
          this.query = rest.substr(qm + 1);
          if (parseQueryString) {
            this.query = querystring.parse(this.query);
          }
          rest = rest.slice(0, qm);
        } else if (parseQueryString) {
          // no query string, but parseQueryString still requested
          this.search = "";
          this.query = {};
        }
        if (rest) this.pathname = rest;
        if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
          this.pathname = "/";
        }

        //to support http.request
        if (this.pathname || this.search) {
          var p = this.pathname || "";
          let s = this.search || "";
          this.path = p + s;
        }

        // finally, reconstruct the href based on what has been validated.
        this.href = this.format();
        return this;
      };

      // format a parsed object into a url string
      function urlFormat(obj) {
        // ensure it's an object, and not a string url.
        // If it's an obj, this is a no-op.
        // this way, you can call url_format() on strings
        // to clean up potentially wonky urls.
        if (util.isString(obj)) obj = urlParse(obj);
        if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
        return obj.format();
      }

      Url.prototype.format = function () {
        let auth = this.auth || "";
        if (auth) {
          auth = encodeURIComponent(auth);
          auth = auth.replace(/%3A/i, ":");
          auth += "@";
        }

        let protocol = this.protocol || "",
          pathname = this.pathname || "",
          hash = this.hash || "",
          host = false,
          query = "";

        if (this.host) {
          host = auth + this.host;
        } else if (this.hostname) {
          host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
          if (this.port) {
            host += ":" + this.port;
          }
        }

        if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
          query = querystring.stringify(this.query);
        }

        let search = this.search || (query && "?" + query) || "";

        if (protocol && protocol.substr(-1) !== ":") protocol += ":";

        // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
        // unless they had them to begin with.
        if (this.slashes || ((!protocol || slashedProtocol[protocol]) && host !== false)) {
          host = "//" + (host || "");
          if (pathname && pathname.charAt(0) !== "/") pathname = "/" + pathname;
        } else if (!host) {
          host = "";
        }

        if (hash && hash.charAt(0) !== "#") hash = "#" + hash;
        if (search && search.charAt(0) !== "?") search = "?" + search;

        pathname = pathname.replace(/[?#]/g, function (match) {
          return encodeURIComponent(match);
        });
        search = search.replace("#", "%23");

        return protocol + host + pathname + search + hash;
      };

      function urlResolve(source, relative) {
        return urlParse(source, false, true).resolve(relative);
      }

      Url.prototype.resolve = function (relative) {
        return this.resolveObject(urlParse(relative, false, true)).format();
      };

      function urlResolveObject(source, relative) {
        if (!source) return relative;
        return urlParse(source, false, true).resolveObject(relative);
      }

      Url.prototype.resolveObject = function (relative) {
        if (util.isString(relative)) {
          let rel = new Url();
          rel.parse(relative, false, true);
          relative = rel;
        }

        let result = new Url();
        let tkeys = Object.keys(this);
        for (let tk = 0; tk < tkeys.length; tk++) {
          let tkey = tkeys[tk];
          result[tkey] = this[tkey];
        }

        // hash is always overridden, no matter what.
        // even href="" will remove it.
        result.hash = relative.hash;

        // if the relative url is empty, then there's nothing left to do here.
        if (relative.href === "") {
          result.href = result.format();
          return result;
        }

        // hrefs like //foo/bar always cut to the protocol.
        if (relative.slashes && !relative.protocol) {
          // take everything except the protocol from relative
          let rkeys = Object.keys(relative);
          for (let rk = 0; rk < rkeys.length; rk++) {
            let rkey = rkeys[rk];
            if (rkey !== "protocol") result[rkey] = relative[rkey];
          }

          //urlParse appends trailing / to urls like http://www.example.com
          if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
            result.path = result.pathname = "/";
          }

          result.href = result.format();
          return result;
        }

        if (relative.protocol && relative.protocol !== result.protocol) {
          // if it's a known url protocol, then changing
          // the protocol does weird things
          // first, if it's not file:, then we MUST have a host,
          // and if there was a path
          // to begin with, then we MUST have a path.
          // if it is file:, then the host is dropped,
          // because that's known to be hostless.
          // anything else is assumed to be absolute.
          if (!slashedProtocol[relative.protocol]) {
            let keys = Object.keys(relative);
            for (let v = 0; v < keys.length; v++) {
              let k = keys[v];
              result[k] = relative[k];
            }
            result.href = result.format();
            return result;
          }

          result.protocol = relative.protocol;
          if (!relative.host && !hostlessProtocol[relative.protocol]) {
            var relPath = (relative.pathname || "").split("/");
            while (relPath.length && !(relative.host = relPath.shift()));
            if (!relative.host) relative.host = "";
            if (!relative.hostname) relative.hostname = "";
            if (relPath[0] !== "") relPath.unshift("");
            if (relPath.length < 2) relPath.unshift("");
            result.pathname = relPath.join("/");
          } else {
            result.pathname = relative.pathname;
          }
          result.search = relative.search;
          result.query = relative.query;
          result.host = relative.host || "";
          result.auth = relative.auth;
          result.hostname = relative.hostname || relative.host;
          result.port = relative.port;
          // to support http.request
          if (result.pathname || result.search) {
            let p = result.pathname || "";
            let s = result.search || "";
            result.path = p + s;
          }
          result.slashes = result.slashes || relative.slashes;
          result.href = result.format();
          return result;
        }

        var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/",
          isRelAbs = relative.host || (relative.pathname && relative.pathname.charAt(0) === "/"),
          mustEndAbs = isRelAbs || isSourceAbs || (result.host && relative.pathname),
          removeAllDots = mustEndAbs,
          srcPath = (result.pathname && result.pathname.split("/")) || [],
          relPath = (relative.pathname && relative.pathname.split("/")) || [],
          psychotic = result.protocol && !slashedProtocol[result.protocol];

        // if the url is a non-slashed url, then relative
        // links like ../.. should be able
        // to crawl up to the hostname, as well.  This is strange.
        // result.protocol has already been set by now.
        // Later on, put the first path part into the host field.
        if (psychotic) {
          result.hostname = "";
          result.port = null;
          if (result.host) {
            if (srcPath[0] === "") srcPath[0] = result.host;
            else srcPath.unshift(result.host);
          }
          result.host = "";
          if (relative.protocol) {
            relative.hostname = null;
            relative.port = null;
            if (relative.host) {
              if (relPath[0] === "") relPath[0] = relative.host;
              else relPath.unshift(relative.host);
            }
            relative.host = null;
          }
          mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
        }

        if (isRelAbs) {
          // it's absolute.
          result.host = relative.host || relative.host === "" ? relative.host : result.host;
          result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
          result.search = relative.search;
          result.query = relative.query;
          srcPath = relPath;
          // fall through to the dot-handling below.
        } else if (relPath.length) {
          // it's relative
          // throw away the existing file, and take the new path instead.
          if (!srcPath) srcPath = [];
          srcPath.pop();
          srcPath = srcPath.concat(relPath);
          result.search = relative.search;
          result.query = relative.query;
        } else if (!util.isNullOrUndefined(relative.search)) {
          // just pull out the search.
          // like href='?foo'.
          // Put this after the other two cases because it simplifies the booleans
          if (psychotic) {
            result.hostname = result.host = srcPath.shift();
            //occationaly the auth can get stuck only in host
            //this especially happens in cases like
            //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
            var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
            if (authInHost) {
              result.auth = authInHost.shift();
              result.host = result.hostname = authInHost.shift();
            }
          }
          result.search = relative.search;
          result.query = relative.query;
          //to support http.request
          if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
            result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
          }
          result.href = result.format();
          return result;
        }

        if (!srcPath.length) {
          // no path at all.  easy.
          // we've already handled the other stuff above.
          result.pathname = null;
          //to support http.request
          if (result.search) {
            result.path = "/" + result.search;
          } else {
            result.path = null;
          }
          result.href = result.format();
          return result;
        }

        // if a url ENDs in . or .., then it must get a trailing slash.
        // however, if it ends in anything else non-slashy,
        // then it must NOT get a trailing slash.
        let last = srcPath.slice(-1)[0];
        let hasTrailingSlash = ((result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..")) || last === "";

        // strip single dots, resolve double dots to parent dir
        // if the path tries to go above the root, `up` ends up > 0
        let up = 0;
        for (let i = srcPath.length; i >= 0; i--) {
          last = srcPath[i];
          if (last === ".") {
            srcPath.splice(i, 1);
          } else if (last === "..") {
            srcPath.splice(i, 1);
            up++;
          } else if (up) {
            srcPath.splice(i, 1);
            up--;
          }
        }

        // if the path is allowed to go above the root, restore leading ..s
        if (!mustEndAbs && !removeAllDots) {
          for (; up--; up) {
            srcPath.unshift("..");
          }
        }

        if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
          srcPath.unshift("");
        }

        if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
          srcPath.push("");
        }

        let isAbsolute = srcPath[0] === "" || (srcPath[0] && srcPath[0].charAt(0) === "/");

        // put the host back
        if (psychotic) {
          result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
          //occationaly the auth can get stuck only in host
          //this especially happens in cases like
          //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
          var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
          if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
          }
        }

        mustEndAbs = mustEndAbs || (result.host && srcPath.length);

        if (mustEndAbs && !isAbsolute) {
          srcPath.unshift("");
        }

        if (!srcPath.length) {
          result.pathname = null;
          result.path = null;
        } else {
          result.pathname = srcPath.join("/");
        }

        //to support request.http
        if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
          result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
        }
        result.auth = relative.auth || result.auth;
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
      };

      Url.prototype.parseHost = function () {
        let host = this.host;
        let port = portPattern.exec(host);
        if (port) {
          port = port[0];
          if (port !== ":") {
            this.port = port.substr(1);
          }
          host = host.substr(0, host.length - port.length);
        }
        if (host) this.hostname = host;
      };

      /***/
    },
    /* 409 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      let _createClass = (function () {
        function defineProperties(target, props) {
          for (let i = 0; i < props.length; i++) {
            let descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      })();

      let _BaseTexture2 = __webpack_require__(355);

      let _BaseTexture3 = _interopRequireDefault(_BaseTexture2);

      let _utils = __webpack_require__(345);

      let _ticker = __webpack_require__(383);

      let _const = __webpack_require__(343);

      let _determineCrossOrigin = __webpack_require__(407);

      let _determineCrossOrigin2 = _interopRequireDefault(_determineCrossOrigin);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: { value: subClass, enumerable: false, writable: true, configurable: true },
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass);
      }

      /**
       * A texture of a [playing] Video.
       *
       * Video base textures mimic PixiJS BaseTexture.from.... method in their creation process.
       *
       * This can be used in several ways, such as:
       *
       * ```js
       * let texture = PIXI.VideoBaseTexture.fromUrl('http://mydomain.com/video.mp4');
       *
       * let texture = PIXI.VideoBaseTexture.fromUrl({ src: 'http://mydomain.com/video.mp4', mime: 'video/mp4' });
       *
       * let texture = PIXI.VideoBaseTexture.fromUrls(['/video.webm', '/video.mp4']);
       *
       * let texture = PIXI.VideoBaseTexture.fromUrls([
       *     { src: '/video.webm', mime: 'video/webm' },
       *     { src: '/video.mp4', mime: 'video/mp4' }
       * ]);
       * ```
       *
       * See the ["deus" demo](http://www.goodboydigital.com/pixijs/examples/deus/).
       *
       * @class
       * @extends PIXI.BaseTexture
       * @memberof PIXI
       */
      let VideoBaseTexture = (function (_BaseTexture) {
        _inherits(VideoBaseTexture, _BaseTexture);

        /**
         * @param {HTMLVideoElement} source - Video source
         * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
         * @param {boolean} [autoPlay=true] - Start playing video as soon as it is loaded
         */
        function VideoBaseTexture(source, scaleMode) {
          let autoPlay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

          _classCallCheck(this, VideoBaseTexture);

          if (!source) {
            throw new Error("No video source element specified.");
          }

          // hook in here to check if video is already available.
          // BaseTexture looks for a source.complete boolean, plus width & height.

          if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {
            source.complete = true;
          }

          let _this = _possibleConstructorReturn(this, _BaseTexture.call(this, source, scaleMode));

          _this.width = source.videoWidth;
          _this.height = source.videoHeight;

          _this._autoUpdate = true;
          _this._isAutoUpdating = false;

          /**
           * When set to true will automatically play videos used by this texture once
           * they are loaded. If false, it will not modify the playing state.
           *
           * @member {boolean}
           * @default true
           */
          _this.autoPlay = autoPlay;

          _this.update = _this.update.bind(_this);
          _this._onCanPlay = _this._onCanPlay.bind(_this);

          source.addEventListener("play", _this._onPlayStart.bind(_this));
          source.addEventListener("pause", _this._onPlayStop.bind(_this));
          _this.hasLoaded = false;
          _this.__loaded = false;

          if (!_this._isSourceReady()) {
            source.addEventListener("canplay", _this._onCanPlay);
            source.addEventListener("canplaythrough", _this._onCanPlay);
          } else {
            _this._onCanPlay();
          }
          return _this;
        }

        /**
         * Returns true if the underlying source is playing.
         *
         * @private
         * @return {boolean} True if playing.
         */

        VideoBaseTexture.prototype._isSourcePlaying = function _isSourcePlaying() {
          let source = this.source;

          return source.currentTime > 0 && source.paused === false && source.ended === false && source.readyState > 2;
        };

        /**
         * Returns true if the underlying source is ready for playing.
         *
         * @private
         * @return {boolean} True if ready.
         */

        VideoBaseTexture.prototype._isSourceReady = function _isSourceReady() {
          return this.source.readyState === 3 || this.source.readyState === 4;
        };

        /**
         * Runs the update loop when the video is ready to play
         *
         * @private
         */

        VideoBaseTexture.prototype._onPlayStart = function _onPlayStart() {
          // Just in case the video has not received its can play even yet..
          if (!this.hasLoaded) {
            this._onCanPlay();
          }

          if (!this._isAutoUpdating && this.autoUpdate) {
            _ticker.shared.add(this.update, this, _const.UPDATE_PRIORITY.HIGH);
            this._isAutoUpdating = true;
          }
        };

        /**
         * Fired when a pause event is triggered, stops the update loop
         *
         * @private
         */

        VideoBaseTexture.prototype._onPlayStop = function _onPlayStop() {
          if (this._isAutoUpdating) {
            _ticker.shared.remove(this.update, this);
            this._isAutoUpdating = false;
          }
        };

        /**
         * Fired when the video is loaded and ready to play
         *
         * @private
         */

        VideoBaseTexture.prototype._onCanPlay = function _onCanPlay() {
          this.hasLoaded = true;

          if (this.source) {
            this.source.removeEventListener("canplay", this._onCanPlay);
            this.source.removeEventListener("canplaythrough", this._onCanPlay);

            this.width = this.source.videoWidth;
            this.height = this.source.videoHeight;

            // prevent multiple loaded dispatches..
            if (!this.__loaded) {
              this.__loaded = true;
              this.emit("loaded", this);
            }

            if (this._isSourcePlaying()) {
              this._onPlayStart();
            } else if (this.autoPlay) {
              this.source.play();
            }
          }
        };

        /**
         * Destroys this texture
         *
         */

        VideoBaseTexture.prototype.destroy = function destroy() {
          if (this._isAutoUpdating) {
            _ticker.shared.remove(this.update, this);
          }

          if (this.source && this.source._pixiId) {
            _BaseTexture3.default.removeFromCache(this.source._pixiId);
            delete this.source._pixiId;

            this.source.pause();
            this.source.src = "";
            this.source.load();
          }

          _BaseTexture.prototype.destroy.call(this);
        };

        /**
         * Mimic PixiJS BaseTexture.from.... method.
         *
         * @static
         * @param {HTMLVideoElement} video - Video to create texture from
         * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
         * @param {boolean} [autoPlay=true] - Start playing video as soon as it is loaded
         * @return {PIXI.VideoBaseTexture} Newly created VideoBaseTexture
         */

        VideoBaseTexture.fromVideo = function fromVideo(video, scaleMode, autoPlay) {
          if (!video._pixiId) {
            video._pixiId = "video_" + (0, _utils.uid)();
          }

          let baseTexture = _utils.BaseTextureCache[video._pixiId];

          if (!baseTexture) {
            baseTexture = new VideoBaseTexture(video, scaleMode, autoPlay);
            _BaseTexture3.default.addToCache(baseTexture, video._pixiId);
          }

          return baseTexture;
        };

        /**
         * Helper function that creates a new BaseTexture based on the given video element.
         * This BaseTexture can then be used to create a texture
         *
         * @static
         * @param {string|object|string[]|object[]} videoSrc - The URL(s) for the video.
         * @param {string} [videoSrc.src] - One of the source urls for the video
         * @param {string} [videoSrc.mime] - The mimetype of the video (e.g. 'video/mp4'). If not specified
         *  the url's extension will be used as the second part of the mime type.
         * @param {number} scaleMode - See {@link PIXI.SCALE_MODES} for possible values
         * @param {boolean} [crossorigin=(auto)] - Should use anonymous CORS? Defaults to true if the URL is not a data-URI.
         * @param {boolean} [autoPlay=true] - Start playing video as soon as it is loaded
         * @return {PIXI.VideoBaseTexture} Newly created VideoBaseTexture
         */

        VideoBaseTexture.fromUrl = function fromUrl(videoSrc, scaleMode, crossorigin, autoPlay) {
          let video = document.createElement("video");

          video.setAttribute("webkit-playsinline", "");
          video.setAttribute("playsinline", "");

          let url = Array.isArray(videoSrc) ? videoSrc[0].src || videoSrc[0] : videoSrc.src || videoSrc;

          if (crossorigin === undefined && url.indexOf("data:") !== 0) {
            video.crossOrigin = (0, _determineCrossOrigin2.default)(url);
          } else if (crossorigin) {
            video.crossOrigin = typeof crossorigin === "string" ? crossorigin : "anonymous";
          }

          // array of objects or strings
          if (Array.isArray(videoSrc)) {
            for (let i = 0; i < videoSrc.length; ++i) {
              video.appendChild(createSource(videoSrc[i].src || videoSrc[i], videoSrc[i].mime));
            }
          }
          // single object or string
          else {
            video.appendChild(createSource(url, videoSrc.mime));
          }

          video.load();

          return VideoBaseTexture.fromVideo(video, scaleMode, autoPlay);
        };

        /**
         * Should the base texture automatically update itself, set to true by default
         *
         * @member {boolean}
         */

        _createClass(VideoBaseTexture, [
          {
            key: "autoUpdate",
            get: function get() {
              return this._autoUpdate;
            },
            set: function set(
              value // eslint-disable-line require-jsdoc
            ) {
              if (value !== this._autoUpdate) {
                this._autoUpdate = value;

                if (!this._autoUpdate && this._isAutoUpdating) {
                  _ticker.shared.remove(this.update, this);
                  this._isAutoUpdating = false;
                } else if (this._autoUpdate && !this._isAutoUpdating) {
                  _ticker.shared.add(this.update, this, _const.UPDATE_PRIORITY.HIGH);
                  this._isAutoUpdating = true;
                }
              }
            },
          },
        ]);

        return VideoBaseTexture;
      })(_BaseTexture3.default);

      exports.default = VideoBaseTexture;

      VideoBaseTexture.fromUrls = VideoBaseTexture.fromUrl;

      function createSource(path, type) {
        if (!type) {
          let purePath = path.split("?").shift().toLowerCase();

          type = "video/" + purePath.substr(purePath.lastIndexOf(".") + 1);
        }

        let source = document.createElement("source");

        source.src = path;
        source.type = type;

        return source;
      }
      //# sourceMappingURL=VideoBaseTexture.js.map

      /***/
    },
    /* 410 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      let _GroupD = __webpack_require__(394);

      let _GroupD2 = _interopRequireDefault(_GroupD);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      /**
       * A standard object to store the Uvs of a texture
       *
       * @class
       * @private
       * @memberof PIXI
       */
      let TextureUvs = (function () {
        /**
         *
         */
        function TextureUvs() {
          _classCallCheck(this, TextureUvs);

          this.x0 = 0;
          this.y0 = 0;

          this.x1 = 1;
          this.y1 = 0;

          this.x2 = 1;
          this.y2 = 1;

          this.x3 = 0;
          this.y3 = 1;

          this.uvsUint32 = new Uint32Array(4);
        }

        /**
         * Sets the texture Uvs based on the given frame information.
         *
         * @private
         * @param {PIXI.Rectangle} frame - The frame of the texture
         * @param {PIXI.Rectangle} baseFrame - The base frame of the texture
         * @param {number} rotate - Rotation of frame, see {@link PIXI.GroupD8}
         */

        TextureUvs.prototype.set = function set(frame, baseFrame, rotate) {
          let tw = baseFrame.width;
          let th = baseFrame.height;

          if (rotate) {
            // width and height div 2 div baseFrame size
            let w2 = frame.width / 2 / tw;
            let h2 = frame.height / 2 / th;

            // coordinates of center
            let cX = frame.x / tw + w2;
            let cY = frame.y / th + h2;

            rotate = _GroupD2.default.add(rotate, _GroupD2.default.NW); // NW is top-left corner
            this.x0 = cX + w2 * _GroupD2.default.uX(rotate);
            this.y0 = cY + h2 * _GroupD2.default.uY(rotate);

            rotate = _GroupD2.default.add(rotate, 2); // rotate 90 degrees clockwise
            this.x1 = cX + w2 * _GroupD2.default.uX(rotate);
            this.y1 = cY + h2 * _GroupD2.default.uY(rotate);

            rotate = _GroupD2.default.add(rotate, 2);
            this.x2 = cX + w2 * _GroupD2.default.uX(rotate);
            this.y2 = cY + h2 * _GroupD2.default.uY(rotate);

            rotate = _GroupD2.default.add(rotate, 2);
            this.x3 = cX + w2 * _GroupD2.default.uX(rotate);
            this.y3 = cY + h2 * _GroupD2.default.uY(rotate);
          } else {
            this.x0 = frame.x / tw;
            this.y0 = frame.y / th;

            this.x1 = (frame.x + frame.width) / tw;
            this.y1 = frame.y / th;

            this.x2 = (frame.x + frame.width) / tw;
            this.y2 = (frame.y + frame.height) / th;

            this.x3 = frame.x / tw;
            this.y3 = (frame.y + frame.height) / th;
          }

          this.uvsUint32[0] = ((Math.round(this.y0 * 65535) & 0xffff) << 16) | (Math.round(this.x0 * 65535) & 0xffff);
          this.uvsUint32[1] = ((Math.round(this.y1 * 65535) & 0xffff) << 16) | (Math.round(this.x1 * 65535) & 0xffff);
          this.uvsUint32[2] = ((Math.round(this.y2 * 65535) & 0xffff) << 16) | (Math.round(this.x2 * 65535) & 0xffff);
          this.uvsUint32[3] = ((Math.round(this.y3 * 65535) & 0xffff) << 16) | (Math.round(this.x3 * 65535) & 0xffff);
        };

        return TextureUvs;
      })();

      exports.default = TextureUvs;
      //# sourceMappingURL=TextureUvs.js.map

      /***/
    },
    /* 411 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      let _createClass = (function () {
        function defineProperties(target, props) {
          for (let i = 0; i < props.length; i++) {
            let descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      })();

      let _utils = __webpack_require__(345);

      let _math = __webpack_require__(348);

      let _const = __webpack_require__(343);

      let _settings = __webpack_require__(346);

      let _settings2 = _interopRequireDefault(_settings);

      let _Container = __webpack_require__(358);

      let _Container2 = _interopRequireDefault(_Container);

      let _RenderTexture = __webpack_require__(384);

      let _RenderTexture2 = _interopRequireDefault(_RenderTexture);

      let _eventemitter = __webpack_require__(354);

      let _eventemitter2 = _interopRequireDefault(_eventemitter);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: { value: subClass, enumerable: false, writable: true, configurable: true },
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass);
      }

      let tempMatrix = new _math.Matrix();

      /**
       * The SystemRenderer is the base for a PixiJS Renderer. It is extended by the {@link PIXI.CanvasRenderer}
       * and {@link PIXI.WebGLRenderer} which can be used for rendering a PixiJS scene.
       *
       * @abstract
       * @class
       * @extends EventEmitter
       * @memberof PIXI
       */

      let SystemRenderer = (function (_EventEmitter) {
        _inherits(SystemRenderer, _EventEmitter);

        // eslint-disable-next-line valid-jsdoc
        /**
         * @param {string} system - The name of the system this renderer is for.
         * @param {object} [options] - The optional renderer parameters
         * @param {number} [options.width=800] - the width of the screen
         * @param {number} [options.height=600] - the height of the screen
         * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional
         * @param {boolean} [options.transparent=false] - If the render view is transparent, default false
         * @param {boolean} [options.autoResize=false] - If the render view is automatically resized, default false
         * @param {boolean} [options.antialias=false] - sets antialias (only applicable in chrome at the moment)
         * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer. The
         *  resolution of the renderer retina would be 2.
         * @param {boolean} [options.preserveDrawingBuffer=false] - enables drawing buffer preservation,
         *  enable this if you need to call toDataUrl on the webgl context.
         * @param {boolean} [options.clearBeforeRender=true] - This sets if the renderer will clear the canvas or
         *      not before the new render pass.
         * @param {number} [options.backgroundColor=0x000000] - The background color of the rendered area
         *  (shown if not transparent).
         * @param {boolean} [options.roundPixels=false] - If true PixiJS will Math.floor() x/y values when rendering,
         *  stopping pixel interpolation.
         */
        function SystemRenderer(system, options, arg2, arg3) {
          _classCallCheck(this, SystemRenderer);

          let _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

          (0, _utils.sayHello)(system);

          // Support for constructor(system, screenWidth, screenHeight, options)
          if (typeof options === "number") {
            options = Object.assign(
              {
                width: options,
                height: arg2 || _settings2.default.RENDER_OPTIONS.height,
              },
              arg3
            );
          }

          // Add the default render options
          options = Object.assign({}, _settings2.default.RENDER_OPTIONS, options);

          /**
           * The supplied constructor options.
           *
           * @member {Object}
           * @readOnly
           */
          _this.options = options;

          /**
           * The type of the renderer.
           *
           * @member {number}
           * @default PIXI.RENDERER_TYPE.UNKNOWN
           * @see PIXI.RENDERER_TYPE
           */
          _this.type = _const.RENDERER_TYPE.UNKNOWN;

          /**
           * Measurements of the screen. (0, 0, screenWidth, screenHeight)
           *
           * Its safe to use as filterArea or hitArea for whole stage
           *
           * @member {PIXI.Rectangle}
           */
          _this.screen = new _math.Rectangle(0, 0, options.width, options.height);

          /**
           * The canvas element that everything is drawn to
           *
           * @member {HTMLCanvasElement}
           */
          _this.view = options.view || document.createElement("canvas");

          /**
           * The resolution / device pixel ratio of the renderer
           *
           * @member {number}
           * @default 1
           */
          _this.resolution = options.resolution || _settings2.default.RESOLUTION;

          /**
           * Whether the render view is transparent
           *
           * @member {boolean}
           */
          _this.transparent = options.transparent;

          /**
           * Whether css dimensions of canvas view should be resized to screen dimensions automatically
           *
           * @member {boolean}
           */
          _this.autoResize = options.autoResize || false;

          /**
           * Tracks the blend modes useful for this renderer.
           *
           * @member {object<string, mixed>}
           */
          _this.blendModes = null;

          /**
           * The value of the preserveDrawingBuffer flag affects whether or not the contents of
           * the stencil buffer is retained after rendering.
           *
           * @member {boolean}
           */
          _this.preserveDrawingBuffer = options.preserveDrawingBuffer;

          /**
           * This sets if the CanvasRenderer will clear the canvas or not before the new render pass.
           * If the scene is NOT transparent PixiJS will use a canvas sized fillRect operation every
           * frame to set the canvas background color. If the scene is transparent PixiJS will use clearRect
           * to clear the canvas every frame. Disable this by setting this to false. For example if
           * your game has a canvas filling background image you often don't need this set.
           *
           * @member {boolean}
           * @default
           */
          _this.clearBeforeRender = options.clearBeforeRender;

          /**
           * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
           * Handy for crisp pixel art and speed on legacy devices.
           *
           * @member {boolean}
           */
          _this.roundPixels = options.roundPixels;

          /**
           * The background color as a number.
           *
           * @member {number}
           * @private
           */
          _this._backgroundColor = 0x000000;

          /**
           * The background color as an [R, G, B] array.
           *
           * @member {number[]}
           * @private
           */
          _this._backgroundColorRgba = [0, 0, 0, 0];

          /**
           * The background color as a string.
           *
           * @member {string}
           * @private
           */
          _this._backgroundColorString = "#000000";

          _this.backgroundColor = options.backgroundColor || _this._backgroundColor; // run bg color setter

          /**
           * This temporary display object used as the parent of the currently being rendered item
           *
           * @member {PIXI.DisplayObject}
           * @private
           */
          _this._tempDisplayObjectParent = new _Container2.default();

          /**
           * The last root object that the renderer tried to render.
           *
           * @member {PIXI.DisplayObject}
           * @private
           */
          _this._lastObjectRendered = _this._tempDisplayObjectParent;
          return _this;
        }

        /**
         * Same as view.width, actual number of pixels in the canvas by horizontal
         *
         * @member {number}
         * @readonly
         * @default 800
         */

        /**
         * Resizes the screen and canvas to the specified width and height
         * Canvas dimensions are multiplied by resolution
         *
         * @param {number} screenWidth - the new width of the screen
         * @param {number} screenHeight - the new height of the screen
         */
        SystemRenderer.prototype.resize = function resize(screenWidth, screenHeight) {
          this.screen.width = screenWidth;
          this.screen.height = screenHeight;

          this.view.width = screenWidth * this.resolution;
          this.view.height = screenHeight * this.resolution;

          if (this.autoResize) {
            this.view.style.width = screenWidth + "px";
            this.view.style.height = screenHeight + "px";
          }
        };

        /**
         * Useful function that returns a texture of the display object that can then be used to create sprites
         * This can be quite useful if your displayObject is complicated and needs to be reused multiple times.
         *
         * @param {PIXI.DisplayObject} displayObject - The displayObject the object will be generated from
         * @param {number} scaleMode - Should be one of the scaleMode consts
         * @param {number} resolution - The resolution / device pixel ratio of the texture being generated
         * @param {PIXI.Rectangle} [region] - The region of the displayObject, that shall be rendered,
         *        if no region is specified, defaults to the local bounds of the displayObject.
         * @return {PIXI.Texture} a texture of the graphics object
         */

        SystemRenderer.prototype.generateTexture = function generateTexture(displayObject, scaleMode, resolution, region) {
          region = region || displayObject.getLocalBounds();

          let renderTexture = _RenderTexture2.default.create(region.width | 0, region.height | 0, scaleMode, resolution);

          tempMatrix.tx = -region.x;
          tempMatrix.ty = -region.y;

          this.render(displayObject, renderTexture, false, tempMatrix, !!displayObject.parent);

          return renderTexture;
        };

        /**
         * Removes everything from the renderer and optionally removes the Canvas DOM element.
         *
         * @param {boolean} [removeView=false] - Removes the Canvas element from the DOM.
         */

        SystemRenderer.prototype.destroy = function destroy(removeView) {
          if (removeView && this.view.parentNode) {
            this.view.parentNode.removeChild(this.view);
          }

          this.type = _const.RENDERER_TYPE.UNKNOWN;

          this.view = null;

          this.screen = null;

          this.resolution = 0;

          this.transparent = false;

          this.autoResize = false;

          this.blendModes = null;

          this.options = null;

          this.preserveDrawingBuffer = false;
          this.clearBeforeRender = false;

          this.roundPixels = false;

          this._backgroundColor = 0;
          this._backgroundColorRgba = null;
          this._backgroundColorString = null;

          this._tempDisplayObjectParent = null;
          this._lastObjectRendered = null;
        };

        /**
         * The background color to fill if not transparent
         *
         * @member {number}
         */

        _createClass(SystemRenderer, [
          {
            key: "width",
            get: function get() {
              return this.view.width;
            },

            /**
             * Same as view.height, actual number of pixels in the canvas by vertical
             *
             * @member {number}
             * @readonly
             * @default 600
             */
          },
          {
            key: "height",
            get: function get() {
              return this.view.height;
            },
          },
          {
            key: "backgroundColor",
            get: function get() {
              return this._backgroundColor;
            },
            set: function set(
              value // eslint-disable-line require-jsdoc
            ) {
              this._backgroundColor = value;
              this._backgroundColorString = (0, _utils.hex2string)(value);
              (0, _utils.hex2rgb)(value, this._backgroundColorRgba);
            },
          },
        ]);

        return SystemRenderer;
      })(_eventemitter2.default);

      exports.default = SystemRenderer;
      //# sourceMappingURL=SystemRenderer.js.map

      /***/
    },
    /* 412 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      let _BaseTexture2 = __webpack_require__(355);

      let _BaseTexture3 = _interopRequireDefault(_BaseTexture2);

      let _settings = __webpack_require__(346);

      let _settings2 = _interopRequireDefault(_settings);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: { value: subClass, enumerable: false, writable: true, configurable: true },
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass);
      }

      /**
       * A BaseRenderTexture is a special texture that allows any PixiJS display object to be rendered to it.
       *
       * __Hint__: All DisplayObjects (i.e. Sprites) that render to a BaseRenderTexture should be preloaded
       * otherwise black rectangles will be drawn instead.
       *
       * A BaseRenderTexture takes a snapshot of any Display Object given to its render method. The position
       * and rotation of the given Display Objects is ignored. For example:
       *
       * ```js
       * let renderer = PIXI.autoDetectRenderer(1024, 1024);
       * let baseRenderTexture = new PIXI.BaseRenderTexture(800, 600);
       * let renderTexture = new PIXI.RenderTexture(baseRenderTexture);
       * let sprite = PIXI.Sprite.fromImage("spinObj_01.png");
       *
       * sprite.position.x = 800/2;
       * sprite.position.y = 600/2;
       * sprite.anchor.x = 0.5;
       * sprite.anchor.y = 0.5;
       *
       * renderer.render(sprite, renderTexture);
       * ```
       *
       * The Sprite in this case will be rendered using its local transform. To render this sprite at 0,0
       * you can clear the transform
       *
       * ```js
       *
       * sprite.setTransform()
       *
       * let baseRenderTexture = new PIXI.BaseRenderTexture(100, 100);
       * let renderTexture = new PIXI.RenderTexture(baseRenderTexture);
       *
       * renderer.render(sprite, renderTexture);  // Renders to center of RenderTexture
       * ```
       *
       * @class
       * @extends PIXI.BaseTexture
       * @memberof PIXI
       */
      let BaseRenderTexture = (function (_BaseTexture) {
        _inherits(BaseRenderTexture, _BaseTexture);

        /**
         * @param {number} [width=100] - The width of the base render texture
         * @param {number} [height=100] - The height of the base render texture
         * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
         * @param {number} [resolution=1] - The resolution / device pixel ratio of the texture being generated
         */
        function BaseRenderTexture() {
          let width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
          let height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
          let scaleMode = arguments[2];
          let resolution = arguments[3];

          _classCallCheck(this, BaseRenderTexture);

          let _this = _possibleConstructorReturn(this, _BaseTexture.call(this, null, scaleMode));

          _this.resolution = resolution || _settings2.default.RESOLUTION;

          _this.width = Math.ceil(width);
          _this.height = Math.ceil(height);

          _this.realWidth = _this.width * _this.resolution;
          _this.realHeight = _this.height * _this.resolution;

          _this.scaleMode = scaleMode !== undefined ? scaleMode : _settings2.default.SCALE_MODE;
          _this.hasLoaded = true;

          /**
           * A map of renderer IDs to webgl renderTargets
           *
           * @private
           * @member {object<number, WebGLTexture>}
           */
          _this._glRenderTargets = {};

          /**
           * A reference to the canvas render target (we only need one as this can be shared across renderers)
           *
           * @private
           * @member {object<number, WebGLTexture>}
           */
          _this._canvasRenderTarget = null;

          /**
           * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.
           *
           * @member {boolean}
           */
          _this.valid = false;
          return _this;
        }

        /**
         * Resizes the BaseRenderTexture.
         *
         * @param {number} width - The width to resize to.
         * @param {number} height - The height to resize to.
         */

        BaseRenderTexture.prototype.resize = function resize(width, height) {
          width = Math.ceil(width);
          height = Math.ceil(height);

          if (width === this.width && height === this.height) {
            return;
          }

          this.valid = width > 0 && height > 0;

          this.width = width;
          this.height = height;

          this.realWidth = this.width * this.resolution;
          this.realHeight = this.height * this.resolution;

          if (!this.valid) {
            return;
          }

          this.emit("update", this);
        };

        /**
         * Destroys this texture
         *
         */

        BaseRenderTexture.prototype.destroy = function destroy() {
          _BaseTexture.prototype.destroy.call(this, true);
          this.renderer = null;
        };

        return BaseRenderTexture;
      })(_BaseTexture3.default);

      exports.default = BaseRenderTexture;
      //# sourceMappingURL=BaseRenderTexture.js.map

      /***/
    },
    /* 413 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      let _createClass = (function () {
        function defineProperties(target, props) {
          for (let i = 0; i < props.length; i++) {
            let descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      })();

      let _settings = __webpack_require__(346);

      let _settings2 = _interopRequireDefault(_settings);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      /**
       * Creates a Canvas element of the given size.
       *
       * @class
       * @memberof PIXI
       */
      let CanvasRenderTarget = (function () {
        /**
         * @param {number} width - the width for the newly created canvas
         * @param {number} height - the height for the newly created canvas
         * @param {number} [resolution=1] - The resolution / device pixel ratio of the canvas
         */
        function CanvasRenderTarget(width, height, resolution) {
          _classCallCheck(this, CanvasRenderTarget);

          /**
           * The Canvas object that belongs to this CanvasRenderTarget.
           *
           * @member {HTMLCanvasElement}
           */
          this.canvas = document.createElement("canvas");

          /**
           * A CanvasRenderingContext2D object representing a two-dimensional rendering context.
           *
           * @member {CanvasRenderingContext2D}
           */
          this.context = this.canvas.getContext("2d");

          this.resolution = resolution || _settings2.default.RESOLUTION;

          this.resize(width, height);
        }

        /**
         * Clears the canvas that was created by the CanvasRenderTarget class.
         *
         * @private
         */

        CanvasRenderTarget.prototype.clear = function clear() {
          this.context.setTransform(1, 0, 0, 1, 0, 0);
          this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        };

        /**
         * Resizes the canvas to the specified width and height.
         *
         * @param {number} width - the new width of the canvas
         * @param {number} height - the new height of the canvas
         */

        CanvasRenderTarget.prototype.resize = function resize(width, height) {
          this.canvas.width = width * this.resolution;
          this.canvas.height = height * this.resolution;
        };

        /**
         * Destroys this canvas.
         *
         */

        CanvasRenderTarget.prototype.destroy = function destroy() {
          this.context = null;
          this.canvas = null;
        };

        /**
         * The width of the canvas buffer in pixels.
         *
         * @member {number}
         */

        _createClass(CanvasRenderTarget, [
          {
            key: "width",
            get: function get() {
              return this.canvas.width;
            },
            set: function set(
              val // eslint-disable-line require-jsdoc
            ) {
              this.canvas.width = val;
            },

            /**
             * The height of the canvas buffer in pixels.
             *
             * @member {number}
             */
          },
          {
            key: "height",
            get: function get() {
              return this.canvas.height;
            },
            set: function set(
              val // eslint-disable-line require-jsdoc
            ) {
              this.canvas.height = val;
            },
          },
        ]);

        return CanvasRenderTarget;
      })();

      exports.default = CanvasRenderTarget;
      //# sourceMappingURL=CanvasRenderTarget.js.map

      /***/
    },
    /* 414 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;
      exports.default = canUseNewCanvasBlendModes;
      /**
       * Creates a little colored canvas
       *
       * @ignore
       * @param {string} color - The color to make the canvas
       * @return {canvas} a small canvas element
       */
      function createColoredCanvas(color) {
        let canvas = document.createElement("canvas");

        canvas.width = 6;
        canvas.height = 1;

        let context = canvas.getContext("2d");

        context.fillStyle = color;
        context.fillRect(0, 0, 6, 1);

        return canvas;
      }

      /**
       * Checks whether the Canvas BlendModes are supported by the current browser
       *
       * @return {boolean} whether they are supported
       */
      function canUseNewCanvasBlendModes() {
        if (typeof document === "undefined") {
          return false;
        }

        let magenta = createColoredCanvas("#ff00ff");
        let yellow = createColoredCanvas("#ffff00");

        let canvas = document.createElement("canvas");

        canvas.width = 6;
        canvas.height = 1;

        let context = canvas.getContext("2d");

        context.globalCompositeOperation = "multiply";
        context.drawImage(magenta, 0, 0);
        context.drawImage(yellow, 2, 0);

        let imageData = context.getImageData(2, 0, 1, 1);

        if (!imageData) {
          return false;
        }

        let data = imageData.data;

        return data[0] === 255 && data[1] === 0 && data[2] === 0;
      }
      //# sourceMappingURL=canUseNewCanvasBlendModes.js.map

      /***/
    },
    /* 415 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      let _Filter2 = __webpack_require__(416);

      let _Filter3 = _interopRequireDefault(_Filter2);

      let _math = __webpack_require__(348);

      let _path = __webpack_require__(352);

      let _TextureMatrix = __webpack_require__(417);

      let _TextureMatrix2 = _interopRequireDefault(_TextureMatrix);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: { value: subClass, enumerable: false, writable: true, configurable: true },
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass);
      }

      /**
       * The SpriteMaskFilter class
       *
       * @class
       * @extends PIXI.Filter
       * @memberof PIXI
       */
      let SpriteMaskFilter = (function (_Filter) {
        _inherits(SpriteMaskFilter, _Filter);

        /**
         * @param {PIXI.Sprite} sprite - the target sprite
         */
        function SpriteMaskFilter(sprite) {
          _classCallCheck(this, SpriteMaskFilter);

          let maskMatrix = new _math.Matrix();

          let _this = _possibleConstructorReturn(
            this,
            _Filter.call(
              this,
              "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n",
              "varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n\n    original *= (masky.r * masky.a * alpha * clip);\n\n    gl_FragColor = original;\n}\n"
            )
          );

          sprite.renderable = false;

          _this.maskSprite = sprite;
          _this.maskMatrix = maskMatrix;
          return _this;
        }

        /**
         * Applies the filter
         *
         * @param {PIXI.FilterManager} filterManager - The renderer to retrieve the filter from
         * @param {PIXI.RenderTarget} input - The input render target.
         * @param {PIXI.RenderTarget} output - The target to output to.
         * @param {boolean} clear - Should the output be cleared before rendering to it
         */

        SpriteMaskFilter.prototype.apply = function apply(filterManager, input, output, clear) {
          let maskSprite = this.maskSprite;
          let tex = this.maskSprite.texture;

          if (!tex.valid) {
            return;
          }
          if (!tex.transform) {
            // margin = 0.0, let it bleed a bit, shader code becomes easier
            // assuming that atlas textures were made with 1-pixel padding
            tex.transform = new _TextureMatrix2.default(tex, 0.0);
          }
          tex.transform.update();

          this.uniforms.mask = tex;
          this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite).prepend(tex.transform.mapCoord);
          this.uniforms.alpha = maskSprite.worldAlpha;
          this.uniforms.maskClamp = tex.transform.uClampFrame;

          filterManager.applyFilter(this, input, output, clear);
        };

        return SpriteMaskFilter;
      })(_Filter3.default);

      exports.default = SpriteMaskFilter;
      //# sourceMappingURL=SpriteMaskFilter.js.map

      /***/
    },
    /* 416 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      let _createClass = (function () {
        function defineProperties(target, props) {
          for (let i = 0; i < props.length; i++) {
            let descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      })();

      let _extractUniformsFromSrc = __webpack_require__(505);

      let _extractUniformsFromSrc2 = _interopRequireDefault(_extractUniformsFromSrc);

      let _utils = __webpack_require__(345);

      let _const = __webpack_require__(343);

      let _settings = __webpack_require__(346);

      let _settings2 = _interopRequireDefault(_settings);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      let SOURCE_KEY_MAP = {};

      // let math = require('../../../math');
      /**
       * @class
       * @memberof PIXI
       * @extends PIXI.Shader
       */

      let Filter = (function () {
        /**
         * @param {string} [vertexSrc] - The source of the vertex shader.
         * @param {string} [fragmentSrc] - The source of the fragment shader.
         * @param {object} [uniformData] - Custom uniforms to use to augment the built-in ones.
         */
        function Filter(vertexSrc, fragmentSrc, uniformData) {
          _classCallCheck(this, Filter);

          /**
           * The vertex shader.
           *
           * @member {string}
           */
          this.vertexSrc = vertexSrc || Filter.defaultVertexSrc;

          /**
           * The fragment shader.
           *
           * @member {string}
           */
          this.fragmentSrc = fragmentSrc || Filter.defaultFragmentSrc;

          this._blendMode = _const.BLEND_MODES.NORMAL;

          this.uniformData = uniformData || (0, _extractUniformsFromSrc2.default)(this.vertexSrc, this.fragmentSrc, "projectionMatrix|uSampler");

          /**
           * An object containing the current values of custom uniforms.
           * @example <caption>Updating the value of a custom uniform</caption>
           * filter.uniforms.time = performance.now();
           *
           * @member {object}
           */
          this.uniforms = {};

          for (let i in this.uniformData) {
            this.uniforms[i] = this.uniformData[i].value;
            if (this.uniformData[i].type) {
              this.uniformData[i].type = this.uniformData[i].type.toLowerCase();
            }
          }

          // this is where we store shader references..
          // TODO we could cache this!
          this.glShaders = {};

          // used for caching.. sure there is a better way!
          if (!SOURCE_KEY_MAP[this.vertexSrc + this.fragmentSrc]) {
            SOURCE_KEY_MAP[this.vertexSrc + this.fragmentSrc] = (0, _utils.uid)();
          }

          this.glShaderKey = SOURCE_KEY_MAP[this.vertexSrc + this.fragmentSrc];

          /**
           * The padding of the filter. Some filters require extra space to breath such as a blur.
           * Increasing this will add extra width and height to the bounds of the object that the
           * filter is applied to.
           *
           * @member {number}
           */
          this.padding = 4;

          /**
           * The resolution of the filter. Setting this to be lower will lower the quality but
           * increase the performance of the filter.
           *
           * @member {number}
           */
          this.resolution = _settings2.default.FILTER_RESOLUTION;

          /**
           * If enabled is true the filter is applied, if false it will not.
           *
           * @member {boolean}
           */
          this.enabled = true;

          /**
           * If enabled, PixiJS will fit the filter area into boundaries for better performance.
           * Switch it off if it does not work for specific shader.
           *
           * @member {boolean}
           */
          this.autoFit = true;
        }

        /**
         * Applies the filter
         *
         * @param {PIXI.FilterManager} filterManager - The renderer to retrieve the filter from
         * @param {PIXI.RenderTarget} input - The input render target.
         * @param {PIXI.RenderTarget} output - The target to output to.
         * @param {boolean} clear - Should the output be cleared before rendering to it
         * @param {object} [currentState] - It's current state of filter.
         *        There are some useful properties in the currentState :
         *        target, filters, sourceFrame, destinationFrame, renderTarget, resolution
         */

        Filter.prototype.apply = function apply(
          filterManager,
          input,
          output,
          clear,
          currentState // eslint-disable-line no-unused-vars
        ) {
          // --- //
          //  this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(tempMatrix, window.panda );

          // do as you please!

          filterManager.applyFilter(this, input, output, clear);

          // or just do a regular render..
        };

        /**
         * Sets the blendmode of the filter
         *
         * @member {number}
         * @default PIXI.BLEND_MODES.NORMAL
         */

        _createClass(
          Filter,
          [
            {
              key: "blendMode",
              get: function get() {
                return this._blendMode;
              },
              set: function set(
                value // eslint-disable-line require-jsdoc
              ) {
                this._blendMode = value;
              },

              /**
               * The default vertex shader source
               *
               * @static
               * @constant
               */
            },
          ],
          [
            {
              key: "defaultVertexSrc",
              get: function get() {
                return [
                  "attribute vec2 aVertexPosition;",
                  "attribute vec2 aTextureCoord;",
                  "uniform mat3 projectionMatrix;",
                  "uniform mat3 filterMatrix;",
                  "varying vec2 vTextureCoord;",
                  "varying vec2 vFilterCoord;",
                  "void main(void){",
                  "   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);",
                  "   vFilterCoord = ( filterMatrix * vec3( aTextureCoord, 1.0)  ).xy;",
                  "   vTextureCoord = aTextureCoord ;",
                  "}",
                ].join("\n");
              },

              /**
               * The default fragment shader source
               *
               * @static
               * @constant
               */
            },
            {
              key: "defaultFragmentSrc",
              get: function get() {
                return [
                  "varying vec2 vTextureCoord;",
                  "varying vec2 vFilterCoord;",
                  "uniform sampler2D uSampler;",
                  "uniform sampler2D filterSampler;",
                  "void main(void){",
                  "   vec4 masky = texture2D(filterSampler, vFilterCoord);",
                  "   vec4 sample = texture2D(uSampler, vTextureCoord);",
                  "   vec4 color;",
                  "   if(mod(vFilterCoord.x, 1.0) > 0.5)",
                  "   {",
                  "     color = vec4(1.0, 0.0, 0.0, 1.0);",
                  "   }",
                  "   else",
                  "   {",
                  "     color = vec4(0.0, 1.0, 0.0, 1.0);",
                  "   }",
                  // '   gl_FragColor = vec4(mod(vFilterCoord.x, 1.5), vFilterCoord.y,0.0,1.0);',
                  "   gl_FragColor = mix(sample, masky, 0.5);",
                  "   gl_FragColor *= sample.a;",
                  "}",
                ].join("\n");
              },
            },
          ]
        );

        return Filter;
      })();

      exports.default = Filter;
      //# sourceMappingURL=Filter.js.map

      /***/
    },
    /* 417 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      let _createClass = (function () {
        function defineProperties(target, props) {
          for (let i = 0; i < props.length; i++) {
            let descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      })();

      let _Matrix = __webpack_require__(374);

      let _Matrix2 = _interopRequireDefault(_Matrix);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      let tempMat = new _Matrix2.default();

      /**
       * Class controls uv transform and frame clamp for texture
       * Can be used in Texture "transform" field, or separately, you can use different clamp settings on the same texture.
       * If you want to add support for texture region of certain feature or filter, that's what you're looking for.
       *
       * @see PIXI.Texture
       * @see PIXI.mesh.Mesh
       * @see PIXI.extras.TilingSprite
       * @class
       * @memberof PIXI
       */

      let TextureMatrix = (function () {
        /**
         *
         * @param {PIXI.Texture} texture observed texture
         * @param {number} [clampMargin] Changes frame clamping, 0.5 by default. Use -0.5 for extra border.
         * @constructor
         */
        function TextureMatrix(texture, clampMargin) {
          _classCallCheck(this, TextureMatrix);

          this._texture = texture;

          this.mapCoord = new _Matrix2.default();

          this.uClampFrame = new Float32Array(4);

          this.uClampOffset = new Float32Array(2);

          this._lastTextureID = -1;

          /**
           * Changes frame clamping
           * Works with TilingSprite and Mesh
           * Change to 1.5 if you texture has repeated right and bottom lines, that leads to smoother borders
           *
           * @default 0
           * @member {number}
           */
          this.clampOffset = 0;

          /**
           * Changes frame clamping
           * Works with TilingSprite and Mesh
           * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas
           *
           * @default 0.5
           * @member {number}
           */
          this.clampMargin = typeof clampMargin === "undefined" ? 0.5 : clampMargin;
        }

        /**
         * texture property
         * @member {PIXI.Texture}
         */

        /**
         * Multiplies uvs array to transform
         * @param {Float32Array} uvs mesh uvs
         * @param {Float32Array} [out=uvs] output
         * @returns {Float32Array} output
         */
        TextureMatrix.prototype.multiplyUvs = function multiplyUvs(uvs, out) {
          if (out === undefined) {
            out = uvs;
          }

          let mat = this.mapCoord;

          for (let i = 0; i < uvs.length; i += 2) {
            let x = uvs[i];
            let y = uvs[i + 1];

            out[i] = x * mat.a + y * mat.c + mat.tx;
            out[i + 1] = x * mat.b + y * mat.d + mat.ty;
          }

          return out;
        };

        /**
         * updates matrices if texture was changed
         * @param {boolean} forceUpdate if true, matrices will be updated any case
         * @returns {boolean} whether or not it was updated
         */

        TextureMatrix.prototype.update = function update(forceUpdate) {
          let tex = this._texture;

          if (!tex || !tex.valid) {
            return false;
          }

          if (!forceUpdate && this._lastTextureID === tex._updateID) {
            return false;
          }

          this._lastTextureID = tex._updateID;

          let uvs = tex._uvs;

          this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);

          let orig = tex.orig;
          let trim = tex.trim;

          if (trim) {
            tempMat.set(orig.width / trim.width, 0, 0, orig.height / trim.height, -trim.x / trim.width, -trim.y / trim.height);
            this.mapCoord.append(tempMat);
          }

          let texBase = tex.baseTexture;
          let frame = this.uClampFrame;
          let margin = this.clampMargin / texBase.resolution;
          let offset = this.clampOffset;

          frame[0] = (tex._frame.x + margin + offset) / texBase.width;
          frame[1] = (tex._frame.y + margin + offset) / texBase.height;
          frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width;
          frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height;
          this.uClampOffset[0] = offset / texBase.realWidth;
          this.uClampOffset[1] = offset / texBase.realHeight;

          return true;
        };

        _createClass(TextureMatrix, [
          {
            key: "texture",
            get: function get() {
              return this._texture;
            },
            set: function set(
              value // eslint-disable-line require-jsdoc
            ) {
              this._texture = value;
              this._lastTextureID = -1;
            },
          },
        ]);

        return TextureMatrix;
      })();

      exports.default = TextureMatrix;
      //# sourceMappingURL=TextureMatrix.js.map

      /***/
    },
    /* 418 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      let _pixiGlCore = __webpack_require__(350);

      let _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);

      let _createIndicesForQuads = __webpack_require__(385);

      let _createIndicesForQuads2 = _interopRequireDefault(_createIndicesForQuads);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      /**
       * Helper class to create a quad
       *
       * @class
       * @memberof PIXI
       */
      let Quad = (function () {
        /**
         * @param {WebGLRenderingContext} gl - The gl context for this quad to use.
         * @param {object} state - TODO: Description
         */
        function Quad(gl, state) {
          _classCallCheck(this, Quad);

          /**
           * the current WebGL drawing context
           *
           * @member {WebGLRenderingContext}
           */
          this.gl = gl;

          /**
           * An array of vertices
           *
           * @member {Float32Array}
           */
          this.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]);

          /**
           * The Uvs of the quad
           *
           * @member {Float32Array}
           */
          this.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);

          this.interleaved = new Float32Array(8 * 2);

          for (let i = 0; i < 4; i++) {
            this.interleaved[i * 4] = this.vertices[i * 2];
            this.interleaved[i * 4 + 1] = this.vertices[i * 2 + 1];
            this.interleaved[i * 4 + 2] = this.uvs[i * 2];
            this.interleaved[i * 4 + 3] = this.uvs[i * 2 + 1];
          }

          /**
           * An array containing the indices of the vertices
           *
           * @member {Uint16Array}
           */
          this.indices = (0, _createIndicesForQuads2.default)(1);

          /**
           * The vertex buffer
           *
           * @member {glCore.GLBuffer}
           */
          this.vertexBuffer = _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, this.interleaved, gl.STATIC_DRAW);

          /**
           * The index buffer
           *
           * @member {glCore.GLBuffer}
           */
          this.indexBuffer = _pixiGlCore2.default.GLBuffer.createIndexBuffer(gl, this.indices, gl.STATIC_DRAW);

          /**
           * The vertex array object
           *
           * @member {glCore.VertexArrayObject}
           */
          this.vao = new _pixiGlCore2.default.VertexArrayObject(gl, state);
        }

        /**
         * Initialises the vaos and uses the shader.
         *
         * @param {PIXI.Shader} shader - the shader to use
         */

        Quad.prototype.initVao = function initVao(shader) {
          this.vao
            .clear()
            .addIndex(this.indexBuffer)
            .addAttribute(this.vertexBuffer, shader.attributes.aVertexPosition, this.gl.FLOAT, false, 4 * 4, 0)
            .addAttribute(this.vertexBuffer, shader.attributes.aTextureCoord, this.gl.FLOAT, false, 4 * 4, 2 * 4);
        };

        /**
         * Maps two Rectangle to the quad.
         *
         * @param {PIXI.Rectangle} targetTextureFrame - the first rectangle
         * @param {PIXI.Rectangle} destinationFrame - the second rectangle
         * @return {PIXI.Quad} Returns itself.
         */

        Quad.prototype.map = function map(targetTextureFrame, destinationFrame) {
          let x = 0; // destinationFrame.x / targetTextureFrame.width;
          let y = 0; // destinationFrame.y / targetTextureFrame.height;

          this.uvs[0] = x;
          this.uvs[1] = y;

          this.uvs[2] = x + destinationFrame.width / targetTextureFrame.width;
          this.uvs[3] = y;

          this.uvs[4] = x + destinationFrame.width / targetTextureFrame.width;
          this.uvs[5] = y + destinationFrame.height / targetTextureFrame.height;

          this.uvs[6] = x;
          this.uvs[7] = y + destinationFrame.height / targetTextureFrame.height;

          x = destinationFrame.x;
          y = destinationFrame.y;

          this.vertices[0] = x;
          this.vertices[1] = y;

          this.vertices[2] = x + destinationFrame.width;
          this.vertices[3] = y;

          this.vertices[4] = x + destinationFrame.width;
          this.vertices[5] = y + destinationFrame.height;

          this.vertices[6] = x;
          this.vertices[7] = y + destinationFrame.height;

          return this;
        };

        /**
         * Binds the buffer and uploads the data
         *
         * @return {PIXI.Quad} Returns itself.
         */

        Quad.prototype.upload = function upload() {
          for (let i = 0; i < 4; i++) {
            this.interleaved[i * 4] = this.vertices[i * 2];
            this.interleaved[i * 4 + 1] = this.vertices[i * 2 + 1];
            this.interleaved[i * 4 + 2] = this.uvs[i * 2];
            this.interleaved[i * 4 + 3] = this.uvs[i * 2 + 1];
          }

          this.vertexBuffer.upload(this.interleaved);

          return this;
        };

        /**
         * Removes this quad from WebGL
         */

        Quad.prototype.destroy = function destroy() {
          let gl = this.gl;

          gl.deleteBuffer(this.vertexBuffer);
          gl.deleteBuffer(this.indexBuffer);
        };

        return Quad;
      })();

      exports.default = Quad;
      //# sourceMappingURL=Quad.js.map

      /***/
    },
    /* 419 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      let _createClass = (function () {
        function defineProperties(target, props) {
          for (let i = 0; i < props.length; i++) {
            let descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      })(); // disabling eslint for now, going to rewrite this in v5
      /* eslint-disable */

      var _const = __webpack_require__(343);

      var _utils = __webpack_require__(345);

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var defaultStyle = {
        align: "left",
        breakWords: false,
        dropShadow: false,
        dropShadowAlpha: 1,
        dropShadowAngle: Math.PI / 6,
        dropShadowBlur: 0,
        dropShadowColor: "black",
        dropShadowDistance: 5,
        fill: "black",
        fillGradientType: _const.TEXT_GRADIENT.LINEAR_VERTICAL,
        fillGradientStops: [],
        fontFamily: "Arial",
        fontSize: 26,
        fontStyle: "normal",
        fontVariant: "normal",
        fontWeight: "normal",
        letterSpacing: 0,
        lineHeight: 0,
        lineJoin: "miter",
        miterLimit: 10,
        padding: 0,
        stroke: "black",
        strokeThickness: 0,
        textBaseline: "alphabetic",
        trim: false,
        whiteSpace: "pre",
        wordWrap: false,
        wordWrapWidth: 100,
        leading: 0,
      };

      var genericFontFamilies = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"];

      /**
       * A TextStyle Object decorates a Text Object. It can be shared between
       * multiple Text objects. Changing the style will update all text objects using it.
       * It can be generated [here](https://pixijs.io/pixi-text-style).
       *
       * @class
       * @memberof PIXI
       */

      var TextStyle = (function () {
        /**
         * @param {object} [style] - The style parameters
         * @param {string} [style.align='left'] - Alignment for multiline text ('left', 'center' or 'right'),
         *  does not affect single line text
         * @param {boolean} [style.breakWords=false] - Indicates if lines can be wrapped within words, it
         *  needs wordWrap to be set to true
         * @param {boolean} [style.dropShadow=false] - Set a drop shadow for the text
         * @param {number} [style.dropShadowAlpha=1] - Set alpha for the drop shadow
         * @param {number} [style.dropShadowAngle=Math.PI/6] - Set a angle of the drop shadow
         * @param {number} [style.dropShadowBlur=0] - Set a shadow blur radius
         * @param {string|number} [style.dropShadowColor='black'] - A fill style to be used on the dropshadow e.g 'red', '#00FF00'
         * @param {number} [style.dropShadowDistance=5] - Set a distance of the drop shadow
         * @param {string|string[]|number|number[]|CanvasGradient|CanvasPattern} [style.fill='black'] - A canvas
         *  fillstyle that will be used on the text e.g 'red', '#00FF00'. Can be an array to create a gradient
         *  eg ['#000000','#FFFFFF']
         * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}
         * @param {number} [style.fillGradientType=PIXI.TEXT_GRADIENT.LINEAR_VERTICAL] - If fill is an array of colours
         *  to create a gradient, this can change the type/direction of the gradient. See {@link PIXI.TEXT_GRADIENT}
         * @param {number[]} [style.fillGradientStops] - If fill is an array of colours to create a gradient, this array can set
         * the stop points (numbers between 0 and 1) for the color, overriding the default behaviour of evenly spacing them.
         * @param {string|string[]} [style.fontFamily='Arial'] - The font family
         * @param {number|string} [style.fontSize=26] - The font size (as a number it converts to px, but as a string,
         *  equivalents are '26px','20pt','160%' or '1.6em')
         * @param {string} [style.fontStyle='normal'] - The font style ('normal', 'italic' or 'oblique')
         * @param {string} [style.fontVariant='normal'] - The font variant ('normal' or 'small-caps')
         * @param {string} [style.fontWeight='normal'] - The font weight ('normal', 'bold', 'bolder', 'lighter' and '100',
         *  '200', '300', '400', '500', '600', '700', 800' or '900')
         * @param {number} [style.leading=0] - The space between lines
         * @param {number} [style.letterSpacing=0] - The amount of spacing between letters, default is 0
         * @param {number} [style.lineHeight] - The line height, a number that represents the vertical space that a letter uses
         * @param {string} [style.lineJoin='miter'] - The lineJoin property sets the type of corner created, it can resolve
         *      spiked text issues. Possible values "miter" (creates a sharp corner), "round" (creates a round corner) or "bevel"
         *      (creates a squared corner).
         * @param {number} [style.miterLimit=10] - The miter limit to use when using the 'miter' lineJoin mode. This can reduce
         *      or increase the spikiness of rendered text.
         * @param {number} [style.padding=0] - Occasionally some fonts are cropped. Adding some padding will prevent this from
         *     happening by adding padding to all sides of the text.
         * @param {string|number} [style.stroke='black'] - A canvas fillstyle that will be used on the text stroke
         *  e.g 'blue', '#FCFF00'
         * @param {number} [style.strokeThickness=0] - A number that represents the thickness of the stroke.
         *  Default is 0 (no stroke)
         * @param {boolean} [style.trim=false] - Trim transparent borders
         * @param {string} [style.textBaseline='alphabetic'] - The baseline of the text that is rendered.
         * @param {boolean} [style.whiteSpace='pre'] - Determines whether newlines & spaces are collapsed or preserved "normal"
         *      (collapse, collapse), "pre" (preserve, preserve) | "pre-line" (preserve, collapse). It needs wordWrap to be set to true
         * @param {boolean} [style.wordWrap=false] - Indicates if word wrap should be used
         * @param {number} [style.wordWrapWidth=100] - The width at which text will wrap, it needs wordWrap to be set to true
         */
        function TextStyle(style) {
          _classCallCheck(this, TextStyle);

          this.styleID = 0;

          this.reset();

          deepCopyProperties(this, style, style);
        }

        /**
         * Creates a new TextStyle object with the same values as this one.
         * Note that the only the properties of the object are cloned.
         *
         * @return {PIXI.TextStyle} New cloned TextStyle object
         */

        TextStyle.prototype.clone = function clone() {
          var clonedProperties = {};

          deepCopyProperties(clonedProperties, this, defaultStyle);

          return new TextStyle(clonedProperties);
        };

        /**
         * Resets all properties to the defaults specified in TextStyle.prototype._default
         */

        TextStyle.prototype.reset = function reset() {
          deepCopyProperties(this, defaultStyle, defaultStyle);
        };

        /**
         * Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
         *
         * @member {string}
         */

        /**
         * Generates a font style string to use for `TextMetrics.measureFont()`.
         *
         * @return {string} Font style string, for passing to `TextMetrics.measureFont()`
         */
        TextStyle.prototype.toFontString = function toFontString() {
          // build canvas api font setting from individual components. Convert a numeric this.fontSize to px
          var fontSizeString = typeof this.fontSize === "number" ? this.fontSize + "px" : this.fontSize;

          // Clean-up fontFamily property by quoting each font name
          // this will support font names with spaces
          var fontFamilies = this.fontFamily;

          if (!Array.isArray(this.fontFamily)) {
            fontFamilies = this.fontFamily.split(",");
          }

          for (var i = fontFamilies.length - 1; i >= 0; i--) {
            // Trim any extra white-space
            var fontFamily = fontFamilies[i].trim();

            // Check if font is already escaped in quotes except for CSS generic fonts
            if (!/([\"\'])[^\'\"]+\1/.test(fontFamily) && genericFontFamilies.indexOf(fontFamily) < 0) {
              fontFamily = '"' + fontFamily + '"';
            }
            fontFamilies[i] = fontFamily;
          }

          return this.fontStyle + " " + this.fontVariant + " " + this.fontWeight + " " + fontSizeString + " " + fontFamilies.join(",");
        };

        _createClass(TextStyle, [
          {
            key: "align",
            get: function get() {
              return this._align;
            },
            set: function set(
              align // eslint-disable-line require-jsdoc
            ) {
              if (this._align !== align) {
                this._align = align;
                this.styleID++;
              }
            },

            /**
             * Indicates if lines can be wrapped within words, it needs wordWrap to be set to true
             *
             * @member {boolean}
             */
          },
          {
            key: "breakWords",
            get: function get() {
              return this._breakWords;
            },
            set: function set(
              breakWords // eslint-disable-line require-jsdoc
            ) {
              if (this._breakWords !== breakWords) {
                this._breakWords = breakWords;
                this.styleID++;
              }
            },

            /**
             * Set a drop shadow for the text
             *
             * @member {boolean}
             */
          },
          {
            key: "dropShadow",
            get: function get() {
              return this._dropShadow;
            },
            set: function set(
              dropShadow // eslint-disable-line require-jsdoc
            ) {
              if (this._dropShadow !== dropShadow) {
                this._dropShadow = dropShadow;
                this.styleID++;
              }
            },

            /**
             * Set alpha for the drop shadow
             *
             * @member {number}
             */
          },
          {
            key: "dropShadowAlpha",
            get: function get() {
              return this._dropShadowAlpha;
            },
            set: function set(
              dropShadowAlpha // eslint-disable-line require-jsdoc
            ) {
              if (this._dropShadowAlpha !== dropShadowAlpha) {
                this._dropShadowAlpha = dropShadowAlpha;
                this.styleID++;
              }
            },

            /**
             * Set a angle of the drop shadow
             *
             * @member {number}
             */
          },
          {
            key: "dropShadowAngle",
            get: function get() {
              return this._dropShadowAngle;
            },
            set: function set(
              dropShadowAngle // eslint-disable-line require-jsdoc
            ) {
              if (this._dropShadowAngle !== dropShadowAngle) {
                this._dropShadowAngle = dropShadowAngle;
                this.styleID++;
              }
            },

            /**
             * Set a shadow blur radius
             *
             * @member {number}
             */
          },
          {
            key: "dropShadowBlur",
            get: function get() {
              return this._dropShadowBlur;
            },
            set: function set(
              dropShadowBlur // eslint-disable-line require-jsdoc
            ) {
              if (this._dropShadowBlur !== dropShadowBlur) {
                this._dropShadowBlur = dropShadowBlur;
                this.styleID++;
              }
            },

            /**
             * A fill style to be used on the dropshadow e.g 'red', '#00FF00'
             *
             * @member {string|number}
             */
          },
          {
            key: "dropShadowColor",
            get: function get() {
              return this._dropShadowColor;
            },
            set: function set(
              dropShadowColor // eslint-disable-line require-jsdoc
            ) {
              var outputColor = getColor(dropShadowColor);
              if (this._dropShadowColor !== outputColor) {
                this._dropShadowColor = outputColor;
                this.styleID++;
              }
            },

            /**
             * Set a distance of the drop shadow
             *
             * @member {number}
             */
          },
          {
            key: "dropShadowDistance",
            get: function get() {
              return this._dropShadowDistance;
            },
            set: function set(
              dropShadowDistance // eslint-disable-line require-jsdoc
            ) {
              if (this._dropShadowDistance !== dropShadowDistance) {
                this._dropShadowDistance = dropShadowDistance;
                this.styleID++;
              }
            },

            /**
             * A canvas fillstyle that will be used on the text e.g 'red', '#00FF00'.
             * Can be an array to create a gradient eg ['#000000','#FFFFFF']
             * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}
             *
             * @member {string|string[]|number|number[]|CanvasGradient|CanvasPattern}
             */
          },
          {
            key: "fill",
            get: function get() {
              return this._fill;
            },
            set: function set(
              fill // eslint-disable-line require-jsdoc
            ) {
              var outputColor = getColor(fill);
              if (this._fill !== outputColor) {
                this._fill = outputColor;
                this.styleID++;
              }
            },

            /**
             * If fill is an array of colours to create a gradient, this can change the type/direction of the gradient.
             * See {@link PIXI.TEXT_GRADIENT}
             *
             * @member {number}
             */
          },
          {
            key: "fillGradientType",
            get: function get() {
              return this._fillGradientType;
            },
            set: function set(
              fillGradientType // eslint-disable-line require-jsdoc
            ) {
              if (this._fillGradientType !== fillGradientType) {
                this._fillGradientType = fillGradientType;
                this.styleID++;
              }
            },

            /**
             * If fill is an array of colours to create a gradient, this array can set the stop points
             * (numbers between 0 and 1) for the color, overriding the default behaviour of evenly spacing them.
             *
             * @member {number[]}
             */
          },
          {
            key: "fillGradientStops",
            get: function get() {
              return this._fillGradientStops;
            },
            set: function set(
              fillGradientStops // eslint-disable-line require-jsdoc
            ) {
              if (!areArraysEqual(this._fillGradientStops, fillGradientStops)) {
                this._fillGradientStops = fillGradientStops;
                this.styleID++;
              }
            },

            /**
             * The font family
             *
             * @member {string|string[]}
             */
          },
          {
            key: "fontFamily",
            get: function get() {
              return this._fontFamily;
            },
            set: function set(
              fontFamily // eslint-disable-line require-jsdoc
            ) {
              if (this.fontFamily !== fontFamily) {
                this._fontFamily = fontFamily;
                this.styleID++;
              }
            },

            /**
             * The font size
             * (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em')
             *
             * @member {number|string}
             */
          },
          {
            key: "fontSize",
            get: function get() {
              return this._fontSize;
            },
            set: function set(
              fontSize // eslint-disable-line require-jsdoc
            ) {
              if (this._fontSize !== fontSize) {
                this._fontSize = fontSize;
                this.styleID++;
              }
            },

            /**
             * The font style
             * ('normal', 'italic' or 'oblique')
             *
             * @member {string}
             */
          },
          {
            key: "fontStyle",
            get: function get() {
              return this._fontStyle;
            },
            set: function set(
              fontStyle // eslint-disable-line require-jsdoc
            ) {
              if (this._fontStyle !== fontStyle) {
                this._fontStyle = fontStyle;
                this.styleID++;
              }
            },

            /**
             * The font variant
             * ('normal' or 'small-caps')
             *
             * @member {string}
             */
          },
          {
            key: "fontVariant",
            get: function get() {
              return this._fontVariant;
            },
            set: function set(
              fontVariant // eslint-disable-line require-jsdoc
            ) {
              if (this._fontVariant !== fontVariant) {
                this._fontVariant = fontVariant;
                this.styleID++;
              }
            },

            /**
             * The font weight
             * ('normal', 'bold', 'bolder', 'lighter' and '100', '200', '300', '400', '500', '600', '700', 800' or '900')
             *
             * @member {string}
             */
          },
          {
            key: "fontWeight",
            get: function get() {
              return this._fontWeight;
            },
            set: function set(
              fontWeight // eslint-disable-line require-jsdoc
            ) {
              if (this._fontWeight !== fontWeight) {
                this._fontWeight = fontWeight;
                this.styleID++;
              }
            },

            /**
             * The amount of spacing between letters, default is 0
             *
             * @member {number}
             */
          },
          {
            key: "letterSpacing",
            get: function get() {
              return this._letterSpacing;
            },
            set: function set(
              letterSpacing // eslint-disable-line require-jsdoc
            ) {
              if (this._letterSpacing !== letterSpacing) {
                this._letterSpacing = letterSpacing;
                this.styleID++;
              }
            },

            /**
             * The line height, a number that represents the vertical space that a letter uses
             *
             * @member {number}
             */
          },
          {
            key: "lineHeight",
            get: function get() {
              return this._lineHeight;
            },
            set: function set(
              lineHeight // eslint-disable-line require-jsdoc
            ) {
              if (this._lineHeight !== lineHeight) {
                this._lineHeight = lineHeight;
                this.styleID++;
              }
            },

            /**
             * The space between lines
             *
             * @member {number}
             */
          },
          {
            key: "leading",
            get: function get() {
              return this._leading;
            },
            set: function set(
              leading // eslint-disable-line require-jsdoc
            ) {
              if (this._leading !== leading) {
                this._leading = leading;
                this.styleID++;
              }
            },

            /**
             * The lineJoin property sets the type of corner created, it can resolve spiked text issues.
             * Default is 'miter' (creates a sharp corner).
             *
             * @member {string}
             */
          },
          {
            key: "lineJoin",
            get: function get() {
              return this._lineJoin;
            },
            set: function set(
              lineJoin // eslint-disable-line require-jsdoc
            ) {
              if (this._lineJoin !== lineJoin) {
                this._lineJoin = lineJoin;
                this.styleID++;
              }
            },

            /**
             * The miter limit to use when using the 'miter' lineJoin mode
             * This can reduce or increase the spikiness of rendered text.
             *
             * @member {number}
             */
          },
          {
            key: "miterLimit",
            get: function get() {
              return this._miterLimit;
            },
            set: function set(
              miterLimit // eslint-disable-line require-jsdoc
            ) {
              if (this._miterLimit !== miterLimit) {
                this._miterLimit = miterLimit;
                this.styleID++;
              }
            },

            /**
             * Occasionally some fonts are cropped. Adding some padding will prevent this from happening
             * by adding padding to all sides of the text.
             *
             * @member {number}
             */
          },
          {
            key: "padding",
            get: function get() {
              return this._padding;
            },
            set: function set(
              padding // eslint-disable-line require-jsdoc
            ) {
              if (this._padding !== padding) {
                this._padding = padding;
                this.styleID++;
              }
            },

            /**
             * A canvas fillstyle that will be used on the text stroke
             * e.g 'blue', '#FCFF00'
             *
             * @member {string|number}
             */
          },
          {
            key: "stroke",
            get: function get() {
              return this._stroke;
            },
            set: function set(
              stroke // eslint-disable-line require-jsdoc
            ) {
              var outputColor = getColor(stroke);
              if (this._stroke !== outputColor) {
                this._stroke = outputColor;
                this.styleID++;
              }
            },

            /**
             * A number that represents the thickness of the stroke.
             * Default is 0 (no stroke)
             *
             * @member {number}
             */
          },
          {
            key: "strokeThickness",
            get: function get() {
              return this._strokeThickness;
            },
            set: function set(
              strokeThickness // eslint-disable-line require-jsdoc
            ) {
              if (this._strokeThickness !== strokeThickness) {
                this._strokeThickness = strokeThickness;
                this.styleID++;
              }
            },

            /**
             * The baseline of the text that is rendered.
             *
             * @member {string}
             */
          },
          {
            key: "textBaseline",
            get: function get() {
              return this._textBaseline;
            },
            set: function set(
              textBaseline // eslint-disable-line require-jsdoc
            ) {
              if (this._textBaseline !== textBaseline) {
                this._textBaseline = textBaseline;
                this.styleID++;
              }
            },

            /**
             * Trim transparent borders
             *
             * @member {boolean}
             */
          },
          {
            key: "trim",
            get: function get() {
              return this._trim;
            },
            set: function set(
              trim // eslint-disable-line require-jsdoc
            ) {
              if (this._trim !== trim) {
                this._trim = trim;
                this.styleID++;
              }
            },

            /**
             * How newlines and spaces should be handled.
             * Default is 'pre' (preserve, preserve).
             *
             *  value       | New lines     |   Spaces
             *  ---         | ---           |   ---
             * 'normal'     | Collapse      |   Collapse
             * 'pre'        | Preserve      |   Preserve
             * 'pre-line'   | Preserve      |   Collapse
             *
             * @member {string}
             */
          },
          {
            key: "whiteSpace",
            get: function get() {
              return this._whiteSpace;
            },
            set: function set(
              whiteSpace // eslint-disable-line require-jsdoc
            ) {
              if (this._whiteSpace !== whiteSpace) {
                this._whiteSpace = whiteSpace;
                this.styleID++;
              }
            },

            /**
             * Indicates if word wrap should be used
             *
             * @member {boolean}
             */
          },
          {
            key: "wordWrap",
            get: function get() {
              return this._wordWrap;
            },
            set: function set(
              wordWrap // eslint-disable-line require-jsdoc
            ) {
              if (this._wordWrap !== wordWrap) {
                this._wordWrap = wordWrap;
                this.styleID++;
              }
            },

            /**
             * The width at which text will wrap, it needs wordWrap to be set to true
             *
             * @member {number}
             */
          },
          {
            key: "wordWrapWidth",
            get: function get() {
              return this._wordWrapWidth;
            },
            set: function set(
              wordWrapWidth // eslint-disable-line require-jsdoc
            ) {
              if (this._wordWrapWidth !== wordWrapWidth) {
                this._wordWrapWidth = wordWrapWidth;
                this.styleID++;
              }
            },
          },
        ]);

        return TextStyle;
      })();

      /**
       * Utility function to convert hexadecimal colors to strings, and simply return the color if it's a string.
       * @private
       * @param {number|number[]} color
       * @return {string} The color as a string.
       */

      exports.default = TextStyle;
      function getSingleColor(color) {
        if (typeof color === "number") {
          return (0, _utils.hex2string)(color);
        } else if (typeof color === "string") {
          if (color.indexOf("0x") === 0) {
            color = color.replace("0x", "#");
          }
        }

        return color;
      }

      /**
       * Utility function to convert hexadecimal colors to strings, and simply return the color if it's a string.
       * This version can also convert array of colors
       * @private
       * @param {number|number[]} color
       * @return {string} The color as a string.
       */
      function getColor(color) {
        if (!Array.isArray(color)) {
          return getSingleColor(color);
        } else {
          for (var i = 0; i < color.length; ++i) {
            color[i] = getSingleColor(color[i]);
          }

          return color;
        }
      }

      /**
       * Utility function to convert hexadecimal colors to strings, and simply return the color if it's a string.
       * This version can also convert array of colors
       * @private
       * @param {Array} array1 First array to compare
       * @param {Array} array2 Second array to compare
       * @return {boolean} Do the arrays contain the same values in the same order
       */
      function areArraysEqual(array1, array2) {
        if (!Array.isArray(array1) || !Array.isArray(array2)) {
          return false;
        }

        if (array1.length !== array2.length) {
          return false;
        }

        for (var i = 0; i < array1.length; ++i) {
          if (array1[i] !== array2[i]) {
            return false;
          }
        }

        return true;
      }

      /**
       * Utility function to ensure that object properties are copied by value, and not by reference
       * @private
       * @param {Object} target Target object to copy properties into
       * @param {Object} source Source object for the proporties to copy
       * @param {string} propertyObj Object containing properties names we want to loop over
       */
      function deepCopyProperties(target, source, propertyObj) {
        for (var prop in propertyObj) {
          if (Array.isArray(source[prop])) {
            target[prop] = source[prop].slice();
          } else {
            target[prop] = source[prop];
          }
        }
      }
      //# sourceMappingURL=TextStyle.js.map

      /***/
    },
    /* 420 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      /**
       * The TextMetrics object represents the measurement of a block of text with a specified style.
       *
       * ```js
       * let style = new PIXI.TextStyle({fontFamily : 'Arial', fontSize: 24, fill : 0xff1010, align : 'center'})
       * let textMetrics = PIXI.TextMetrics.measureText('Your text', style)
       * ```
       *
       * @class
       * @memberOf PIXI
       */
      var TextMetrics = (function () {
        /**
         * @param {string} text - the text that was measured
         * @param {PIXI.TextStyle} style - the style that was measured
         * @param {number} width - the measured width of the text
         * @param {number} height - the measured height of the text
         * @param {array} lines - an array of the lines of text broken by new lines and wrapping if specified in style
         * @param {array} lineWidths - an array of the line widths for each line matched to `lines`
         * @param {number} lineHeight - the measured line height for this style
         * @param {number} maxLineWidth - the maximum line width for all measured lines
         * @param {Object} fontProperties - the font properties object from TextMetrics.measureFont
         */
        function TextMetrics(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
          _classCallCheck(this, TextMetrics);

          this.text = text;
          this.style = style;
          this.width = width;
          this.height = height;
          this.lines = lines;
          this.lineWidths = lineWidths;
          this.lineHeight = lineHeight;
          this.maxLineWidth = maxLineWidth;
          this.fontProperties = fontProperties;
        }

        /**
         * Measures the supplied string of text and returns a Rectangle.
         *
         * @param {string} text - the text to measure.
         * @param {PIXI.TextStyle} style - the text style to use for measuring
         * @param {boolean} [wordWrap] - optional override for if word-wrap should be applied to the text.
         * @param {HTMLCanvasElement} [canvas] - optional specification of the canvas to use for measuring.
         * @return {PIXI.TextMetrics} measured width and height of the text.
         */

        TextMetrics.measureText = function measureText(text, style, wordWrap) {
          var canvas = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : TextMetrics._canvas;

          wordWrap = wordWrap === undefined || wordWrap === null ? style.wordWrap : wordWrap;
          var font = style.toFontString();
          var fontProperties = TextMetrics.measureFont(font);
          var context = canvas.getContext("2d");

          context.font = font;

          var outputText = wordWrap ? TextMetrics.wordWrap(text, style, canvas) : text;
          var lines = outputText.split(/(?:\r\n|\r|\n)/);
          var lineWidths = new Array(lines.length);
          var maxLineWidth = 0;

          for (var i = 0; i < lines.length; i++) {
            var lineWidth = context.measureText(lines[i]).width + (lines[i].length - 1) * style.letterSpacing;

            lineWidths[i] = lineWidth;
            maxLineWidth = Math.max(maxLineWidth, lineWidth);
          }
          var width = maxLineWidth + style.strokeThickness;

          if (style.dropShadow) {
            width += style.dropShadowDistance;
          }

          var lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;
          var height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness) + (lines.length - 1) * (lineHeight + style.leading);

          if (style.dropShadow) {
            height += style.dropShadowDistance;
          }

          return new TextMetrics(text, style, width, height, lines, lineWidths, lineHeight + style.leading, maxLineWidth, fontProperties);
        };

        /**
         * Applies newlines to a string to have it optimally fit into the horizontal
         * bounds set by the Text object's wordWrapWidth property.
         *
         * @private
         * @param {string} text - String to apply word wrapping to
         * @param {PIXI.TextStyle} style - the style to use when wrapping
         * @param {HTMLCanvasElement} [canvas] - optional specification of the canvas to use for measuring.
         * @return {string} New string with new lines applied where required
         */

        TextMetrics.wordWrap = function wordWrap(text, style) {
          var canvas = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TextMetrics._canvas;

          var context = canvas.getContext("2d");

          var width = 0;
          var line = "";
          var lines = "";

          var cache = {};
          var letterSpacing = style.letterSpacing,
            whiteSpace = style.whiteSpace;

          // How to handle whitespaces

          var collapseSpaces = TextMetrics.collapseSpaces(whiteSpace);
          var collapseNewlines = TextMetrics.collapseNewlines(whiteSpace);

          // whether or not spaces may be added to the beginning of lines
          var canPrependSpaces = !collapseSpaces;

          // There is letterSpacing after every char except the last one
          // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!
          // so for convenience the above needs to be compared to width + 1 extra letterSpace
          // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!_
          // ________________________________________________
          // And then the final space is simply no appended to each line
          var wordWrapWidth = style.wordWrapWidth + letterSpacing;

          // break text into words, spaces and newline chars
          var tokens = TextMetrics.tokenize(text);

          for (var i = 0; i < tokens.length; i++) {
            // get the word, space or newlineChar
            var token = tokens[i];

            // if word is a new line
            if (TextMetrics.isNewline(token)) {
              // keep the new line
              if (!collapseNewlines) {
                lines += TextMetrics.addLine(line);
                canPrependSpaces = !collapseSpaces;
                line = "";
                width = 0;
                continue;
              }

              // if we should collapse new lines
              // we simply convert it into a space
              token = " ";
            }

            // if we should collapse repeated whitespaces
            if (collapseSpaces) {
              // check both this and the last tokens for spaces
              var currIsBreakingSpace = TextMetrics.isBreakingSpace(token);
              var lastIsBreakingSpace = TextMetrics.isBreakingSpace(line[line.length - 1]);

              if (currIsBreakingSpace && lastIsBreakingSpace) {
                continue;
              }
            }

            // get word width from cache if possible
            var tokenWidth = TextMetrics.getFromCache(token, letterSpacing, cache, context);

            // word is longer than desired bounds
            if (tokenWidth > wordWrapWidth) {
              // if we are not already at the beginning of a line
              if (line !== "") {
                // start newlines for overflow words
                lines += TextMetrics.addLine(line);
                line = "";
                width = 0;
              }

              // break large word over multiple lines
              if (TextMetrics.canBreakWords(token, style.breakWords)) {
                // break word into characters
                var characters = token.split("");

                // loop the characters
                for (var j = 0; j < characters.length; j++) {
                  var char = characters[j];

                  var k = 1;
                  // we are not at the end of the token

                  while (characters[j + k]) {
                    var nextChar = characters[j + k];
                    var lastChar = char[char.length - 1];

                    // should not split chars
                    if (!TextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) {
                      // combine chars & move forward one
                      char += nextChar;
                    } else {
                      break;
                    }

                    k++;
                  }

                  j += char.length - 1;

                  var characterWidth = TextMetrics.getFromCache(char, letterSpacing, cache, context);

                  if (characterWidth + width > wordWrapWidth) {
                    lines += TextMetrics.addLine(line);
                    canPrependSpaces = false;
                    line = "";
                    width = 0;
                  }

                  line += char;
                  width += characterWidth;
                }
              }

              // run word out of the bounds
              else {
                // if there are words in this line already
                // finish that line and start a new one
                if (line.length > 0) {
                  lines += TextMetrics.addLine(line);
                  line = "";
                  width = 0;
                }

                var isLastToken = i === tokens.length - 1;

                // give it its own line if it's not the end
                lines += TextMetrics.addLine(token, !isLastToken);
                canPrependSpaces = false;
                line = "";
                width = 0;
              }
            }

            // word could fit
            else {
              // word won't fit because of existing words
              // start a new line
              if (tokenWidth + width > wordWrapWidth) {
                // if its a space we don't want it
                canPrependSpaces = false;

                // add a new line
                lines += TextMetrics.addLine(line);

                // start a new line
                line = "";
                width = 0;
              }

              // don't add spaces to the beginning of lines
              if (line.length > 0 || !TextMetrics.isBreakingSpace(token) || canPrependSpaces) {
                // add the word to the current line
                line += token;

                // update width counter
                width += tokenWidth;
              }
            }
          }

          lines += TextMetrics.addLine(line, false);

          return lines;
        };

        /**
         * Convienience function for logging each line added during the wordWrap
         * method
         *
         * @private
         * @param  {string}   line        - The line of text to add
         * @param  {boolean}  newLine     - Add new line character to end
         * @return {string}   A formatted line
         */

        TextMetrics.addLine = function addLine(line) {
          var newLine = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

          line = TextMetrics.trimRight(line);

          line = newLine ? line + "\n" : line;

          return line;
        };

        /**
         * Gets & sets the widths of calculated characters in a cache object
         *
         * @private
         * @param  {string}                    key            The key
         * @param  {number}                    letterSpacing  The letter spacing
         * @param  {object}                    cache          The cache
         * @param  {CanvasRenderingContext2D}  context        The canvas context
         * @return {number}                    The from cache.
         */

        TextMetrics.getFromCache = function getFromCache(key, letterSpacing, cache, context) {
          var width = cache[key];

          if (width === undefined) {
            var spacing = key.length * letterSpacing;

            width = context.measureText(key).width + spacing;
            cache[key] = width;
          }

          return width;
        };

        /**
         * Determines whether we should collapse breaking spaces
         *
         * @private
         * @param  {string}   whiteSpace  The TextStyle property whiteSpace
         * @return {boolean}  should collapse
         */

        TextMetrics.collapseSpaces = function collapseSpaces(whiteSpace) {
          return whiteSpace === "normal" || whiteSpace === "pre-line";
        };

        /**
         * Determines whether we should collapse newLine chars
         *
         * @private
         * @param  {string}   whiteSpace  The white space
         * @return {boolean}  should collapse
         */

        TextMetrics.collapseNewlines = function collapseNewlines(whiteSpace) {
          return whiteSpace === "normal";
        };

        /**
         * trims breaking whitespaces from string
         *
         * @private
         * @param  {string}  text  The text
         * @return {string}  trimmed string
         */

        TextMetrics.trimRight = function trimRight(text) {
          if (typeof text !== "string") {
            return "";
          }

          for (var i = text.length - 1; i >= 0; i--) {
            var char = text[i];

            if (!TextMetrics.isBreakingSpace(char)) {
              break;
            }

            text = text.slice(0, -1);
          }

          return text;
        };

        /**
         * Determines if char is a newline.
         *
         * @private
         * @param  {string}  char  The character
         * @return {boolean}  True if newline, False otherwise.
         */

        TextMetrics.isNewline = function isNewline(char) {
          if (typeof char !== "string") {
            return false;
          }

          return TextMetrics._newlines.indexOf(char.charCodeAt(0)) >= 0;
        };

        /**
         * Determines if char is a breaking whitespace.
         *
         * @private
         * @param  {string}  char  The character
         * @return {boolean}  True if whitespace, False otherwise.
         */

        TextMetrics.isBreakingSpace = function isBreakingSpace(char) {
          if (typeof char !== "string") {
            return false;
          }

          return TextMetrics._breakingSpaces.indexOf(char.charCodeAt(0)) >= 0;
        };

        /**
         * Splits a string into words, breaking-spaces and newLine characters
         *
         * @private
         * @param  {string}  text       The text
         * @return {array}  A tokenized array
         */

        TextMetrics.tokenize = function tokenize(text) {
          var tokens = [];
          var token = "";

          if (typeof text !== "string") {
            return tokens;
          }

          for (var i = 0; i < text.length; i++) {
            var char = text[i];

            if (TextMetrics.isBreakingSpace(char) || TextMetrics.isNewline(char)) {
              if (token !== "") {
                tokens.push(token);
                token = "";
              }

              tokens.push(char);

              continue;
            }

            token += char;
          }

          if (token !== "") {
            tokens.push(token);
          }

          return tokens;
        };

        /**
         * This method exists to be easily overridden
         * It allows one to customise which words should break
         * Examples are if the token is CJK or numbers.
         * It must return a boolean.
         *
         * @private
         * @param  {string}  token       The token
         * @param  {boolean}  breakWords  The style attr break words
         * @return {boolean} whether to break word or not
         */

        TextMetrics.canBreakWords = function canBreakWords(token, breakWords) {
          return breakWords;
        };

        /**
         * This method exists to be easily overridden
         * It allows one to determine whether a pair of characters
         * should be broken by newlines
         * For example certain characters in CJK langs or numbers.
         * It must return a boolean.
         *
         * @private
         * @param  {string}  char      The character
         * @param  {string}  nextChar  The next character
         * @param  {string}  token     The token/word the characters are from
         * @param  {number}  index     The index in the token of the char
         * @param  {boolean}  breakWords  The style attr break words
         * @return {boolean} whether to break word or not
         */

        TextMetrics.canBreakChars = function canBreakChars(
          char,
          nextChar,
          token,
          index,
          breakWords // eslint-disable-line no-unused-vars
        ) {
          return true;
        };

        /**
         * Calculates the ascent, descent and fontSize of a given font-style
         *
         * @static
         * @param {string} font - String representing the style of the font
         * @return {PIXI.TextMetrics~FontMetrics} Font properties object
         */

        TextMetrics.measureFont = function measureFont(font) {
          // as this method is used for preparing assets, don't recalculate things if we don't need to
          if (TextMetrics._fonts[font]) {
            return TextMetrics._fonts[font];
          }

          var properties = {};

          var canvas = TextMetrics._canvas;
          var context = TextMetrics._context;

          context.font = font;

          var metricsString = TextMetrics.METRICS_STRING + TextMetrics.BASELINE_SYMBOL;
          var width = Math.ceil(context.measureText(metricsString).width);
          var baseline = Math.ceil(context.measureText(TextMetrics.BASELINE_SYMBOL).width);
          var height = 2 * baseline;

          baseline = (baseline * TextMetrics.BASELINE_MULTIPLIER) | 0;

          canvas.width = width;
          canvas.height = height;

          context.fillStyle = "#f00";
          context.fillRect(0, 0, width, height);

          context.font = font;

          context.textBaseline = "alphabetic";
          context.fillStyle = "#000";
          context.fillText(metricsString, 0, baseline);

          var imagedata = context.getImageData(0, 0, width, height).data;
          var pixels = imagedata.length;
          var line = width * 4;

          var i = 0;
          var idx = 0;
          var stop = false;

          // ascent. scan from top to bottom until we find a non red pixel
          for (i = 0; i < baseline; ++i) {
            for (var j = 0; j < line; j += 4) {
              if (imagedata[idx + j] !== 255) {
                stop = true;
                break;
              }
            }
            if (!stop) {
              idx += line;
            } else {
              break;
            }
          }

          properties.ascent = baseline - i;

          idx = pixels - line;
          stop = false;

          // descent. scan from bottom to top until we find a non red pixel
          for (i = height; i > baseline; --i) {
            for (var _j = 0; _j < line; _j += 4) {
              if (imagedata[idx + _j] !== 255) {
                stop = true;
                break;
              }
            }

            if (!stop) {
              idx -= line;
            } else {
              break;
            }
          }

          properties.descent = i - baseline;
          properties.fontSize = properties.ascent + properties.descent;

          TextMetrics._fonts[font] = properties;

          return properties;
        };

        /**
         * Clear font metrics in metrics cache.
         *
         * @static
         * @param {string} [font] - font name. If font name not set then clear cache for all fonts.
         */

        TextMetrics.clearMetrics = function clearMetrics() {
          var font = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

          if (font) {
            delete TextMetrics._fonts[font];
          } else {
            TextMetrics._fonts = {};
          }
        };

        return TextMetrics;
      })();

      /**
       * Internal return object for {@link PIXI.TextMetrics.measureFont `TextMetrics.measureFont`}.
       * @class FontMetrics
       * @memberof PIXI.TextMetrics~
       * @property {number} ascent - The ascent distance
       * @property {number} descent - The descent distance
       * @property {number} fontSize - Font size from ascent to descent
       */

      exports.default = TextMetrics;
      var canvas = document.createElement("canvas");

      canvas.width = canvas.height = 10;

      /**
       * Cached canvas element for measuring text
       * @memberof PIXI.TextMetrics
       * @type {HTMLCanvasElement}
       * @private
       */
      TextMetrics._canvas = canvas;

      /**
       * Cache for context to use.
       * @memberof PIXI.TextMetrics
       * @type {CanvasRenderingContext2D}
       * @private
       */
      TextMetrics._context = canvas.getContext("2d");

      /**
       * Cache of PIXI.TextMetrics~FontMetrics objects.
       * @memberof PIXI.TextMetrics
       * @type {Object}
       * @private
       */
      TextMetrics._fonts = {};

      /**
       * String used for calculate font metrics.
       * @static
       * @memberof PIXI.TextMetrics
       * @name METRICS_STRING
       * @type {string}
       * @default |Éq
       */
      TextMetrics.METRICS_STRING = "|Éq";

      /**
       * Baseline symbol for calculate font metrics.
       * @static
       * @memberof PIXI.TextMetrics
       * @name BASELINE_SYMBOL
       * @type {string}
       * @default M
       */
      TextMetrics.BASELINE_SYMBOL = "M";

      /**
       * Baseline multiplier for calculate font metrics.
       * @static
       * @memberof PIXI.TextMetrics
       * @name BASELINE_MULTIPLIER
       * @type {number}
       * @default 1.4
       */
      TextMetrics.BASELINE_MULTIPLIER = 1.4;

      /**
       * Cache of new line chars.
       * @memberof PIXI.TextMetrics
       * @type {number[]}
       * @private
       */
      TextMetrics._newlines = [
        0x000a, // line feed
        0x000d,
      ];

      /**
       * Cache of breaking spaces.
       * @memberof PIXI.TextMetrics
       * @type {number[]}
       * @private
       */
      TextMetrics._breakingSpaces = [
        0x0009, // character tabulation
        0x0020, // space
        0x2000, // en quad
        0x2001, // em quad
        0x2002, // en space
        0x2003, // em space
        0x2004, // three-per-em space
        0x2005, // four-per-em space
        0x2006, // six-per-em space
        0x2008, // punctuation space
        0x2009, // thin space
        0x200a, // hair space
        0x205f, // medium mathematical space
        0x3000,
      ];
      //# sourceMappingURL=TextMetrics.js.map

      /***/
    },
    /* 421 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      /**
       * A GraphicsData object.
       *
       * @class
       * @memberof PIXI
       */
      var GraphicsData = (function () {
        /**
         *
         * @param {number} lineWidth - the width of the line to draw
         * @param {number} lineColor - the color of the line to draw
         * @param {number} lineAlpha - the alpha of the line to draw
         * @param {number} fillColor - the color of the fill
         * @param {number} fillAlpha - the alpha of the fill
         * @param {boolean} fill - whether or not the shape is filled with a colour
         * @param {boolean} nativeLines - the method for drawing lines
         * @param {PIXI.Circle|PIXI.Rectangle|PIXI.Ellipse|PIXI.Polygon} shape - The shape object to draw.
         * @param {number} lineAlignment - the alignment of the line.
         */
        function GraphicsData(lineWidth, lineColor, lineAlpha, fillColor, fillAlpha, fill, nativeLines, shape, lineAlignment) {
          _classCallCheck(this, GraphicsData);

          /**
           * the width of the line to draw
           * @member {number}
           */
          this.lineWidth = lineWidth;

          /**
           * The alignment of any lines drawn (0.5 = middle, 1 = outter, 0 = inner).
           *
           * @member {number}
           * @default 0
           */
          this.lineAlignment = lineAlignment;

          /**
           * if true the liens will be draw using LINES instead of TRIANGLE_STRIP
           * @member {boolean}
           */
          this.nativeLines = nativeLines;

          /**
           * the color of the line to draw
           * @member {number}
           */
          this.lineColor = lineColor;

          /**
           * the alpha of the line to draw
           * @member {number}
           */
          this.lineAlpha = lineAlpha;

          /**
           * cached tint of the line to draw
           * @member {number}
           * @private
           */
          this._lineTint = lineColor;

          /**
           * the color of the fill
           * @member {number}
           */
          this.fillColor = fillColor;

          /**
           * the alpha of the fill
           * @member {number}
           */
          this.fillAlpha = fillAlpha;

          /**
           * cached tint of the fill
           * @member {number}
           * @private
           */
          this._fillTint = fillColor;

          /**
           * whether or not the shape is filled with a colour
           * @member {boolean}
           */
          this.fill = fill;

          this.holes = [];

          /**
           * The shape object to draw.
           * @member {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle}
           */
          this.shape = shape;

          /**
           * The type of the shape, see the Const.Shapes file for all the existing types,
           * @member {number}
           */
          this.type = shape.type;
        }

        /**
         * Creates a new GraphicsData object with the same values as this one.
         *
         * @return {PIXI.GraphicsData} Cloned GraphicsData object
         */

        GraphicsData.prototype.clone = function clone() {
          return new GraphicsData(
            this.lineWidth,
            this.lineColor,
            this.lineAlpha,
            this.fillColor,
            this.fillAlpha,
            this.fill,
            this.nativeLines,
            this.shape,
            this.lineAlignment
          );
        };

        /**
         * Adds a hole to the shape.
         *
         * @param {PIXI.Rectangle|PIXI.Circle} shape - The shape of the hole.
         */

        GraphicsData.prototype.addHole = function addHole(shape) {
          this.holes.push(shape);
        };

        /**
         * Destroys the Graphics data.
         */

        GraphicsData.prototype.destroy = function destroy() {
          this.shape = null;
          this.holes = null;
        };

        return GraphicsData;
      })();

      exports.default = GraphicsData;
      //# sourceMappingURL=GraphicsData.js.map

      /***/
    },
    /* 422 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      var _createClass = (function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      })();

      var _autoDetectRenderer = __webpack_require__(423);

      var _Container = __webpack_require__(358);

      var _Container2 = _interopRequireDefault(_Container);

      var _ticker = __webpack_require__(383);

      var _settings = __webpack_require__(346);

      var _settings2 = _interopRequireDefault(_settings);

      var _const = __webpack_require__(343);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      /**
       * Convenience class to create a new PIXI application.
       * This class automatically creates the renderer, ticker
       * and root container.
       *
       * @example
       * // Create the application
       * const app = new PIXI.Application();
       *
       * // Add the view to the DOM
       * document.body.appendChild(app.view);
       *
       * // ex, add display objects
       * app.stage.addChild(PIXI.Sprite.fromImage('something.png'));
       *
       * @class
       * @memberof PIXI
       */
      var Application = (function () {
        // eslint-disable-next-line valid-jsdoc
        /**
         * @param {object} [options] - The optional renderer parameters
         * @param {boolean} [options.autoStart=true] - automatically starts the rendering after the construction.
         *     Note that setting this parameter to false does NOT stop the shared ticker even if you set
         *     options.sharedTicker to true in case that it is already started. Stop it by your own.
         * @param {number} [options.width=800] - the width of the renderers view
         * @param {number} [options.height=600] - the height of the renderers view
         * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional
         * @param {boolean} [options.transparent=false] - If the render view is transparent, default false
         * @param {boolean} [options.antialias=false] - sets antialias (only applicable in chrome at the moment)
         * @param {boolean} [options.preserveDrawingBuffer=false] - enables drawing buffer preservation, enable this if you
         *  need to call toDataUrl on the webgl context
         * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer, retina would be 2
         * @param {boolean} [options.forceCanvas=false] - prevents selection of WebGL renderer, even if such is present
         * @param {number} [options.backgroundColor=0x000000] - The background color of the rendered area
         *  (shown if not transparent).
         * @param {boolean} [options.clearBeforeRender=true] - This sets if the renderer will clear the canvas or
         *   not before the new render pass.
         * @param {boolean} [options.roundPixels=false] - If true PixiJS will Math.floor() x/y values when rendering,
         *  stopping pixel interpolation.
         * @param {boolean} [options.forceFXAA=false] - forces FXAA antialiasing to be used over native.
         *  FXAA is faster, but may not always look as great **webgl only**
         * @param {boolean} [options.legacy=false] - `true` to ensure compatibility with older / less advanced devices.
         *  If you experience unexplained flickering try setting this to true. **webgl only**
         * @param {string} [options.powerPreference] - Parameter passed to webgl context, set to "high-performance"
         *  for devices with dual graphics card **webgl only**
         * @param {boolean} [options.sharedTicker=false] - `true` to use PIXI.ticker.shared, `false` to create new ticker.
         * @param {boolean} [options.sharedLoader=false] - `true` to use PIXI.loaders.shared, `false` to create new Loader.
         */
        function Application(options, arg2, arg3, arg4, arg5) {
          _classCallCheck(this, Application);

          // Support for constructor(width, height, options, noWebGL, useSharedTicker)
          if (typeof options === "number") {
            options = Object.assign(
              {
                width: options,
                height: arg2 || _settings2.default.RENDER_OPTIONS.height,
                forceCanvas: !!arg4,
                sharedTicker: !!arg5,
              },
              arg3
            );
          }

          /**
           * The default options, so we mixin functionality later.
           * @member {object}
           * @protected
           */
          this._options = options = Object.assign(
            {
              autoStart: true,
              sharedTicker: false,
              forceCanvas: false,
              sharedLoader: false,
            },
            options
          );

          /**
           * WebGL renderer if available, otherwise CanvasRenderer
           * @member {PIXI.WebGLRenderer|PIXI.CanvasRenderer}
           */
          this.renderer = (0, _autoDetectRenderer.autoDetectRenderer)(options);

          /**
           * The root display container that's rendered.
           * @member {PIXI.Container}
           */
          this.stage = new _Container2.default();

          /**
           * Internal reference to the ticker
           * @member {PIXI.ticker.Ticker}
           * @private
           */
          this._ticker = null;

          /**
           * Ticker for doing render updates.
           * @member {PIXI.ticker.Ticker}
           * @default PIXI.ticker.shared
           */
          this.ticker = options.sharedTicker ? _ticker.shared : new _ticker.Ticker();

          // Start the rendering
          if (options.autoStart) {
            this.start();
          }
        }

        /**
         * Render the current stage.
         */
        Application.prototype.render = function render() {
          this.renderer.render(this.stage);
        };

        /**
         * Convenience method for stopping the render.
         */

        Application.prototype.stop = function stop() {
          this._ticker.stop();
        };

        /**
         * Convenience method for starting the render.
         */

        Application.prototype.start = function start() {
          this._ticker.start();
        };

        /**
         * Reference to the renderer's canvas element.
         * @member {HTMLCanvasElement}
         * @readonly
         */

        /**
         * Destroy and don't use after this.
         * @param {Boolean} [removeView=false] Automatically remove canvas from DOM.
         * @param {object|boolean} [stageOptions] - Options parameter. A boolean will act as if all options
         *  have been set to that value
         * @param {boolean} [stageOptions.children=false] - if set to true, all the children will have their destroy
         *  method called as well. 'stageOptions' will be passed on to those calls.
         * @param {boolean} [stageOptions.texture=false] - Only used for child Sprites if stageOptions.children is set
         *  to true. Should it destroy the texture of the child sprite
         * @param {boolean} [stageOptions.baseTexture=false] - Only used for child Sprites if stageOptions.children is set
         *  to true. Should it destroy the base texture of the child sprite
         */
        Application.prototype.destroy = function destroy(removeView, stageOptions) {
          if (this._ticker) {
            var oldTicker = this._ticker;

            this.ticker = null;
            oldTicker.destroy();
          }

          this.stage.destroy(stageOptions);
          this.stage = null;

          this.renderer.destroy(removeView);
          this.renderer = null;

          this._options = null;
        };

        _createClass(Application, [
          {
            key: "ticker",
            set: function set(
              ticker // eslint-disable-line require-jsdoc
            ) {
              if (this._ticker) {
                this._ticker.remove(this.render, this);
              }
              this._ticker = ticker;
              if (ticker) {
                ticker.add(this.render, this, _const.UPDATE_PRIORITY.LOW);
              }
            },
            get: function get() { // eslint-disable-line require-jsdoc
              return this._ticker;
            },
          },
          {
            key: "view",
            get: function get() {
              return this.renderer.view;
            },

            /**
             * Reference to the renderer's screen rectangle. Its safe to use as filterArea or hitArea for whole screen
             * @member {PIXI.Rectangle}
             * @readonly
             */
          },
          {
            key: "screen",
            get: function get() {
              return this.renderer.screen;
            },
          },
        ]);

        return Application;
      })();

      exports.default = Application;
      //# sourceMappingURL=Application.js.map

      /***/
    },
    /* 423 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;
      exports.autoDetectRenderer = autoDetectRenderer;

      var _utils = __webpack_require__(345);

      var utils = _interopRequireWildcard(_utils);

      var _CanvasRenderer = __webpack_require__(359);

      var _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);

      var _WebGLRenderer = __webpack_require__(366);

      var _WebGLRenderer2 = _interopRequireDefault(_WebGLRenderer);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};
          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }
          newObj.default = obj;
          return newObj;
        }
      }

      // eslint-disable-next-line valid-jsdoc
      /**
       * This helper function will automatically detect which renderer you should be using.
       * WebGL is the preferred renderer as it is a lot faster. If webGL is not supported by
       * the browser then this function will return a canvas renderer
       *
       * @memberof PIXI
       * @function autoDetectRenderer
       * @param {object} [options] - The optional renderer parameters
       * @param {number} [options.width=800] - the width of the renderers view
       * @param {number} [options.height=600] - the height of the renderers view
       * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional
       * @param {boolean} [options.transparent=false] - If the render view is transparent, default false
       * @param {boolean} [options.antialias=false] - sets antialias (only applicable in chrome at the moment)
       * @param {boolean} [options.preserveDrawingBuffer=false] - enables drawing buffer preservation, enable this if you
       *  need to call toDataUrl on the webgl context
       * @param {number} [options.backgroundColor=0x000000] - The background color of the rendered area
       *  (shown if not transparent).
       * @param {boolean} [options.clearBeforeRender=true] - This sets if the renderer will clear the canvas or
       *   not before the new render pass.
       * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer, retina would be 2
       * @param {boolean} [options.forceCanvas=false] - prevents selection of WebGL renderer, even if such is present
       * @param {boolean} [options.roundPixels=false] - If true PixiJS will Math.floor() x/y values when rendering,
       *  stopping pixel interpolation.
       * @param {boolean} [options.forceFXAA=false] - forces FXAA antialiasing to be used over native.
       *  FXAA is faster, but may not always look as great **webgl only**
       * @param {boolean} [options.legacy=false] - `true` to ensure compatibility with older / less advanced devices.
       *  If you experience unexplained flickering try setting this to true. **webgl only**
       * @param {string} [options.powerPreference] - Parameter passed to webgl context, set to "high-performance"
       *  for devices with dual graphics card **webgl only**
       * @return {PIXI.WebGLRenderer|PIXI.CanvasRenderer} Returns WebGL renderer if available, otherwise CanvasRenderer
       */
      function autoDetectRenderer(options, arg1, arg2, arg3) {
        // Backward-compatible support for noWebGL option
        var forceCanvas = options && options.forceCanvas;

        if (arg3 !== undefined) {
          forceCanvas = arg3;
        }

        if (!forceCanvas && utils.isWebGLSupported()) {
          return new _WebGLRenderer2.default(options, arg1, arg2);
        }

        return new _CanvasRenderer2.default(options, arg1, arg2);
      }
      //# sourceMappingURL=autoDetectRenderer.js.map

      /***/
    },
    /* 424 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;
      /**
       * Default property values of accessible objects
       * used by {@link PIXI.accessibility.AccessibilityManager}.
       *
       * @function accessibleTarget
       * @memberof PIXI.accessibility
       * @example
       *      function MyObject() {}
       *
       *      Object.assign(
       *          MyObject.prototype,
       *          PIXI.accessibility.accessibleTarget
       *      );
       */
      exports.default = {
        /**
         *  Flag for if the object is accessible. If true AccessibilityManager will overlay a
         *   shadow div with attributes set
         *
         * @member {boolean}
         */
        accessible: false,

        /**
         * Sets the title attribute of the shadow div
         * If accessibleTitle AND accessibleHint has not been this will default to 'displayObject [tabIndex]'
         *
         * @member {string}
         */
        accessibleTitle: null,

        /**
         * Sets the aria-label attribute of the shadow div
         *
         * @member {string}
         */
        accessibleHint: null,

        /**
         * @todo Needs docs.
         */
        tabIndex: 0,

        /**
         * @todo Needs docs.
         */
        _accessibleActive: false,

        /**
         * @todo Needs docs.
         */
        _accessibleDiv: false,
      };
      //# sourceMappingURL=accessibleTarget.js.map

      /***/
    },
    /* 425 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;
      exports.BitmapText = exports.TilingSpriteRenderer = exports.TilingSprite = exports.AnimatedSprite = undefined;

      var _AnimatedSprite = __webpack_require__(537);

      Object.defineProperty(exports, "AnimatedSprite", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_AnimatedSprite).default;
        },
      });

      var _TilingSprite = __webpack_require__(538);

      Object.defineProperty(exports, "TilingSprite", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_TilingSprite).default;
        },
      });

      var _TilingSpriteRenderer = __webpack_require__(539);

      Object.defineProperty(exports, "TilingSpriteRenderer", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_TilingSpriteRenderer).default;
        },
      });

      var _BitmapText = __webpack_require__(540);

      Object.defineProperty(exports, "BitmapText", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_BitmapText).default;
        },
      });

      __webpack_require__(541);

      __webpack_require__(542);

      __webpack_require__(543);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      // imported for side effect of extending the prototype only, contains no exports
      //# sourceMappingURL=index.js.map

      /***/
    },
    /* 426 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      var _createClass = (function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      })();

      var _core = __webpack_require__(344);

      var core = _interopRequireWildcard(_core);

      var _generateBlurVertSource = __webpack_require__(427);

      var _generateBlurVertSource2 = _interopRequireDefault(_generateBlurVertSource);

      var _generateBlurFragSource = __webpack_require__(428);

      var _generateBlurFragSource2 = _interopRequireDefault(_generateBlurFragSource);

      var _getMaxBlurKernelSize = __webpack_require__(429);

      var _getMaxBlurKernelSize2 = _interopRequireDefault(_getMaxBlurKernelSize);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};
          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }
          newObj.default = obj;
          return newObj;
        }
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: { value: subClass, enumerable: false, writable: true, configurable: true },
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass);
      }

      /**
       * The BlurXFilter applies a horizontal Gaussian blur to an object.
       *
       * @class
       * @extends PIXI.Filter
       * @memberof PIXI.filters
       */
      var BlurXFilter = (function (_core$Filter) {
        _inherits(BlurXFilter, _core$Filter);

        /**
         * @param {number} strength - The strength of the blur filter.
         * @param {number} quality - The quality of the blur filter.
         * @param {number} resolution - The resolution of the blur filter.
         * @param {number} [kernelSize=5] - The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15.
         */
        function BlurXFilter(strength, quality, resolution, kernelSize) {
          _classCallCheck(this, BlurXFilter);

          kernelSize = kernelSize || 5;
          var vertSrc = (0, _generateBlurVertSource2.default)(kernelSize, true);
          var fragSrc = (0, _generateBlurFragSource2.default)(kernelSize);

          var _this = _possibleConstructorReturn(
            this,
            _core$Filter.call(
              this,
              // vertex shader
              vertSrc,
              // fragment shader
              fragSrc
            )
          );

          _this.resolution = resolution || core.settings.RESOLUTION;

          _this._quality = 0;

          _this.quality = quality || 4;
          _this.strength = strength || 8;

          _this.firstRun = true;
          return _this;
        }

        /**
         * Applies the filter.
         *
         * @param {PIXI.FilterManager} filterManager - The manager.
         * @param {PIXI.RenderTarget} input - The input target.
         * @param {PIXI.RenderTarget} output - The output target.
         * @param {boolean} clear - Should the output be cleared before rendering?
         */

        BlurXFilter.prototype.apply = function apply(filterManager, input, output, clear) {
          if (this.firstRun) {
            var gl = filterManager.renderer.gl;
            var kernelSize = (0, _getMaxBlurKernelSize2.default)(gl);

            this.vertexSrc = (0, _generateBlurVertSource2.default)(kernelSize, true);
            this.fragmentSrc = (0, _generateBlurFragSource2.default)(kernelSize);

            this.firstRun = false;
          }

          this.uniforms.strength = (1 / output.size.width) * (output.size.width / input.size.width);

          // screen space!
          this.uniforms.strength *= this.strength;
          this.uniforms.strength /= this.passes; // / this.passes//Math.pow(1, this.passes);

          if (this.passes === 1) {
            filterManager.applyFilter(this, input, output, clear);
          } else {
            var renderTarget = filterManager.getRenderTarget(true);
            var flip = input;
            var flop = renderTarget;

            for (var i = 0; i < this.passes - 1; i++) {
              filterManager.applyFilter(this, flip, flop, true);

              var temp = flop;

              flop = flip;
              flip = temp;
            }

            filterManager.applyFilter(this, flip, output, clear);

            filterManager.returnRenderTarget(renderTarget);
          }
        };

        /**
         * Sets the strength of both the blur.
         *
         * @member {number}
         * @default 16
         */

        _createClass(BlurXFilter, [
          {
            key: "blur",
            get: function get() {
              return this.strength;
            },
            set: function set(
              value // eslint-disable-line require-jsdoc
            ) {
              this.padding = Math.abs(value) * 2;
              this.strength = value;
            },

            /**
             * Sets the quality of the blur by modifying the number of passes. More passes means higher
             * quaility bluring but the lower the performance.
             *
             * @member {number}
             * @default 4
             */
          },
          {
            key: "quality",
            get: function get() {
              return this._quality;
            },
            set: function set(
              value // eslint-disable-line require-jsdoc
            ) {
              this._quality = value;
              this.passes = value;
            },
          },
        ]);

        return BlurXFilter;
      })(core.Filter);

      exports.default = BlurXFilter;
      //# sourceMappingURL=BlurXFilter.js.map

      /***/
    },
    /* 427 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;
      exports.default = generateVertBlurSource;
      var vertTemplate = [
        "attribute vec2 aVertexPosition;",
        "attribute vec2 aTextureCoord;",
        "uniform float strength;",
        "uniform mat3 projectionMatrix;",
        "varying vec2 vBlurTexCoords[%size%];",
        "void main(void)",
        "{",
        "gl_Position = vec4((projectionMatrix * vec3((aVertexPosition), 1.0)).xy, 0.0, 1.0);",
        "%blur%",
        "}",
      ].join("\n");

      function generateVertBlurSource(kernelSize, x) {
        var halfLength = Math.ceil(kernelSize / 2);

        var vertSource = vertTemplate;

        var blurLoop = "";
        var template = void 0;
        // let value;

        if (x) {
          template = "vBlurTexCoords[%index%] = aTextureCoord + vec2(%sampleIndex% * strength, 0.0);";
        } else {
          template = "vBlurTexCoords[%index%] = aTextureCoord + vec2(0.0, %sampleIndex% * strength);";
        }

        for (var i = 0; i < kernelSize; i++) {
          var blur = template.replace("%index%", i);

          // value = i;

          // if(i >= halfLength)
          // {
          //     value = kernelSize - i - 1;
          // }

          blur = blur.replace("%sampleIndex%", i - (halfLength - 1) + ".0");

          blurLoop += blur;
          blurLoop += "\n";
        }

        vertSource = vertSource.replace("%blur%", blurLoop);
        vertSource = vertSource.replace("%size%", kernelSize);

        return vertSource;
      }
      //# sourceMappingURL=generateBlurVertSource.js.map

      /***/
    },
    /* 428 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;
      exports.default = generateFragBlurSource;
      var GAUSSIAN_VALUES = {
        5: [0.153388, 0.221461, 0.250301],
        7: [0.071303, 0.131514, 0.189879, 0.214607],
        9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
        11: [0.0093, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
        13: [0.002406, 0.009255, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
        15: [0.000489, 0.002403, 0.009246, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448],
      };

      var fragTemplate = [
        "varying vec2 vBlurTexCoords[%size%];",
        "uniform sampler2D uSampler;",
        "void main(void)",
        "{",
        "    gl_FragColor = vec4(0.0);",
        "    %blur%",
        "}",
      ].join("\n");

      function generateFragBlurSource(kernelSize) {
        var kernel = GAUSSIAN_VALUES[kernelSize];
        var halfLength = kernel.length;

        var fragSource = fragTemplate;

        var blurLoop = "";
        var template = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;";
        var value = void 0;

        for (var i = 0; i < kernelSize; i++) {
          var blur = template.replace("%index%", i);

          value = i;

          if (i >= halfLength) {
            value = kernelSize - i - 1;
          }

          blur = blur.replace("%value%", kernel[value]);

          blurLoop += blur;
          blurLoop += "\n";
        }

        fragSource = fragSource.replace("%blur%", blurLoop);
        fragSource = fragSource.replace("%size%", kernelSize);

        return fragSource;
      }
      //# sourceMappingURL=generateBlurFragSource.js.map

      /***/
    },
    /* 429 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;
      exports.default = getMaxKernelSize;
      function getMaxKernelSize(gl) {
        var maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
        var kernelSize = 15;

        while (kernelSize > maxVaryings) {
          kernelSize -= 2;
        }

        return kernelSize;
      }
      //# sourceMappingURL=getMaxBlurKernelSize.js.map

      /***/
    },
    /* 430 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      var _createClass = (function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      })();

      var _core = __webpack_require__(344);

      var core = _interopRequireWildcard(_core);

      var _generateBlurVertSource = __webpack_require__(427);

      var _generateBlurVertSource2 = _interopRequireDefault(_generateBlurVertSource);

      var _generateBlurFragSource = __webpack_require__(428);

      var _generateBlurFragSource2 = _interopRequireDefault(_generateBlurFragSource);

      var _getMaxBlurKernelSize = __webpack_require__(429);

      var _getMaxBlurKernelSize2 = _interopRequireDefault(_getMaxBlurKernelSize);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};
          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }
          newObj.default = obj;
          return newObj;
        }
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: { value: subClass, enumerable: false, writable: true, configurable: true },
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass);
      }

      /**
       * The BlurYFilter applies a horizontal Gaussian blur to an object.
       *
       * @class
       * @extends PIXI.Filter
       * @memberof PIXI.filters
       */
      var BlurYFilter = (function (_core$Filter) {
        _inherits(BlurYFilter, _core$Filter);

        /**
         * @param {number} strength - The strength of the blur filter.
         * @param {number} quality - The quality of the blur filter.
         * @param {number} resolution - The resolution of the blur filter.
         * @param {number} [kernelSize=5] - The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15.
         */
        function BlurYFilter(strength, quality, resolution, kernelSize) {
          _classCallCheck(this, BlurYFilter);

          kernelSize = kernelSize || 5;
          var vertSrc = (0, _generateBlurVertSource2.default)(kernelSize, false);
          var fragSrc = (0, _generateBlurFragSource2.default)(kernelSize);

          var _this = _possibleConstructorReturn(
            this,
            _core$Filter.call(
              this,
              // vertex shader
              vertSrc,
              // fragment shader
              fragSrc
            )
          );

          _this.resolution = resolution || core.settings.RESOLUTION;

          _this._quality = 0;

          _this.quality = quality || 4;
          _this.strength = strength || 8;

          _this.firstRun = true;
          return _this;
        }

        /**
         * Applies the filter.
         *
         * @param {PIXI.FilterManager} filterManager - The manager.
         * @param {PIXI.RenderTarget} input - The input target.
         * @param {PIXI.RenderTarget} output - The output target.
         * @param {boolean} clear - Should the output be cleared before rendering?
         */

        BlurYFilter.prototype.apply = function apply(filterManager, input, output, clear) {
          if (this.firstRun) {
            var gl = filterManager.renderer.gl;
            var kernelSize = (0, _getMaxBlurKernelSize2.default)(gl);

            this.vertexSrc = (0, _generateBlurVertSource2.default)(kernelSize, false);
            this.fragmentSrc = (0, _generateBlurFragSource2.default)(kernelSize);

            this.firstRun = false;
          }

          this.uniforms.strength = (1 / output.size.height) * (output.size.height / input.size.height);

          this.uniforms.strength *= this.strength;
          this.uniforms.strength /= this.passes;

          if (this.passes === 1) {
            filterManager.applyFilter(this, input, output, clear);
          } else {
            var renderTarget = filterManager.getRenderTarget(true);
            var flip = input;
            var flop = renderTarget;

            for (var i = 0; i < this.passes - 1; i++) {
              filterManager.applyFilter(this, flip, flop, true);

              var temp = flop;

              flop = flip;
              flip = temp;
            }

            filterManager.applyFilter(this, flip, output, clear);

            filterManager.returnRenderTarget(renderTarget);
          }
        };

        /**
         * Sets the strength of both the blur.
         *
         * @member {number}
         * @default 2
         */

        _createClass(BlurYFilter, [
          {
            key: "blur",
            get: function get() {
              return this.strength;
            },
            set: function set(
              value // eslint-disable-line require-jsdoc
            ) {
              this.padding = Math.abs(value) * 2;
              this.strength = value;
            },

            /**
             * Sets the quality of the blur by modifying the number of passes. More passes means higher
             * quaility bluring but the lower the performance.
             *
             * @member {number}
             * @default 4
             */
          },
          {
            key: "quality",
            get: function get() {
              return this._quality;
            },
            set: function set(
              value // eslint-disable-line require-jsdoc
            ) {
              this._quality = value;
              this.passes = value;
            },
          },
        ]);

        return BlurYFilter;
      })(core.Filter);

      exports.default = BlurYFilter;
      //# sourceMappingURL=BlurYFilter.js.map

      /***/
    },
    /* 431 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      var _createClass = (function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      })();

      var _core = __webpack_require__(344);

      var core = _interopRequireWildcard(_core);

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};
          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }
          newObj.default = obj;
          return newObj;
        }
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      /**
       * Holds all information related to an Interaction event
       *
       * @class
       * @memberof PIXI.interaction
       */
      var InteractionData = (function () {
        /**
         *
         */
        function InteractionData() {
          _classCallCheck(this, InteractionData);

          /**
           * This point stores the global coords of where the touch/mouse event happened
           *
           * @member {PIXI.Point}
           */
          this.global = new core.Point();

          /**
           * The target DisplayObject that was interacted with
           *
           * @member {PIXI.DisplayObject}
           */
          this.target = null;

          /**
           * When passed to an event handler, this will be the original DOM Event that was captured
           *
           * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent
           * @see https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent
           * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent
           * @member {MouseEvent|TouchEvent|PointerEvent}
           */
          this.originalEvent = null;

          /**
           * Unique identifier for this interaction
           *
           * @member {number}
           */
          this.identifier = null;

          /**
           * Indicates whether or not the pointer device that created the event is the primary pointer.
           * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary
           * @type {Boolean}
           */
          this.isPrimary = false;

          /**
           * Indicates which button was pressed on the mouse or pointer device to trigger the event.
           * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button
           * @type {number}
           */
          this.button = 0;

          /**
           * Indicates which buttons are pressed on the mouse or pointer device when the event is triggered.
           * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons
           * @type {number}
           */
          this.buttons = 0;

          /**
           * The width of the pointer's contact along the x-axis, measured in CSS pixels.
           * radiusX of TouchEvents will be represented by this value.
           * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width
           * @type {number}
           */
          this.width = 0;

          /**
           * The height of the pointer's contact along the y-axis, measured in CSS pixels.
           * radiusY of TouchEvents will be represented by this value.
           * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height
           * @type {number}
           */
          this.height = 0;

          /**
           * The angle, in degrees, between the pointer device and the screen.
           * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX
           * @type {number}
           */
          this.tiltX = 0;

          /**
           * The angle, in degrees, between the pointer device and the screen.
           * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY
           * @type {number}
           */
          this.tiltY = 0;

          /**
           * The type of pointer that triggered the event.
           * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType
           * @type {string}
           */
          this.pointerType = null;

          /**
           * Pressure applied by the pointing device during the event. A Touch's force property
           * will be represented by this value.
           * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure
           * @type {number}
           */
          this.pressure = 0;

          /**
           * From TouchEvents (not PointerEvents triggered by touches), the rotationAngle of the Touch.
           * @see https://developer.mozilla.org/en-US/docs/Web/API/Touch/rotationAngle
           * @type {number}
           */
          this.rotationAngle = 0;

          /**
           * Twist of a stylus pointer.
           * @see https://w3c.github.io/pointerevents/#pointerevent-interface
           * @type {number}
           */
          this.twist = 0;

          /**
           * Barrel pressure on a stylus pointer.
           * @see https://w3c.github.io/pointerevents/#pointerevent-interface
           * @type {number}
           */
          this.tangentialPressure = 0;
        }

        /**
         * The unique identifier of the pointer. It will be the same as `identifier`.
         * @readonly
         * @member {number}
         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId
         */

        /**
         * This will return the local coordinates of the specified displayObject for this InteractionData
         *
         * @param {PIXI.DisplayObject} displayObject - The DisplayObject that you would like the local
         *  coords off
         * @param {PIXI.Point} [point] - A Point object in which to store the value, optional (otherwise
         *  will create a new point)
         * @param {PIXI.Point} [globalPos] - A Point object containing your custom global coords, optional
         *  (otherwise will use the current global coords)
         * @return {PIXI.Point} A point containing the coordinates of the InteractionData position relative
         *  to the DisplayObject
         */
        InteractionData.prototype.getLocalPosition = function getLocalPosition(displayObject, point, globalPos) {
          return displayObject.worldTransform.applyInverse(globalPos || this.global, point);
        };

        /**
         * Copies properties from normalized event data.
         *
         * @param {Touch|MouseEvent|PointerEvent} event The normalized event data
         */

        InteractionData.prototype.copyEvent = function copyEvent(event) {
          // isPrimary should only change on touchstart/pointerdown, so we don't want to overwrite
          // it with "false" on later events when our shim for it on touch events might not be
          // accurate
          if (event.isPrimary) {
            this.isPrimary = true;
          }
          this.button = event.button;
          // event.buttons is not available in all browsers (ie. Safari), but it does have a non-standard
          // event.which property instead, which conveys the same information.
          this.buttons = Number.isInteger(event.buttons) ? event.buttons : event.which;
          this.width = event.width;
          this.height = event.height;
          this.tiltX = event.tiltX;
          this.tiltY = event.tiltY;
          this.pointerType = event.pointerType;
          this.pressure = event.pressure;
          this.rotationAngle = event.rotationAngle;
          this.twist = event.twist || 0;
          this.tangentialPressure = event.tangentialPressure || 0;
        };

        /**
         * Resets the data for pooling.
         */

        InteractionData.prototype.reset = function reset() {
          // isPrimary is the only property that we really need to reset - everything else is
          // guaranteed to be overwritten
          this.isPrimary = false;
        };

        _createClass(InteractionData, [
          {
            key: "pointerId",
            get: function get() {
              return this.identifier;
            },
          },
        ]);

        return InteractionData;
      })();

      exports.default = InteractionData;
      //# sourceMappingURL=InteractionData.js.map

      /***/
    },
    /* 432 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      /**
       * Event class that mimics native DOM events.
       *
       * @class
       * @memberof PIXI.interaction
       */
      var InteractionEvent = (function () {
        /**
         *
         */
        function InteractionEvent() {
          _classCallCheck(this, InteractionEvent);

          /**
           * Whether this event will continue propagating in the tree
           *
           * @member {boolean}
           */
          this.stopped = false;

          /**
           * The object which caused this event to be dispatched.
           * For listener callback see {@link PIXI.interaction.InteractionEvent.currentTarget}.
           *
           * @member {PIXI.DisplayObject}
           */
          this.target = null;

          /**
           * The object whose event listener’s callback is currently being invoked.
           *
           * @member {PIXI.DisplayObject}
           */
          this.currentTarget = null;

          /**
           * Type of the event
           *
           * @member {string}
           */
          this.type = null;

          /**
           * InteractionData related to this event
           *
           * @member {PIXI.interaction.InteractionData}
           */
          this.data = null;
        }

        /**
         * Prevents event from reaching any objects other than the current object.
         *
         */

        InteractionEvent.prototype.stopPropagation = function stopPropagation() {
          this.stopped = true;
        };

        /**
         * Resets the event.
         */

        InteractionEvent.prototype.reset = function reset() {
          this.stopped = false;
          this.currentTarget = null;
          this.target = null;
        };

        return InteractionEvent;
      })();

      exports.default = InteractionEvent;
      //# sourceMappingURL=InteractionEvent.js.map

      /***/
    },
    /* 433 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      var _createClass = (function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      })();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      /**
       * DisplayObjects with the {@link PIXI.interaction.interactiveTarget} mixin use this class to track interactions
       *
       * @class
       * @private
       * @memberof PIXI.interaction
       */
      var InteractionTrackingData = (function () {
        /**
         * @param {number} pointerId - Unique pointer id of the event
         */
        function InteractionTrackingData(pointerId) {
          _classCallCheck(this, InteractionTrackingData);

          this._pointerId = pointerId;
          this._flags = InteractionTrackingData.FLAGS.NONE;
        }

        /**
         *
         * @private
         * @param {number} flag - The interaction flag to set
         * @param {boolean} yn - Should the flag be set or unset
         */

        InteractionTrackingData.prototype._doSet = function _doSet(flag, yn) {
          if (yn) {
            this._flags = this._flags | flag;
          } else {
            this._flags = this._flags & ~flag;
          }
        };

        /**
         * Unique pointer id of the event
         *
         * @readonly
         * @member {number}
         */

        _createClass(InteractionTrackingData, [
          {
            key: "pointerId",
            get: function get() {
              return this._pointerId;
            },

            /**
             * State of the tracking data, expressed as bit flags
             *
             * @member {number}
             * @memberof PIXI.interaction.InteractionTrackingData#
             */
          },
          {
            key: "flags",
            get: function get() {
              return this._flags;
            },

            /**
             * Set the flags for the tracking data
             *
             * @param {number} flags - Flags to set
             */
            set: function set(flags) {
              this._flags = flags;
            },

            /**
             * Is the tracked event inactive (not over or down)?
             *
             * @member {number}
             * @memberof PIXI.interaction.InteractionTrackingData#
             */
          },
          {
            key: "none",
            get: function get() {
              return this._flags === this.constructor.FLAGS.NONE;
            },

            /**
             * Is the tracked event over the DisplayObject?
             *
             * @member {boolean}
             * @memberof PIXI.interaction.InteractionTrackingData#
             */
          },
          {
            key: "over",
            get: function get() {
              return (this._flags & this.constructor.FLAGS.OVER) !== 0;
            },

            /**
             * Set the over flag
             *
             * @param {boolean} yn - Is the event over?
             */
            set: function set(yn) {
              this._doSet(this.constructor.FLAGS.OVER, yn);
            },

            /**
             * Did the right mouse button come down in the DisplayObject?
             *
             * @member {boolean}
             * @memberof PIXI.interaction.InteractionTrackingData#
             */
          },
          {
            key: "rightDown",
            get: function get() {
              return (this._flags & this.constructor.FLAGS.RIGHT_DOWN) !== 0;
            },

            /**
             * Set the right down flag
             *
             * @param {boolean} yn - Is the right mouse button down?
             */
            set: function set(yn) {
              this._doSet(this.constructor.FLAGS.RIGHT_DOWN, yn);
            },

            /**
             * Did the left mouse button come down in the DisplayObject?
             *
             * @member {boolean}
             * @memberof PIXI.interaction.InteractionTrackingData#
             */
          },
          {
            key: "leftDown",
            get: function get() {
              return (this._flags & this.constructor.FLAGS.LEFT_DOWN) !== 0;
            },

            /**
             * Set the left down flag
             *
             * @param {boolean} yn - Is the left mouse button down?
             */
            set: function set(yn) {
              this._doSet(this.constructor.FLAGS.LEFT_DOWN, yn);
            },
          },
        ]);

        return InteractionTrackingData;
      })();

      exports.default = InteractionTrackingData;

      InteractionTrackingData.FLAGS = Object.freeze({
        NONE: 0,
        OVER: 1 << 0,
        LEFT_DOWN: 1 << 1,
        RIGHT_DOWN: 1 << 2,
      });
      //# sourceMappingURL=InteractionTrackingData.js.map

      /***/
    },
    /* 434 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;
      /**
       * Default property values of interactive objects
       * Used by {@link PIXI.interaction.InteractionManager} to automatically give all DisplayObjects these properties
       *
       * @private
       * @name interactiveTarget
       * @memberof PIXI.interaction
       * @example
       *      function MyObject() {}
       *
       *      Object.assign(
       *          core.DisplayObject.prototype,
       *          PIXI.interaction.interactiveTarget
       *      );
       */
      exports.default = {
        /**
         * Enable interaction events for the DisplayObject. Touch, pointer and mouse
         * events will not be emitted unless `interactive` is set to `true`.
         *
         * @example
         * const sprite = new PIXI.Sprite(texture);
         * sprite.interactive = true;
         * sprite.on('tap', (event) => {
         *    //handle event
         * });
         * @member {boolean}
         * @memberof PIXI.DisplayObject#
         */
        interactive: false,

        /**
         * Determines if the children to the displayObject can be clicked/touched
         * Setting this to false allows PixiJS to bypass a recursive `hitTest` function
         *
         * @member {boolean}
         * @memberof PIXI.Container#
         */
        interactiveChildren: true,

        /**
         * Interaction shape. Children will be hit first, then this shape will be checked.
         * Setting this will cause this shape to be checked in hit tests rather than the displayObject's bounds.
         *
         * @example
         * const sprite = new PIXI.Sprite(texture);
         * sprite.interactive = true;
         * sprite.hitArea = new PIXI.Rectangle(0, 0, 100, 100);
         * @member {PIXI.Rectangle|PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.RoundedRectangle}
         * @memberof PIXI.DisplayObject#
         */
        hitArea: null,

        /**
         * If enabled, the mouse cursor use the pointer behavior when hovered over the displayObject if it is interactive
         * Setting this changes the 'cursor' property to `'pointer'`.
         *
         * @example
         * const sprite = new PIXI.Sprite(texture);
         * sprite.interactive = true;
         * sprite.buttonMode = true;
         * @member {boolean}
         * @memberof PIXI.DisplayObject#
         */
        get buttonMode() {
          return this.cursor === "pointer";
        },
        set buttonMode(value) {
          if (value) {
            this.cursor = "pointer";
          } else if (this.cursor === "pointer") {
            this.cursor = null;
          }
        },

        /**
         * This defines what cursor mode is used when the mouse cursor
         * is hovered over the displayObject.
         *
         * @example
         * const sprite = new PIXI.Sprite(texture);
         * sprite.interactive = true;
         * sprite.cursor = 'wait';
         * @see https://developer.mozilla.org/en/docs/Web/CSS/cursor
         *
         * @member {string}
         * @memberof PIXI.DisplayObject#
         */
        cursor: null,

        /**
         * Internal set of all active pointers, by identifier
         *
         * @member {Map<number, InteractionTrackingData>}
         * @memberof PIXI.DisplayObject#
         * @private
         */
        get trackedPointers() {
          if (this._trackedPointers === undefined) this._trackedPointers = {};

          return this._trackedPointers;
        },

        /**
         * Map of all tracked pointers, by identifier. Use trackedPointers to access.
         *
         * @private
         * @type {Map<number, InteractionTrackingData>}
         */
        _trackedPointers: undefined,
      };
      //# sourceMappingURL=interactiveTarget.js.map

      /***/
    },
    /* 435 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;
      exports.parse = parse;

      exports.default = function () {
        return function bitmapFontParser(resource, next) {
          // skip if no data or not xml data
          if (!resource.data || resource.type !== _resourceLoader.Resource.TYPE.XML) {
            next();

            return;
          }

          // skip if not bitmap font data, using some silly duck-typing
          if (
            resource.data.getElementsByTagName("page").length === 0 ||
            resource.data.getElementsByTagName("info").length === 0 ||
            resource.data.getElementsByTagName("info")[0].getAttribute("face") === null
          ) {
            next();

            return;
          }

          var xmlUrl = !resource.isDataUrl ? path.dirname(resource.url) : "";

          if (resource.isDataUrl) {
            if (xmlUrl === ".") {
              xmlUrl = "";
            }

            if (this.baseUrl && xmlUrl) {
              // if baseurl has a trailing slash then add one to xmlUrl so the replace works below
              if (this.baseUrl.charAt(this.baseUrl.length - 1) === "/") {
                xmlUrl += "/";
              }
            }
          }

          // remove baseUrl from xmlUrl
          xmlUrl = xmlUrl.replace(this.baseUrl, "");

          // if there is an xmlUrl now, it needs a trailing slash. Ensure that it does if the string isn't empty.
          if (xmlUrl && xmlUrl.charAt(xmlUrl.length - 1) !== "/") {
            xmlUrl += "/";
          }

          var pages = resource.data.getElementsByTagName("page");
          var textures = {};

          // Handle completed, when the number of textures
          // load is the same number as references in the fnt file
          var completed = function completed(page) {
            textures[page.metadata.pageFile] = page.texture;

            if (Object.keys(textures).length === pages.length) {
              parse(resource, textures);
              next();
            }
          };

          for (var i = 0; i < pages.length; ++i) {
            var pageFile = pages[i].getAttribute("file");
            var url = xmlUrl + pageFile;
            var exists = false;

            // incase the image is loaded outside
            // using the same loader, resource will be available
            for (var name in this.resources) {
              var bitmapResource = this.resources[name];

              if (bitmapResource.url === url) {
                bitmapResource.metadata.pageFile = pageFile;
                if (bitmapResource.texture) {
                  completed(bitmapResource);
                } else {
                  bitmapResource.onAfterMiddleware.add(completed);
                }
                exists = true;
                break;
              }
            }

            // texture is not loaded, we'll attempt to add
            // it to the load and add the texture to the list
            if (!exists) {
              // Standard loading options for images
              var options = {
                crossOrigin: resource.crossOrigin,
                loadType: _resourceLoader.Resource.LOAD_TYPE.IMAGE,
                metadata: Object.assign({ pageFile: pageFile }, resource.metadata.imageMetadata),
                parentResource: resource,
              };

              this.add(url, options, completed);
            }
          }
        };
      };

      var _path = __webpack_require__(352);

      var path = _interopRequireWildcard(_path);

      var _resourceLoader = __webpack_require__(362);

      var _extras = __webpack_require__(425);

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};
          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }
          newObj.default = obj;
          return newObj;
        }
      }

      /**
       * Register a BitmapText font from loader resource.
       *
       * @function parseBitmapFontData
       * @memberof PIXI.loaders
       * @param {PIXI.loaders.Resource} resource - Loader resource.
       * @param {PIXI.Texture|PIXI.Texture[]} textures - List of textures for each page.
       */
      function parse(resource, textures) {
        resource.bitmapFont = _extras.BitmapText.registerFont(resource.data, textures);
      }
      //# sourceMappingURL=bitmapFontParser.js.map

      /***/
    },
    /* 436 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _createClass = (function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      })();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var MiniSignalBinding = (function () {
        function MiniSignalBinding(fn, once, thisArg) {
          if (once === undefined) once = false;

          _classCallCheck(this, MiniSignalBinding);

          this._fn = fn;
          this._once = once;
          this._thisArg = thisArg;
          this._next = this._prev = this._owner = null;
        }

        _createClass(MiniSignalBinding, [
          {
            key: "detach",
            value: function detach() {
              if (this._owner === null) return false;
              this._owner.detach(this);
              return true;
            },
          },
        ]);

        return MiniSignalBinding;
      })();

      function _addMiniSignalBinding(self, node) {
        if (!self._head) {
          self._head = node;
          self._tail = node;
        } else {
          self._tail._next = node;
          node._prev = self._tail;
          self._tail = node;
        }

        node._owner = self;

        return node;
      }

      var MiniSignal = (function () {
        function MiniSignal() {
          _classCallCheck(this, MiniSignal);

          this._head = this._tail = undefined;
        }

        _createClass(MiniSignal, [
          {
            key: "handlers",
            value: function handlers() {
              var exists = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];

              var node = this._head;

              if (exists) return !!node;

              var ee = [];

              while (node) {
                ee.push(node);
                node = node._next;
              }

              return ee;
            },
          },
          {
            key: "has",
            value: function has(node) {
              if (!(node instanceof MiniSignalBinding)) {
                throw new Error("MiniSignal#has(): First arg must be a MiniSignalBinding object.");
              }

              return node._owner === this;
            },
          },
          {
            key: "dispatch",
            value: function dispatch() {
              var node = this._head;

              if (!node) return false;

              while (node) {
                if (node._once) this.detach(node);
                node._fn.apply(node._thisArg, arguments);
                node = node._next;
              }

              return true;
            },
          },
          {
            key: "add",
            value: function add(fn) {
              var thisArg = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

              if (typeof fn !== "function") {
                throw new Error("MiniSignal#add(): First arg must be a Function.");
              }
              return _addMiniSignalBinding(this, new MiniSignalBinding(fn, false, thisArg));
            },
          },
          {
            key: "once",
            value: function once(fn) {
              var thisArg = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

              if (typeof fn !== "function") {
                throw new Error("MiniSignal#once(): First arg must be a Function.");
              }
              return _addMiniSignalBinding(this, new MiniSignalBinding(fn, true, thisArg));
            },
          },
          {
            key: "detach",
            value: function detach(node) {
              if (!(node instanceof MiniSignalBinding)) {
                throw new Error("MiniSignal#detach(): First arg must be a MiniSignalBinding object.");
              }
              if (node._owner !== this) return this;

              if (node._prev) node._prev._next = node._next;
              if (node._next) node._next._prev = node._prev;

              if (node === this._head) {
                this._head = node._next;
                if (node._next === null) {
                  this._tail = null;
                }
              } else if (node === this._tail) {
                this._tail = node._prev;
                this._tail._next = null;
              }

              node._owner = null;
              return this;
            },
          },
          {
            key: "detachAll",
            value: function detachAll() {
              var node = this._head;
              if (!node) return this;

              this._head = this._tail = null;

              while (node) {
                node._owner = null;
                node = node._next;
              }
              return this;
            },
          },
        ]);

        return MiniSignal;
      })();

      MiniSignal.MiniSignalBinding = MiniSignalBinding;

      exports["default"] = MiniSignal;
      module.exports = exports["default"];

      /***/
    },
    /* 437 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      function parseURI(str, opts) {
        if (!str) return undefined;

        opts = opts || {};

        var o = {
          key: [
            "source",
            "protocol",
            "authority",
            "userInfo",
            "user",
            "password",
            "host",
            "port",
            "relative",
            "path",
            "directory",
            "file",
            "query",
            "anchor",
          ],
          q: {
            name: "queryKey",
            parser: /(?:^|&)([^&=]*)=?([^&]*)/g,
          },
          parser: {
            strict:
              /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
            loose:
              /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,
          },
        };

        var m = o.parser[opts.strictMode ? "strict" : "loose"].exec(str);
        var uri = {};
        var i = 14;

        while (i--) uri[o.key[i]] = m[i] || "";

        uri[o.q.name] = {};
        uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {
          if ($1) uri[o.q.name][$1] = $2;
        });

        return uri;
      }

      module.exports = parseURI;

      /***/
    },
    /* 438 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;
      exports.eachSeries = eachSeries;
      exports.queue = queue;
      /**
       * Smaller version of the async library constructs.
       *
       * @namespace async
       */

      /**
       * Noop function
       *
       * @ignore
       * @function
       * @memberof async
       */
      function _noop() {} /* empty */

      /**
       * Iterates an array in series.
       *
       * @memberof async
       * @param {Array.<*>} array - Array to iterate.
       * @param {function} iterator - Function to call for each element.
       * @param {function} callback - Function to call when done, or on error.
       * @param {boolean} [deferNext=false] - Break synchronous each loop by calling next with a setTimeout of 1.
       */
      function eachSeries(array, iterator, callback, deferNext) {
        var i = 0;
        var len = array.length;

        (function next(err) {
          if (err || i === len) {
            if (callback) {
              callback(err);
            }

            return;
          }

          if (deferNext) {
            setTimeout(function () {
              iterator(array[i++], next);
            }, 1);
          } else {
            iterator(array[i++], next);
          }
        })();
      }

      /**
       * Ensures a function is only called once.
       *
       * @ignore
       * @memberof async
       * @param {function} fn - The function to wrap.
       * @return {function} The wrapping function.
       */
      function onlyOnce(fn) {
        return function onceWrapper() {
          if (fn === null) {
            throw new Error("Callback was already called.");
          }

          var callFn = fn;

          fn = null;
          callFn.apply(this, arguments);
        };
      }

      /**
       * Async queue implementation,
       *
       * @memberof async
       * @param {function} worker - The worker function to call for each task.
       * @param {number} concurrency - How many workers to run in parrallel.
       * @return {*} The async queue object.
       */
      function queue(worker, concurrency) {
        if (concurrency == null) {
          // eslint-disable-line no-eq-null,eqeqeq
          concurrency = 1;
        } else if (concurrency === 0) {
          throw new Error("Concurrency must not be zero");
        }

        var workers = 0;
        var q = {
          _tasks: [],
          concurrency: concurrency,
          saturated: _noop,
          unsaturated: _noop,
          buffer: concurrency / 4,
          empty: _noop,
          drain: _noop,
          error: _noop,
          started: false,
          paused: false,
          push: function push(data, callback) {
            _insert(data, false, callback);
          },
          kill: function kill() {
            workers = 0;
            q.drain = _noop;
            q.started = false;
            q._tasks = [];
          },
          unshift: function unshift(data, callback) {
            _insert(data, true, callback);
          },
          process: function process() {
            while (!q.paused && workers < q.concurrency && q._tasks.length) {
              var task = q._tasks.shift();

              if (q._tasks.length === 0) {
                q.empty();
              }

              workers += 1;

              if (workers === q.concurrency) {
                q.saturated();
              }

              worker(task.data, onlyOnce(_next(task)));
            }
          },
          length: function length() {
            return q._tasks.length;
          },
          running: function running() {
            return workers;
          },
          idle: function idle() {
            return q._tasks.length + workers === 0;
          },
          pause: function pause() {
            if (q.paused === true) {
              return;
            }

            q.paused = true;
          },
          resume: function resume() {
            if (q.paused === false) {
              return;
            }

            q.paused = false;

            // Need to call q.process once per concurrent
            // worker to preserve full concurrency after pause
            for (var w = 1; w <= q.concurrency; w++) {
              q.process();
            }
          },
        };

        function _insert(data, insertAtFront, callback) {
          if (callback != null && typeof callback !== "function") {
            // eslint-disable-line no-eq-null,eqeqeq
            throw new Error("task callback must be a function");
          }

          q.started = true;

          if (data == null && q.idle()) {
            // eslint-disable-line no-eq-null,eqeqeq
            // call drain immediately if there are no tasks
            setTimeout(function () {
              return q.drain();
            }, 1);

            return;
          }

          var item = {
            data: data,
            callback: typeof callback === "function" ? callback : _noop,
          };

          if (insertAtFront) {
            q._tasks.unshift(item);
          } else {
            q._tasks.push(item);
          }

          setTimeout(function () {
            return q.process();
          }, 1);
        }

        function _next(task) {
          return function next() {
            workers -= 1;

            task.callback.apply(task, arguments);

            if (arguments[0] != null) {
              // eslint-disable-line no-eq-null,eqeqeq
              q.error(arguments[0], task.data);
            }

            if (workers <= q.concurrency - q.buffer) {
              q.unsaturated();
            }

            if (q.idle()) {
              q.drain();
            }

            q.process();
          };
        }

        return q;
      }
      //# sourceMappingURL=async.js.map

      /***/
    },
    /* 439 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;
      exports.encodeBinary = encodeBinary;
      var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

      /**
       * Encodes binary into base64.
       *
       * @param {string} input The input data to encode.
       * @returns {string} The encoded base64 string
       */
      function encodeBinary(input) {
        var output = "";
        var inx = 0;

        while (inx < input.length) {
          // Fill byte buffer array
          var bytebuffer = [0, 0, 0];
          var encodedCharIndexes = [0, 0, 0, 0];

          for (var jnx = 0; jnx < bytebuffer.length; ++jnx) {
            if (inx < input.length) {
              // throw away high-order byte, as documented at:
              // https://developer.mozilla.org/En/Using_XMLHttpRequest#Handling_binary_data
              bytebuffer[jnx] = input.charCodeAt(inx++) & 0xff;
            } else {
              bytebuffer[jnx] = 0;
            }
          }

          // Get each encoded character, 6 bits at a time
          // index 1: first 6 bits
          encodedCharIndexes[0] = bytebuffer[0] >> 2;

          // index 2: second 6 bits (2 least significant bits from input byte 1 + 4 most significant bits from byte 2)
          encodedCharIndexes[1] = ((bytebuffer[0] & 0x3) << 4) | (bytebuffer[1] >> 4);

          // index 3: third 6 bits (4 least significant bits from input byte 2 + 2 most significant bits from byte 3)
          encodedCharIndexes[2] = ((bytebuffer[1] & 0x0f) << 2) | (bytebuffer[2] >> 6);

          // index 3: forth 6 bits (6 least significant bits from input byte 3)
          encodedCharIndexes[3] = bytebuffer[2] & 0x3f;

          // Determine whether padding happened, and adjust accordingly
          var paddingBytes = inx - (input.length - 1);

          switch (paddingBytes) {
            case 2:
              // Set last 2 characters to padding char
              encodedCharIndexes[3] = 64;
              encodedCharIndexes[2] = 64;
              break;

            case 1:
              // Set last character to padding char
              encodedCharIndexes[3] = 64;
              break;

            default:
              break; // No padding - proceed
          }

          // Now we will grab each appropriate character out of our keystring
          // based on our index array and append it to the output string
          for (var _jnx = 0; _jnx < encodedCharIndexes.length; ++_jnx) {
            output += _keyStr.charAt(encodedCharIndexes[_jnx]);
          }
        }

        return output;
      }

      // Backwards compat
      if (true) {
        module.exports.default = encodeBinary; // eslint-disable-line no-undef
      }
      //# sourceMappingURL=b64.js.map

      /***/
    },
    /* 440 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      exports.default = function () {
        return function spritesheetParser(resource, next) {
          var imageResourceName = resource.name + "_image";

          // skip if no data, its not json, it isn't spritesheet data, or the image resource already exists
          if (!resource.data || resource.type !== _resourceLoader.Resource.TYPE.JSON || !resource.data.frames || this.resources[imageResourceName]) {
            next();

            return;
          }

          var loadOptions = {
            crossOrigin: resource.crossOrigin,
            metadata: resource.metadata.imageMetadata,
            parentResource: resource,
          };

          var resourcePath = getResourcePath(resource, this.baseUrl);

          // load the image for this sheet
          this.add(imageResourceName, resourcePath, loadOptions, function onImageLoad(res) {
            if (res.error) {
              next(res.error);

              return;
            }

            var spritesheet = new _core.Spritesheet(res.texture.baseTexture, resource.data, resource.url);

            spritesheet.parse(function () {
              resource.spritesheet = spritesheet;
              resource.textures = spritesheet.textures;
              next();
            });
          });
        };
      };

      exports.getResourcePath = getResourcePath;

      var _resourceLoader = __webpack_require__(362);

      var _url = __webpack_require__(408);

      var _url2 = _interopRequireDefault(_url);

      var _core = __webpack_require__(344);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function getResourcePath(resource, baseUrl) {
        // Prepend url path unless the resource image is a data url
        if (resource.isDataUrl) {
          return resource.data.meta.image;
        }

        return _url2.default.resolve(resource.url.replace(baseUrl, ""), resource.data.meta.image);
      }
      //# sourceMappingURL=spritesheetParser.js.map

      /***/
    },
    /* 441 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      exports.default = function () {
        return function textureParser(resource, next) {
          // create a new texture if the data is an Image object
          if (resource.data && resource.type === _resourceLoader.Resource.TYPE.IMAGE) {
            resource.texture = _Texture2.default.fromLoader(resource.data, resource.url, resource.name);
          }
          next();
        };
      };

      var _resourceLoader = __webpack_require__(362);

      var _Texture = __webpack_require__(353);

      var _Texture2 = _interopRequireDefault(_Texture);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      //# sourceMappingURL=textureParser.js.map

      /***/
    },
    /* 442 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      var _Mesh2 = __webpack_require__(363);

      var _Mesh3 = _interopRequireDefault(_Mesh2);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: { value: subClass, enumerable: false, writable: true, configurable: true },
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass);
      }

      /**
       * The Plane allows you to draw a texture across several points and them manipulate these points
       *
       *```js
       * for (let i = 0; i < 20; i++) {
       *     points.push(new PIXI.Point(i * 50, 0));
       * };
       * let Plane = new PIXI.Plane(PIXI.Texture.fromImage("snake.png"), points);
       *  ```
       *
       * @class
       * @extends PIXI.mesh.Mesh
       * @memberof PIXI.mesh
       *
       */
      var Plane = (function (_Mesh) {
        _inherits(Plane, _Mesh);

        /**
         * @param {PIXI.Texture} texture - The texture to use on the Plane.
         * @param {number} [verticesX=10] - The number of vertices in the x-axis
         * @param {number} [verticesY=10] - The number of vertices in the y-axis
         */
        function Plane(texture, verticesX, verticesY) {
          _classCallCheck(this, Plane);

          /**
           * Tracker for if the Plane is ready to be drawn. Needed because Mesh ctor can
           * call _onTextureUpdated which could call refresh too early.
           *
           * @member {boolean}
           * @private
           */
          var _this = _possibleConstructorReturn(this, _Mesh.call(this, texture));

          _this._ready = true;

          _this.verticesX = verticesX || 10;
          _this.verticesY = verticesY || 10;

          _this.drawMode = _Mesh3.default.DRAW_MODES.TRIANGLES;
          _this.refresh();
          return _this;
        }

        /**
         * Refreshes plane coordinates
         *
         */

        Plane.prototype._refresh = function _refresh() {
          var texture = this._texture;
          var total = this.verticesX * this.verticesY;
          var verts = [];
          var colors = [];
          var uvs = [];
          var indices = [];

          var segmentsX = this.verticesX - 1;
          var segmentsY = this.verticesY - 1;

          var sizeX = texture.width / segmentsX;
          var sizeY = texture.height / segmentsY;

          for (var i = 0; i < total; i++) {
            var x = i % this.verticesX;
            var y = (i / this.verticesX) | 0;

            verts.push(x * sizeX, y * sizeY);

            uvs.push(x / segmentsX, y / segmentsY);
          }

          //  cons

          var totalSub = segmentsX * segmentsY;

          for (var _i = 0; _i < totalSub; _i++) {
            var xpos = _i % segmentsX;
            var ypos = (_i / segmentsX) | 0;

            var value = ypos * this.verticesX + xpos;
            var value2 = ypos * this.verticesX + xpos + 1;
            var value3 = (ypos + 1) * this.verticesX + xpos;
            var value4 = (ypos + 1) * this.verticesX + xpos + 1;

            indices.push(value, value2, value3);
            indices.push(value2, value4, value3);
          }

          // console.log(indices)
          this.vertices = new Float32Array(verts);
          this.uvs = new Float32Array(uvs);
          this.colors = new Float32Array(colors);
          this.indices = new Uint16Array(indices);

          this.dirty++;
          this.indexDirty++;

          this.multiplyUvs();
        };

        /**
         * Clear texture UVs when new texture is set
         *
         * @private
         */

        Plane.prototype._onTextureUpdate = function _onTextureUpdate() {
          _Mesh3.default.prototype._onTextureUpdate.call(this);

          // wait for the Plane ctor to finish before calling refresh
          if (this._ready) {
            this.refresh();
          }
        };

        return Plane;
      })(_Mesh3.default);

      exports.default = Plane;
      //# sourceMappingURL=Plane.js.map

      /***/
    },
    /* 443 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      /**
       * CountLimiter limits the number of items handled by a {@link PIXI.prepare.BasePrepare} to a specified
       * number of items per frame.
       *
       * @class
       * @memberof PIXI
       */
      var CountLimiter = (function () {
        /**
         * @param {number} maxItemsPerFrame - The maximum number of items that can be prepared each frame.
         */
        function CountLimiter(maxItemsPerFrame) {
          _classCallCheck(this, CountLimiter);

          /**
           * The maximum number of items that can be prepared each frame.
           * @private
           */
          this.maxItemsPerFrame = maxItemsPerFrame;
          /**
           * The number of items that can be prepared in the current frame.
           * @type {number}
           * @private
           */
          this.itemsLeft = 0;
        }

        /**
         * Resets any counting properties to start fresh on a new frame.
         */

        CountLimiter.prototype.beginFrame = function beginFrame() {
          this.itemsLeft = this.maxItemsPerFrame;
        };

        /**
         * Checks to see if another item can be uploaded. This should only be called once per item.
         * @return {boolean} If the item is allowed to be uploaded.
         */

        CountLimiter.prototype.allowedToUpload = function allowedToUpload() {
          return this.itemsLeft-- > 0;
        };

        return CountLimiter;
      })();

      exports.default = CountLimiter;
      //# sourceMappingURL=CountLimiter.js.map

      /***/
    },
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    /* 444 */ /* 445 */ /* 446 */ /* 447 */ /* 448 */ /* 449 */ /* 450 */ /* 451 */ /* 452 */ /* 453 */ /* 454 */ /* 455 */ /* 456 */ /* 457 */ /* 458 */ /* 459 */ /* 460 */ /* 461 */ /* 462 */ /* 463 */ /* 464 */ /* 465 */ /* 466 */ /* 467 */ /* 468 */ /* 469 */ /* 470 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      __webpack_require__(471);

      __webpack_require__(473);

      __webpack_require__(474);

      __webpack_require__(475);

      if (!window.ArrayBuffer) {
        window.ArrayBuffer = Array;
      }

      if (!window.Float32Array) {
        window.Float32Array = Array;
      }

      if (!window.Uint32Array) {
        window.Uint32Array = Array;
      }

      if (!window.Uint16Array) {
        window.Uint16Array = Array;
      }
      //# sourceMappingURL=index.js.map

      /***/
    },
    /* 471 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var _objectAssign = __webpack_require__(472);

      var _objectAssign2 = _interopRequireDefault(_objectAssign);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      if (!Object.assign) {
        Object.assign = _objectAssign2.default;
      } // References:
      // https://github.com/sindresorhus/object-assign
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
      //# sourceMappingURL=Object.assign.js.map

      /***/
    },
    /* 472 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";
      /*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  */

      /* eslint-disable no-unused-vars */
      var getOwnPropertySymbols = Object.getOwnPropertySymbols;
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var propIsEnumerable = Object.prototype.propertyIsEnumerable;

      function toObject(val) {
        if (val === null || val === undefined) {
          throw new TypeError("Object.assign cannot be called with null or undefined");
        }

        return Object(val);
      }

      function shouldUseNative() {
        try {
          if (!Object.assign) {
            return false;
          }

          // Detect buggy property enumeration order in older V8 versions.

          // https://bugs.chromium.org/p/v8/issues/detail?id=4118
          var test1 = new String("abc"); // eslint-disable-line no-new-wrappers
          test1[5] = "de";
          if (Object.getOwnPropertyNames(test1)[0] === "5") {
            return false;
          }

          // https://bugs.chromium.org/p/v8/issues/detail?id=3056
          var test2 = {};
          for (var i = 0; i < 10; i++) {
            test2["_" + String.fromCharCode(i)] = i;
          }
          var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
            return test2[n];
          });
          if (order2.join("") !== "0123456789") {
            return false;
          }

          // https://bugs.chromium.org/p/v8/issues/detail?id=3056
          var test3 = {};
          "abcdefghijklmnopqrst".split("").forEach(function (letter) {
            test3[letter] = letter;
          });
          if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
            return false;
          }

          return true;
        } catch (err) {
          // We don't expect any of the above to throw, but better to be safe.
          return false;
        }
      }

      module.exports = shouldUseNative()
        ? Object.assign
        : function (target, source) {
            var from;
            var to = toObject(target);
            var symbols;

            for (var s = 1; s < arguments.length; s++) {
              from = Object(arguments[s]);

              for (var key in from) {
                if (hasOwnProperty.call(from, key)) {
                  to[key] = from[key];
                }
              }

              if (getOwnPropertySymbols) {
                symbols = getOwnPropertySymbols(from);
                for (var i = 0; i < symbols.length; i++) {
                  if (propIsEnumerable.call(from, symbols[i])) {
                    to[symbols[i]] = from[symbols[i]];
                  }
                }
              }
            }

            return to;
          };

      /***/
    },
    /* 473 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";
      /* WEBPACK VAR INJECTION */ (function (global) {
        // References:
        // http://paulirish.com/2011/requestanimationframe-for-smart-animating/
        // https://gist.github.com/1579671
        // http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision
        // https://gist.github.com/timhall/4078614
        // https://github.com/Financial-Times/polyfill-service/tree/master/polyfills/requestAnimationFrame

        // Expected to be used with Browserfiy
        // Browserify automatically detects the use of `global` and passes the
        // correct reference of `global`, `self`, and finally `window`

        var ONE_FRAME_TIME = 16;

        // Date.now
        if (!(Date.now && Date.prototype.getTime)) {
          Date.now = function now() {
            return new Date().getTime();
          };
        }

        // performance.now
        if (!(global.performance && global.performance.now)) {
          var startTime = Date.now();

          if (!global.performance) {
            global.performance = {};
          }

          global.performance.now = function () {
            return Date.now() - startTime;
          };
        }

        // requestAnimationFrame
        var lastTime = Date.now();
        var vendors = ["ms", "moz", "webkit", "o"];

        for (var x = 0; x < vendors.length && !global.requestAnimationFrame; ++x) {
          var p = vendors[x];

          global.requestAnimationFrame = global[p + "RequestAnimationFrame"];
          global.cancelAnimationFrame = global[p + "CancelAnimationFrame"] || global[p + "CancelRequestAnimationFrame"];
        }

        if (!global.requestAnimationFrame) {
          global.requestAnimationFrame = function (callback) {
            if (typeof callback !== "function") {
              throw new TypeError(callback + "is not a function");
            }

            var currentTime = Date.now();
            var delay = ONE_FRAME_TIME + lastTime - currentTime;

            if (delay < 0) {
              delay = 0;
            }

            lastTime = currentTime;

            return setTimeout(function () {
              lastTime = Date.now();
              callback(performance.now());
            }, delay);
          };
        }

        if (!global.cancelAnimationFrame) {
          global.cancelAnimationFrame = function (id) {
            return clearTimeout(id);
          };
        }
        //# sourceMappingURL=requestAnimationFrame.js.map
        /* WEBPACK VAR INJECTION */
      }).call(this, __webpack_require__(39));

      /***/
    },
    /* 474 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      // References:
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

      if (!Math.sign) {
        Math.sign = function mathSign(x) {
          x = Number(x);

          if (x === 0 || isNaN(x)) {
            return x;
          }

          return x > 0 ? 1 : -1;
        };
      }
      //# sourceMappingURL=Math.sign.js.map

      /***/
    },
    /* 475 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      // References:
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger

      if (!Number.isInteger) {
        Number.isInteger = function numberIsInteger(value) {
          return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
        };
      }
      //# sourceMappingURL=Number.isInteger.js.map

      /***/
    },
    /* 476 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      var _Rectangle = __webpack_require__(375);

      var _Rectangle2 = _interopRequireDefault(_Rectangle);

      var _const = __webpack_require__(343);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      /**
       * The Circle object can be used to specify a hit area for displayObjects
       *
       * @class
       * @memberof PIXI
       */
      var Circle = (function () {
        /**
         * @param {number} [x=0] - The X coordinate of the center of this circle
         * @param {number} [y=0] - The Y coordinate of the center of this circle
         * @param {number} [radius=0] - The radius of the circle
         */
        function Circle() {
          var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
          var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          var radius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

          _classCallCheck(this, Circle);

          /**
           * @member {number}
           * @default 0
           */
          this.x = x;

          /**
           * @member {number}
           * @default 0
           */
          this.y = y;

          /**
           * @member {number}
           * @default 0
           */
          this.radius = radius;

          /**
           * The type of the object, mainly used to avoid `instanceof` checks
           *
           * @member {number}
           * @readOnly
           * @default PIXI.SHAPES.CIRC
           * @see PIXI.SHAPES
           */
          this.type = _const.SHAPES.CIRC;
        }

        /**
         * Creates a clone of this Circle instance
         *
         * @return {PIXI.Circle} a copy of the Circle
         */

        Circle.prototype.clone = function clone() {
          return new Circle(this.x, this.y, this.radius);
        };

        /**
         * Checks whether the x and y coordinates given are contained within this circle
         *
         * @param {number} x - The X coordinate of the point to test
         * @param {number} y - The Y coordinate of the point to test
         * @return {boolean} Whether the x/y coordinates are within this Circle
         */

        Circle.prototype.contains = function contains(x, y) {
          if (this.radius <= 0) {
            return false;
          }

          var r2 = this.radius * this.radius;
          var dx = this.x - x;
          var dy = this.y - y;

          dx *= dx;
          dy *= dy;

          return dx + dy <= r2;
        };

        /**
         * Returns the framing rectangle of the circle as a Rectangle object
         *
         * @return {PIXI.Rectangle} the framing rectangle
         */

        Circle.prototype.getBounds = function getBounds() {
          return new _Rectangle2.default(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
        };

        return Circle;
      })();

      exports.default = Circle;
      //# sourceMappingURL=Circle.js.map

      /***/
    },
    /* 477 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      var _Rectangle = __webpack_require__(375);

      var _Rectangle2 = _interopRequireDefault(_Rectangle);

      var _const = __webpack_require__(343);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      /**
       * The Ellipse object can be used to specify a hit area for displayObjects
       *
       * @class
       * @memberof PIXI
       */
      var Ellipse = (function () {
        /**
         * @param {number} [x=0] - The X coordinate of the center of this ellipse
         * @param {number} [y=0] - The Y coordinate of the center of this ellipse
         * @param {number} [halfWidth=0] - The half width of this ellipse
         * @param {number} [halfHeight=0] - The half height of this ellipse
         */
        function Ellipse() {
          var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
          var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          var halfWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
          var halfHeight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

          _classCallCheck(this, Ellipse);

          /**
           * @member {number}
           * @default 0
           */
          this.x = x;

          /**
           * @member {number}
           * @default 0
           */
          this.y = y;

          /**
           * @member {number}
           * @default 0
           */
          this.width = halfWidth;

          /**
           * @member {number}
           * @default 0
           */
          this.height = halfHeight;

          /**
           * The type of the object, mainly used to avoid `instanceof` checks
           *
           * @member {number}
           * @readOnly
           * @default PIXI.SHAPES.ELIP
           * @see PIXI.SHAPES
           */
          this.type = _const.SHAPES.ELIP;
        }

        /**
         * Creates a clone of this Ellipse instance
         *
         * @return {PIXI.Ellipse} a copy of the ellipse
         */

        Ellipse.prototype.clone = function clone() {
          return new Ellipse(this.x, this.y, this.width, this.height);
        };

        /**
         * Checks whether the x and y coordinates given are contained within this ellipse
         *
         * @param {number} x - The X coordinate of the point to test
         * @param {number} y - The Y coordinate of the point to test
         * @return {boolean} Whether the x/y coords are within this ellipse
         */

        Ellipse.prototype.contains = function contains(x, y) {
          if (this.width <= 0 || this.height <= 0) {
            return false;
          }

          // normalize the coords to an ellipse with center 0,0
          var normx = (x - this.x) / this.width;
          var normy = (y - this.y) / this.height;

          normx *= normx;
          normy *= normy;

          return normx + normy <= 1;
        };

        /**
         * Returns the framing rectangle of the ellipse as a Rectangle object
         *
         * @return {PIXI.Rectangle} the framing rectangle
         */

        Ellipse.prototype.getBounds = function getBounds() {
          return new _Rectangle2.default(this.x - this.width, this.y - this.height, this.width, this.height);
        };

        return Ellipse;
      })();

      exports.default = Ellipse;
      //# sourceMappingURL=Ellipse.js.map

      /***/
    },
    /* 478 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      var _Point = __webpack_require__(373);

      var _Point2 = _interopRequireDefault(_Point);

      var _const = __webpack_require__(343);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      /**
       * @class
       * @memberof PIXI
       */
      var Polygon = (function () {
        /**
         * @param {PIXI.Point[]|number[]} points - This can be an array of Points
         *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or
         *  the arguments passed can be all the points of the polygon e.g.
         *  `new PIXI.Polygon(new PIXI.Point(), new PIXI.Point(), ...)`, or the arguments passed can be flat
         *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.
         */
        function Polygon() {
          for (var _len = arguments.length, points = Array(_len), _key = 0; _key < _len; _key++) {
            points[_key] = arguments[_key];
          }

          _classCallCheck(this, Polygon);

          if (Array.isArray(points[0])) {
            points = points[0];
          }

          // if this is an array of points, convert it to a flat array of numbers
          if (points[0] instanceof _Point2.default) {
            var p = [];

            for (var i = 0, il = points.length; i < il; i++) {
              p.push(points[i].x, points[i].y);
            }

            points = p;
          }

          this.closed = true;

          /**
           * An array of the points of this polygon
           *
           * @member {number[]}
           */
          this.points = points;

          /**
           * The type of the object, mainly used to avoid `instanceof` checks
           *
           * @member {number}
           * @readOnly
           * @default PIXI.SHAPES.POLY
           * @see PIXI.SHAPES
           */
          this.type = _const.SHAPES.POLY;
        }

        /**
         * Creates a clone of this polygon
         *
         * @return {PIXI.Polygon} a copy of the polygon
         */

        Polygon.prototype.clone = function clone() {
          return new Polygon(this.points.slice());
        };

        /**
         * Closes the polygon, adding points if necessary.
         *
         */

        Polygon.prototype.close = function close() {
          var points = this.points;

          // close the poly if the value is true!
          if (points[0] !== points[points.length - 2] || points[1] !== points[points.length - 1]) {
            points.push(points[0], points[1]);
          }
        };

        /**
         * Checks whether the x and y coordinates passed to this function are contained within this polygon
         *
         * @param {number} x - The X coordinate of the point to test
         * @param {number} y - The Y coordinate of the point to test
         * @return {boolean} Whether the x/y coordinates are within this polygon
         */

        Polygon.prototype.contains = function contains(x, y) {
          var inside = false;

          // use some raycasting to test hits
          // https://github.com/substack/point-in-polygon/blob/master/index.js
          var length = this.points.length / 2;

          for (var i = 0, j = length - 1; i < length; j = i++) {
            var xi = this.points[i * 2];
            var yi = this.points[i * 2 + 1];
            var xj = this.points[j * 2];
            var yj = this.points[j * 2 + 1];
            var intersect = yi > y !== yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi;

            if (intersect) {
              inside = !inside;
            }
          }

          return inside;
        };

        return Polygon;
      })();

      exports.default = Polygon;
      //# sourceMappingURL=Polygon.js.map

      /***/
    },
    /* 479 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      var _const = __webpack_require__(343);

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      /**
       * The Rounded Rectangle object is an area that has nice rounded corners, as indicated by its
       * top-left corner point (x, y) and by its width and its height and its radius.
       *
       * @class
       * @memberof PIXI
       */
      var RoundedRectangle = (function () {
        /**
         * @param {number} [x=0] - The X coordinate of the upper-left corner of the rounded rectangle
         * @param {number} [y=0] - The Y coordinate of the upper-left corner of the rounded rectangle
         * @param {number} [width=0] - The overall width of this rounded rectangle
         * @param {number} [height=0] - The overall height of this rounded rectangle
         * @param {number} [radius=20] - Controls the radius of the rounded corners
         */
        function RoundedRectangle() {
          var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
          var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
          var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
          var radius = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 20;

          _classCallCheck(this, RoundedRectangle);

          /**
           * @member {number}
           * @default 0
           */
          this.x = x;

          /**
           * @member {number}
           * @default 0
           */
          this.y = y;

          /**
           * @member {number}
           * @default 0
           */
          this.width = width;

          /**
           * @member {number}
           * @default 0
           */
          this.height = height;

          /**
           * @member {number}
           * @default 20
           */
          this.radius = radius;

          /**
           * The type of the object, mainly used to avoid `instanceof` checks
           *
           * @member {number}
           * @readonly
           * @default PIXI.SHAPES.RREC
           * @see PIXI.SHAPES
           */
          this.type = _const.SHAPES.RREC;
        }

        /**
         * Creates a clone of this Rounded Rectangle
         *
         * @return {PIXI.RoundedRectangle} a copy of the rounded rectangle
         */

        RoundedRectangle.prototype.clone = function clone() {
          return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
        };

        /**
         * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
         *
         * @param {number} x - The X coordinate of the point to test
         * @param {number} y - The Y coordinate of the point to test
         * @return {boolean} Whether the x/y coordinates are within this Rounded Rectangle
         */

        RoundedRectangle.prototype.contains = function contains(x, y) {
          if (this.width <= 0 || this.height <= 0) {
            return false;
          }
          if (x >= this.x && x <= this.x + this.width) {
            if (y >= this.y && y <= this.y + this.height) {
              if (
                (y >= this.y + this.radius && y <= this.y + this.height - this.radius) ||
                (x >= this.x + this.radius && x <= this.x + this.width - this.radius)
              ) {
                return true;
              }
              var dx = x - (this.x + this.radius);
              var dy = y - (this.y + this.radius);
              var radius2 = this.radius * this.radius;

              if (dx * dx + dy * dy <= radius2) {
                return true;
              }
              dx = x - (this.x + this.width - this.radius);
              if (dx * dx + dy * dy <= radius2) {
                return true;
              }
              dy = y - (this.y + this.height - this.radius);
              if (dx * dx + dy * dy <= radius2) {
                return true;
              }
              dx = x - (this.x + this.radius);
              if (dx * dx + dy * dy <= radius2) {
                return true;
              }
            }
          }

          return false;
        };

        return RoundedRectangle;
      })();

      exports.default = RoundedRectangle;
      //# sourceMappingURL=RoundedRectangle.js.map

      /***/
    },
    /* 480 */
    /***/ function (module, exports) {
      /**
       * Helper class to create a webGL Context
       *
       * @class
       * @memberof PIXI.glCore
       * @param canvas {HTMLCanvasElement} the canvas element that we will get the context from
       * @param options {Object} An options object that gets passed in to the canvas element containing the context attributes,
       *                         see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext for the options available
       * @return {WebGLRenderingContext} the WebGL context
       */
      var createContext = function (canvas, options) {
        var gl = canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options);

        if (!gl) {
          // fail, not able to get a context
          throw new Error("This browser does not support webGL. Try using the canvas renderer");
        }

        return gl;
      };

      module.exports = createContext;

      /***/
    },
    /* 481 */
    /***/ function (module, exports) {
      var EMPTY_ARRAY_BUFFER = new ArrayBuffer(0);

      /**
       * Helper class to create a webGL buffer
       *
       * @class
       * @memberof PIXI.glCore
       * @param gl {WebGLRenderingContext} The current WebGL rendering context
       * @param type {gl.ARRAY_BUFFER | gl.ELEMENT_ARRAY_BUFFER} @mat
       * @param data {ArrayBuffer| SharedArrayBuffer|ArrayBufferView} an array of data
       * @param drawType {gl.STATIC_DRAW|gl.DYNAMIC_DRAW|gl.STREAM_DRAW}
       */
      var Buffer = function (gl, type, data, drawType) {
        /**
         * The current WebGL rendering context
         *
         * @member {WebGLRenderingContext}
         */
        this.gl = gl;

        /**
         * The WebGL buffer, created upon instantiation
         *
         * @member {WebGLBuffer}
         */
        this.buffer = gl.createBuffer();

        /**
         * The type of the buffer
         *
         * @member {gl.ARRAY_BUFFER|gl.ELEMENT_ARRAY_BUFFER}
         */
        this.type = type || gl.ARRAY_BUFFER;

        /**
         * The draw type of the buffer
         *
         * @member {gl.STATIC_DRAW|gl.DYNAMIC_DRAW|gl.STREAM_DRAW}
         */
        this.drawType = drawType || gl.STATIC_DRAW;

        /**
         * The data in the buffer, as a typed array
         *
         * @member {ArrayBuffer| SharedArrayBuffer|ArrayBufferView}
         */
        this.data = EMPTY_ARRAY_BUFFER;

        if (data) {
          this.upload(data);
        }

        this._updateID = 0;
      };

      /**
       * Uploads the buffer to the GPU
       * @param data {ArrayBuffer| SharedArrayBuffer|ArrayBufferView} an array of data to upload
       * @param offset {Number} if only a subset of the data should be uploaded, this is the amount of data to subtract
       * @param dontBind {Boolean} whether to bind the buffer before uploading it
       */
      Buffer.prototype.upload = function (data, offset, dontBind) {
        // todo - needed?
        if (!dontBind) this.bind();

        var gl = this.gl;

        data = data || this.data;
        offset = offset || 0;

        if (this.data.byteLength >= data.byteLength) {
          gl.bufferSubData(this.type, offset, data);
        } else {
          gl.bufferData(this.type, data, this.drawType);
        }

        this.data = data;
      };
      /**
       * Binds the buffer
       *
       */
      Buffer.prototype.bind = function () {
        var gl = this.gl;
        gl.bindBuffer(this.type, this.buffer);
      };

      Buffer.createVertexBuffer = function (gl, data, drawType) {
        return new Buffer(gl, gl.ARRAY_BUFFER, data, drawType);
      };

      Buffer.createIndexBuffer = function (gl, data, drawType) {
        return new Buffer(gl, gl.ELEMENT_ARRAY_BUFFER, data, drawType);
      };

      Buffer.create = function (gl, type, data, drawType) {
        return new Buffer(gl, type, data, drawType);
      };

      /**
       * Destroys the buffer
       *
       */
      Buffer.prototype.destroy = function () {
        this.gl.deleteBuffer(this.buffer);
      };

      module.exports = Buffer;

      /***/
    },
    /* 482 */
    /***/ function (module, exports, __webpack_require__) {
      var Texture = __webpack_require__(396);

      /**
       * Helper class to create a webGL Framebuffer
       *
       * @class
       * @memberof PIXI.glCore
       * @param gl {WebGLRenderingContext} The current WebGL rendering context
       * @param width {Number} the width of the drawing area of the frame buffer
       * @param height {Number} the height of the drawing area of the frame buffer
       */
      var Framebuffer = function (gl, width, height) {
        /**
         * The current WebGL rendering context
         *
         * @member {WebGLRenderingContext}
         */
        this.gl = gl;

        /**
         * The frame buffer
         *
         * @member {WebGLFramebuffer}
         */
        this.framebuffer = gl.createFramebuffer();

        /**
         * The stencil buffer
         *
         * @member {WebGLRenderbuffer}
         */
        this.stencil = null;

        /**
         * The stencil buffer
         *
         * @member {PIXI.glCore.GLTexture}
         */
        this.texture = null;

        /**
         * The width of the drawing area of the buffer
         *
         * @member {Number}
         */
        this.width = width || 100;
        /**
         * The height of the drawing area of the buffer
         *
         * @member {Number}
         */
        this.height = height || 100;
      };

      /**
       * Adds a texture to the frame buffer
       * @param texture {PIXI.glCore.GLTexture}
       */
      Framebuffer.prototype.enableTexture = function (texture) {
        var gl = this.gl;

        this.texture = texture || new Texture(gl);

        this.texture.bind();

        //gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,  this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

        this.bind();

        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.texture, 0);
      };

      /**
       * Initialises the stencil buffer
       */
      Framebuffer.prototype.enableStencil = function () {
        if (this.stencil) return;

        var gl = this.gl;

        this.stencil = gl.createRenderbuffer();

        gl.bindRenderbuffer(gl.RENDERBUFFER, this.stencil);

        // TODO.. this is depth AND stencil?
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this.stencil);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, this.width, this.height);
      };

      /**
       * Erases the drawing area and fills it with a colour
       * @param  r {Number} the red value of the clearing colour
       * @param  g {Number} the green value of the clearing colour
       * @param  b {Number} the blue value of the clearing colour
       * @param  a {Number} the alpha value of the clearing colour
       */
      Framebuffer.prototype.clear = function (r, g, b, a) {
        this.bind();

        var gl = this.gl;

        gl.clearColor(r, g, b, a);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      };

      /**
       * Binds the frame buffer to the WebGL context
       */
      Framebuffer.prototype.bind = function () {
        var gl = this.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
      };

      /**
       * Unbinds the frame buffer to the WebGL context
       */
      Framebuffer.prototype.unbind = function () {
        var gl = this.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      };
      /**
       * Resizes the drawing area of the buffer to the given width and height
       * @param  width  {Number} the new width
       * @param  height {Number} the new height
       */
      Framebuffer.prototype.resize = function (width, height) {
        var gl = this.gl;

        this.width = width;
        this.height = height;

        if (this.texture) {
          this.texture.uploadData(null, width, height);
        }

        if (this.stencil) {
          // update the stencil buffer width and height
          gl.bindRenderbuffer(gl.RENDERBUFFER, this.stencil);
          gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);
        }
      };

      /**
       * Destroys this buffer
       */
      Framebuffer.prototype.destroy = function () {
        var gl = this.gl;

        //TODO
        if (this.texture) {
          this.texture.destroy();
        }

        gl.deleteFramebuffer(this.framebuffer);

        this.gl = null;

        this.stencil = null;
        this.texture = null;
      };

      /**
       * Creates a frame buffer with a texture containing the given data
       * @static
       * @param gl {WebGLRenderingContext} The current WebGL rendering context
       * @param width {Number} the width of the drawing area of the frame buffer
       * @param height {Number} the height of the drawing area of the frame buffer
       * @param data {ArrayBuffer| SharedArrayBuffer|ArrayBufferView} an array of data
       */
      Framebuffer.createRGBA = function (gl, width, height, data) {
        var texture = Texture.fromData(gl, null, width, height);
        texture.enableNearestScaling();
        texture.enableWrapClamp();

        //now create the framebuffer object and attach the texture to it.
        var fbo = new Framebuffer(gl, width, height);
        fbo.enableTexture(texture);
        //fbo.enableStencil(); // get this back on soon!

        //fbo.enableStencil(); // get this back on soon!

        fbo.unbind();

        return fbo;
      };

      /**
       * Creates a frame buffer with a texture containing the given data
       * @static
       * @param gl {WebGLRenderingContext} The current WebGL rendering context
       * @param width {Number} the width of the drawing area of the frame buffer
       * @param height {Number} the height of the drawing area of the frame buffer
       * @param data {ArrayBuffer| SharedArrayBuffer|ArrayBufferView} an array of data
       */
      Framebuffer.createFloat32 = function (gl, width, height, data) {
        // create a new texture..
        var texture = new Texture.fromData(gl, data, width, height);
        texture.enableNearestScaling();
        texture.enableWrapClamp();

        //now create the framebuffer object and attach the texture to it.
        var fbo = new Framebuffer(gl, width, height);
        fbo.enableTexture(texture);

        fbo.unbind();

        return fbo;
      };

      module.exports = Framebuffer;

      /***/
    },
    /* 483 */
    /***/ function (module, exports, __webpack_require__) {
      var compileProgram = __webpack_require__(397),
        extractAttributes = __webpack_require__(398),
        extractUniforms = __webpack_require__(400),
        setPrecision = __webpack_require__(402),
        generateUniformAccessObject = __webpack_require__(403);

      /**
       * Helper class to create a webGL Shader
       *
       * @class
       * @memberof PIXI.glCore
       * @param gl {WebGLRenderingContext}
       * @param vertexSrc {string|string[]} The vertex shader source as an array of strings.
       * @param fragmentSrc {string|string[]} The fragment shader source as an array of strings.
       * @param precision {string} The float precision of the shader. Options are 'lowp', 'mediump' or 'highp'.
       * @param attributeLocations {object} A key value pair showing which location eact attribute should sit eg {position:0, uvs:1}
       */
      var Shader = function (gl, vertexSrc, fragmentSrc, precision, attributeLocations) {
        /**
         * The current WebGL rendering context
         *
         * @member {WebGLRenderingContext}
         */
        this.gl = gl;

        if (precision) {
          vertexSrc = setPrecision(vertexSrc, precision);
          fragmentSrc = setPrecision(fragmentSrc, precision);
        }

        /**
         * The shader program
         *
         * @member {WebGLProgram}
         */
        // First compile the program..
        this.program = compileProgram(gl, vertexSrc, fragmentSrc, attributeLocations);

        /**
         * The attributes of the shader as an object containing the following properties
         * {
         * 	type,
         * 	size,
         * 	location,
         * 	pointer
         * }
         * @member {Object}
         */
        // next extract the attributes
        this.attributes = extractAttributes(gl, this.program);

        this.uniformData = extractUniforms(gl, this.program);

        /**
         * The uniforms of the shader as an object containing the following properties
         * {
         * 	gl,
         * 	data
         * }
         * @member {Object}
         */
        this.uniforms = generateUniformAccessObject(gl, this.uniformData);
      };
      /**
       * Uses this shader
       *
       * @return {PIXI.glCore.GLShader} Returns itself.
       */
      Shader.prototype.bind = function () {
        this.gl.useProgram(this.program);
        return this;
      };

      /**
       * Destroys this shader
       * TODO
       */
      Shader.prototype.destroy = function () {
        this.attributes = null;
        this.uniformData = null;
        this.uniforms = null;

        var gl = this.gl;
        gl.deleteProgram(this.program);
      };

      module.exports = Shader;

      /***/
    },
    /* 484 */
    /***/ function (module, exports, __webpack_require__) {
      // state object//
      var setVertexAttribArrays = __webpack_require__(395);

      /**
       * Helper class to work with WebGL VertexArrayObjects (vaos)
       * Only works if WebGL extensions are enabled (they usually are)
       *
       * @class
       * @memberof PIXI.glCore
       * @param gl {WebGLRenderingContext} The current WebGL rendering context
       */
      function VertexArrayObject(gl, state) {
        this.nativeVaoExtension = null;

        if (!VertexArrayObject.FORCE_NATIVE) {
          this.nativeVaoExtension =
            gl.getExtension("OES_vertex_array_object") ||
            gl.getExtension("MOZ_OES_vertex_array_object") ||
            gl.getExtension("WEBKIT_OES_vertex_array_object");
        }

        this.nativeState = state;

        if (this.nativeVaoExtension) {
          this.nativeVao = this.nativeVaoExtension.createVertexArrayOES();

          var maxAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);

          // VAO - overwrite the state..
          this.nativeState = {
            tempAttribState: new Array(maxAttribs),
            attribState: new Array(maxAttribs),
          };
        }

        /**
         * The current WebGL rendering context
         *
         * @member {WebGLRenderingContext}
         */
        this.gl = gl;

        /**
         * An array of attributes
         *
         * @member {Array}
         */
        this.attributes = [];

        /**
         * @member {PIXI.glCore.GLBuffer}
         */
        this.indexBuffer = null;

        /**
         * A boolean flag
         *
         * @member {Boolean}
         */
        this.dirty = false;
      }

      VertexArrayObject.prototype.constructor = VertexArrayObject;
      module.exports = VertexArrayObject;

      /**
       * Some devices behave a bit funny when using the newer extensions (im looking at you ipad 2!)
       * If you find on older devices that things have gone a bit weird then set this to true.
       */
      /**
       * Lets the VAO know if you should use the WebGL extension or the native methods.
       * Some devices behave a bit funny when using the newer extensions (im looking at you ipad 2!)
       * If you find on older devices that things have gone a bit weird then set this to true.
       * @static
       * @property {Boolean} FORCE_NATIVE
       */
      VertexArrayObject.FORCE_NATIVE = false;

      /**
       * Binds the buffer
       */
      VertexArrayObject.prototype.bind = function () {
        if (this.nativeVao) {
          this.nativeVaoExtension.bindVertexArrayOES(this.nativeVao);

          if (this.dirty) {
            this.dirty = false;
            this.activate();
            return this;
          }
          if (this.indexBuffer) {
            this.indexBuffer.bind();
          }
        } else {
          this.activate();
        }

        return this;
      };

      /**
       * Unbinds the buffer
       */
      VertexArrayObject.prototype.unbind = function () {
        if (this.nativeVao) {
          this.nativeVaoExtension.bindVertexArrayOES(null);
        }

        return this;
      };

      /**
       * Uses this vao
       */
      VertexArrayObject.prototype.activate = function () {
        var gl = this.gl;
        var lastBuffer = null;

        for (var i = 0; i < this.attributes.length; i++) {
          var attrib = this.attributes[i];

          if (lastBuffer !== attrib.buffer) {
            attrib.buffer.bind();
            lastBuffer = attrib.buffer;
          }

          gl.vertexAttribPointer(
            attrib.attribute.location,
            attrib.attribute.size,
            attrib.type || gl.FLOAT,
            attrib.normalized || false,
            attrib.stride || 0,
            attrib.start || 0
          );
        }

        setVertexAttribArrays(gl, this.attributes, this.nativeState);

        if (this.indexBuffer) {
          this.indexBuffer.bind();
        }

        return this;
      };

      /**
       *
       * @param buffer     {PIXI.gl.GLBuffer}
       * @param attribute  {*}
       * @param type       {String}
       * @param normalized {Boolean}
       * @param stride     {Number}
       * @param start      {Number}
       */
      VertexArrayObject.prototype.addAttribute = function (buffer, attribute, type, normalized, stride, start) {
        this.attributes.push({
          buffer: buffer,
          attribute: attribute,

          location: attribute.location,
          type: type || this.gl.FLOAT,
          normalized: normalized || false,
          stride: stride || 0,
          start: start || 0,
        });

        this.dirty = true;

        return this;
      };

      /**
       *
       * @param buffer   {PIXI.gl.GLBuffer}
       */
      VertexArrayObject.prototype.addIndex = function (buffer /*, options*/) {
        this.indexBuffer = buffer;

        this.dirty = true;

        return this;
      };

      /**
       * Unbinds this vao and disables it
       */
      VertexArrayObject.prototype.clear = function () {
        // var gl = this.gl;

        // TODO - should this function unbind after clear?
        // for now, no but lets see what happens in the real world!
        if (this.nativeVao) {
          this.nativeVaoExtension.bindVertexArrayOES(this.nativeVao);
        }

        this.attributes.length = 0;
        this.indexBuffer = null;

        return this;
      };

      /**
       * @param type  {Number}
       * @param size  {Number}
       * @param start {Number}
       */
      VertexArrayObject.prototype.draw = function (type, size, start) {
        var gl = this.gl;

        if (this.indexBuffer) {
          gl.drawElements(type, size || this.indexBuffer.data.length, gl.UNSIGNED_SHORT, (start || 0) * 2);
        } else {
          // TODO need a better way to calculate size..
          gl.drawArrays(type, start, size || this.getSize());
        }

        return this;
      };

      /**
       * Destroy this vao
       */
      VertexArrayObject.prototype.destroy = function () {
        // lose references
        this.gl = null;
        this.indexBuffer = null;
        this.attributes = null;
        this.nativeState = null;

        if (this.nativeVao) {
          this.nativeVaoExtension.deleteVertexArrayOES(this.nativeVao);
        }

        this.nativeVaoExtension = null;
        this.nativeVao = null;
      };

      VertexArrayObject.prototype.getSize = function () {
        var attrib = this.attributes[0];
        return attrib.buffer.data.length / (attrib.stride / 4 || attrib.attribute.size);
      };

      /***/
    },
    /* 485 */
    /***/ function (module, exports, __webpack_require__) {
      module.exports = {
        compileProgram: __webpack_require__(397),
        defaultValue: __webpack_require__(401),
        extractAttributes: __webpack_require__(398),
        extractUniforms: __webpack_require__(400),
        generateUniformAccessObject: __webpack_require__(403),
        setPrecision: __webpack_require__(402),
        mapSize: __webpack_require__(399),
        mapType: __webpack_require__(376),
      };

      /***/
    },
    /* 486 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;
      exports.default = maxRecommendedTextures;

      var _ismobilejs = __webpack_require__(378);

      var _ismobilejs2 = _interopRequireDefault(_ismobilejs);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function maxRecommendedTextures(max) {
        if (_ismobilejs2.default.tablet || _ismobilejs2.default.phone) {
          // check if the res is iphone 6 or higher..
          return 4;
        }

        // desktop should be ok
        return max;
      }
      //# sourceMappingURL=maxRecommendedTextures.js.map

      /***/
    },
    /* 487 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;
      exports.default = canUploadSameBuffer;
      function canUploadSameBuffer() {
        // Uploading the same buffer multiple times in a single frame can cause perf issues.
        // Apparent on IOS so only check for that at the moment
        // this check may become more complex if this issue pops up elsewhere.
        var ios = !!navigator.platform && /iPad|iPhone|iPod/.test(navigator.platform);

        return !ios;
      }
      //# sourceMappingURL=canUploadSameBuffer.js.map

      /***/
    },
    /* 488 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;
      /**
       * Mixins functionality to make an object have "plugins".
       *
       * @example
       *      function MyObject() {}
       *
       *      pluginTarget.mixin(MyObject);
       *
       * @mixin
       * @memberof PIXI.utils
       * @param {object} obj - The object to mix into.
       */
      function pluginTarget(obj) {
        obj.__plugins = {};

        /**
         * Adds a plugin to an object
         *
         * @param {string} pluginName - The events that should be listed.
         * @param {Function} ctor - The constructor function for the plugin.
         */
        obj.registerPlugin = function registerPlugin(pluginName, ctor) {
          obj.__plugins[pluginName] = ctor;
        };

        /**
         * Instantiates all the plugins of this object
         *
         */
        obj.prototype.initPlugins = function initPlugins() {
          this.plugins = this.plugins || {};

          for (var o in obj.__plugins) {
            this.plugins[o] = new obj.__plugins[o](this);
          }
        };

        /**
         * Removes all the plugins of this object
         *
         */
        obj.prototype.destroyPlugins = function destroyPlugins() {
          for (var o in this.plugins) {
            this.plugins[o].destroy();
            this.plugins[o] = null;
          }

          this.plugins = null;
        };
      }

      exports.default = {
        /**
         * Mixes in the properties of the pluginTarget into another object
         *
         * @param {object} obj - The obj to mix into
         */
        mixin: function mixin(obj) {
          pluginTarget(obj);
        },
      };
      //# sourceMappingURL=pluginTarget.js.map

      /***/
    },
    /* 489 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;
      exports.mixin = mixin;
      exports.delayMixin = delayMixin;
      exports.performMixins = performMixins;
      /**
       * Mixes all enumerable properties and methods from a source object to a target object.
       *
       * @memberof PIXI.utils.mixins
       * @function mixin
       * @param {object} target The prototype or instance that properties and methods should be added to.
       * @param {object} source The source of properties and methods to mix in.
       */
      function mixin(target, source) {
        if (!target || !source) return;
        // in ES8/ES2017, this would be really easy:
        // Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));

        // get all the enumerable property keys
        var keys = Object.keys(source);

        // loop through properties
        for (var i = 0; i < keys.length; ++i) {
          var propertyName = keys[i];

          // Set the property using the property descriptor - this works for accessors and normal value properties
          Object.defineProperty(target, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
        }
      }

      var mixins = [];

      /**
       * Queues a mixin to be handled towards the end of the initialization of PIXI, so that deprecation
       * can take effect.
       *
       * @memberof PIXI.utils.mixins
       * @function delayMixin
       * @private
       * @param {object} target The prototype or instance that properties and methods should be added to.
       * @param {object} source The source of properties and methods to mix in.
       */
      function delayMixin(target, source) {
        mixins.push(target, source);
      }

      /**
       * Handles all mixins queued via delayMixin().
       *
       * @memberof PIXI.utils.mixins
       * @function performMixins
       * @private
       */
      function performMixins() {
        for (var i = 0; i < mixins.length; i += 2) {
          mixin(mixins[i], mixins[i + 1]);
        }
        mixins.length = 0;
      }
      //# sourceMappingURL=mixin.js.map

      /***/
    },
    /* 490 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      /**
       * Remove a range of items from an array
       *
       * @function removeItems
       * @param {Array<*>} arr The target array
       * @param {number} startIdx The index to begin removing from (inclusive)
       * @param {number} removeCount How many items to remove
       */
      module.exports = function removeItems(arr, startIdx, removeCount) {
        var i,
          length = arr.length;

        if (startIdx >= length || removeCount === 0) {
          return;
        }

        removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;

        var len = length - removeCount;

        for (i = startIdx; i < len; ++i) {
          arr[i] = arr[i + removeCount];
        }

        arr.length = len;
      };

      /***/
    },
    /* 491 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;
      exports.default = mapPremultipliedBlendModes;

      var _const = __webpack_require__(343);

      /**
       * Corrects PixiJS blend, takes premultiplied alpha into account
       *
       * @memberof PIXI
       * @function mapPremultipliedBlendModes
       * @private
       * @param {Array<number[]>} [array] - The array to output into.
       * @return {Array<number[]>} Mapped modes.
       */

      function mapPremultipliedBlendModes() {
        var pm = [];
        var npm = [];

        for (var i = 0; i < 32; i++) {
          pm[i] = i;
          npm[i] = i;
        }

        pm[_const.BLEND_MODES.NORMAL_NPM] = _const.BLEND_MODES.NORMAL;
        pm[_const.BLEND_MODES.ADD_NPM] = _const.BLEND_MODES.ADD;
        pm[_const.BLEND_MODES.SCREEN_NPM] = _const.BLEND_MODES.SCREEN;

        npm[_const.BLEND_MODES.NORMAL] = _const.BLEND_MODES.NORMAL_NPM;
        npm[_const.BLEND_MODES.ADD] = _const.BLEND_MODES.ADD_NPM;
        npm[_const.BLEND_MODES.SCREEN] = _const.BLEND_MODES.SCREEN_NPM;

        var array = [];

        array.push(npm);
        array.push(pm);

        return array;
      }
      //# sourceMappingURL=mapPremultipliedBlendModes.js.map

      /***/
    },
    /* 492 */
    /***/ function (module, exports, __webpack_require__) {
      /* WEBPACK VAR INJECTION */ (function (module, global) {
        var __WEBPACK_AMD_DEFINE_RESULT__; /*! https://mths.be/punycode v1.4.1 by @mathias */
        (function (root) {
          /** Detect free variables */
          var freeExports = true && exports && !exports.nodeType && exports;
          var freeModule = true && module && !module.nodeType && module;
          var freeGlobal = typeof global == "object" && global;
          if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
            root = freeGlobal;
          }

          /**
           * The `punycode` object.
           * @name punycode
           * @type Object
           */
          var punycode,
            /** Highest positive signed 32-bit float value */
            maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1
            /** Bootstring parameters */
            base = 36,
            tMin = 1,
            tMax = 26,
            skew = 38,
            damp = 700,
            initialBias = 72,
            initialN = 128, // 0x80
            delimiter = "-", // '\x2D'
            /** Regular expressions */
            regexPunycode = /^xn--/,
            regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
            regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators
            /** Error messages */
            errors = {
              overflow: "Overflow: input needs wider integers to process",
              "not-basic": "Illegal input >= 0x80 (not a basic code point)",
              "invalid-input": "Invalid input",
            },
            /** Convenience shortcuts */
            baseMinusTMin = base - tMin,
            floor = Math.floor,
            stringFromCharCode = String.fromCharCode,
            /** Temporary variable */
            key;

          /*--------------------------------------------------------------------------*/

          /**
           * A generic error utility function.
           * @private
           * @param {String} type The error type.
           * @returns {Error} Throws a `RangeError` with the applicable error message.
           */
          function error(type) {
            throw new RangeError(errors[type]);
          }

          /**
           * A generic `Array#map` utility function.
           * @private
           * @param {Array} array The array to iterate over.
           * @param {Function} callback The function that gets called for every array
           * item.
           * @returns {Array} A new array of values returned by the callback function.
           */
          function map(array, fn) {
            var length = array.length;
            var result = [];
            while (length--) {
              result[length] = fn(array[length]);
            }
            return result;
          }

          /**
           * A simple `Array#map`-like wrapper to work with domain name strings or email
           * addresses.
           * @private
           * @param {String} domain The domain name or email address.
           * @param {Function} callback The function that gets called for every
           * character.
           * @returns {Array} A new string of characters returned by the callback
           * function.
           */
          function mapDomain(string, fn) {
            var parts = string.split("@");
            var result = "";
            if (parts.length > 1) {
              // In email addresses, only the domain name should be punycoded. Leave
              // the local part (i.e. everything up to `@`) intact.
              result = parts[0] + "@";
              string = parts[1];
            }
            // Avoid `split(regex)` for IE8 compatibility. See #17.
            string = string.replace(regexSeparators, "\x2E");
            var labels = string.split(".");
            var encoded = map(labels, fn).join(".");
            return result + encoded;
          }

          /**
           * Creates an array containing the numeric code points of each Unicode
           * character in the string. While JavaScript uses UCS-2 internally,
           * this function will convert a pair of surrogate halves (each of which
           * UCS-2 exposes as separate characters) into a single code point,
           * matching UTF-16.
           * @see `punycode.ucs2.encode`
           * @see <https://mathiasbynens.be/notes/javascript-encoding>
           * @memberOf punycode.ucs2
           * @name decode
           * @param {String} string The Unicode input string (UCS-2).
           * @returns {Array} The new array of code points.
           */
          function ucs2decode(string) {
            var output = [],
              counter = 0,
              length = string.length,
              value,
              extra;
            while (counter < length) {
              value = string.charCodeAt(counter++);
              if (value >= 0xd800 && value <= 0xdbff && counter < length) {
                // high surrogate, and there is a next character
                extra = string.charCodeAt(counter++);
                if ((extra & 0xfc00) == 0xdc00) {
                  // low surrogate
                  output.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);
                } else {
                  // unmatched surrogate; only append this code unit, in case the next
                  // code unit is the high surrogate of a surrogate pair
                  output.push(value);
                  counter--;
                }
              } else {
                output.push(value);
              }
            }
            return output;
          }

          /**
           * Creates a string based on an array of numeric code points.
           * @see `punycode.ucs2.decode`
           * @memberOf punycode.ucs2
           * @name encode
           * @param {Array} codePoints The array of numeric code points.
           * @returns {String} The new Unicode string (UCS-2).
           */
          function ucs2encode(array) {
            return map(array, function (value) {
              var output = "";
              if (value > 0xffff) {
                value -= 0x10000;
                output += stringFromCharCode(((value >>> 10) & 0x3ff) | 0xd800);
                value = 0xdc00 | (value & 0x3ff);
              }
              output += stringFromCharCode(value);
              return output;
            }).join("");
          }

          /**
           * Converts a basic code point into a digit/integer.
           * @see `digitToBasic()`
           * @private
           * @param {Number} codePoint The basic numeric code point value.
           * @returns {Number} The numeric value of a basic code point (for use in
           * representing integers) in the range `0` to `base - 1`, or `base` if
           * the code point does not represent a value.
           */
          function basicToDigit(codePoint) {
            if (codePoint - 48 < 10) {
              return codePoint - 22;
            }
            if (codePoint - 65 < 26) {
              return codePoint - 65;
            }
            if (codePoint - 97 < 26) {
              return codePoint - 97;
            }
            return base;
          }

          /**
           * Converts a digit/integer into a basic code point.
           * @see `basicToDigit()`
           * @private
           * @param {Number} digit The numeric value of a basic code point.
           * @returns {Number} The basic code point whose value (when used for
           * representing integers) is `digit`, which needs to be in the range
           * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
           * used; else, the lowercase form is used. The behavior is undefined
           * if `flag` is non-zero and `digit` has no uppercase form.
           */
          function digitToBasic(digit, flag) {
            //  0..25 map to ASCII a..z or A..Z
            // 26..35 map to ASCII 0..9
            return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
          }

          /**
           * Bias adaptation function as per section 3.4 of RFC 3492.
           * https://tools.ietf.org/html/rfc3492#section-3.4
           * @private
           */
          function adapt(delta, numPoints, firstTime) {
            var k = 0;
            delta = firstTime ? floor(delta / damp) : delta >> 1;
            delta += floor(delta / numPoints);
            for (; /* no initialization */ delta > (baseMinusTMin * tMax) >> 1; k += base) {
              delta = floor(delta / baseMinusTMin);
            }
            return floor(k + ((baseMinusTMin + 1) * delta) / (delta + skew));
          }

          /**
           * Converts a Punycode string of ASCII-only symbols to a string of Unicode
           * symbols.
           * @memberOf punycode
           * @param {String} input The Punycode string of ASCII-only symbols.
           * @returns {String} The resulting string of Unicode symbols.
           */
          function decode(input) {
            // Don't use UCS-2
            var output = [],
              inputLength = input.length,
              out,
              i = 0,
              n = initialN,
              bias = initialBias,
              basic,
              j,
              index,
              oldi,
              w,
              k,
              digit,
              t,
              /** Cached calculation results */
              baseMinusT;

            // Handle the basic code points: let `basic` be the number of input code
            // points before the last delimiter, or `0` if there is none, then copy
            // the first basic code points to the output.

            basic = input.lastIndexOf(delimiter);
            if (basic < 0) {
              basic = 0;
            }

            for (j = 0; j < basic; ++j) {
              // if it's not a basic code point
              if (input.charCodeAt(j) >= 0x80) {
                error("not-basic");
              }
              output.push(input.charCodeAt(j));
            }

            // Main decoding loop: start just after the last delimiter if any basic code
            // points were copied; start at the beginning otherwise.

            for (index = basic > 0 ? basic + 1 : 0; index < inputLength /* no final expression */; ) {
              // `index` is the index of the next character to be consumed.
              // Decode a generalized variable-length integer into `delta`,
              // which gets added to `i`. The overflow checking is easier
              // if we increase `i` as we go, then subtract off its starting
              // value at the end to obtain `delta`.
              for (oldi = i, w = 1, k = base /* no condition */; ; k += base) {
                if (index >= inputLength) {
                  error("invalid-input");
                }

                digit = basicToDigit(input.charCodeAt(index++));

                if (digit >= base || digit > floor((maxInt - i) / w)) {
                  error("overflow");
                }

                i += digit * w;
                t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

                if (digit < t) {
                  break;
                }

                baseMinusT = base - t;
                if (w > floor(maxInt / baseMinusT)) {
                  error("overflow");
                }

                w *= baseMinusT;
              }

              out = output.length + 1;
              bias = adapt(i - oldi, out, oldi == 0);

              // `i` was supposed to wrap around from `out` to `0`,
              // incrementing `n` each time, so we'll fix that now:
              if (floor(i / out) > maxInt - n) {
                error("overflow");
              }

              n += floor(i / out);
              i %= out;

              // Insert `n` at position `i` of the output
              output.splice(i++, 0, n);
            }

            return ucs2encode(output);
          }

          /**
           * Converts a string of Unicode symbols (e.g. a domain name label) to a
           * Punycode string of ASCII-only symbols.
           * @memberOf punycode
           * @param {String} input The string of Unicode symbols.
           * @returns {String} The resulting Punycode string of ASCII-only symbols.
           */
          function encode(input) {
            var n,
              delta,
              handledCPCount,
              basicLength,
              bias,
              j,
              m,
              q,
              k,
              t,
              currentValue,
              output = [],
              /** `inputLength` will hold the number of code points in `input`. */
              inputLength,
              /** Cached calculation results */
              handledCPCountPlusOne,
              baseMinusT,
              qMinusT;

            // Convert the input in UCS-2 to Unicode
            input = ucs2decode(input);

            // Cache the length
            inputLength = input.length;

            // Initialize the state
            n = initialN;
            delta = 0;
            bias = initialBias;

            // Handle the basic code points
            for (j = 0; j < inputLength; ++j) {
              currentValue = input[j];
              if (currentValue < 0x80) {
                output.push(stringFromCharCode(currentValue));
              }
            }

            handledCPCount = basicLength = output.length;

            // `handledCPCount` is the number of code points that have been handled;
            // `basicLength` is the number of basic code points.

            // Finish the basic string - if it is not empty - with a delimiter
            if (basicLength) {
              output.push(delimiter);
            }

            // Main encoding loop:
            while (handledCPCount < inputLength) {
              // All non-basic code points < n have been handled already. Find the next
              // larger one:
              for (m = maxInt, j = 0; j < inputLength; ++j) {
                currentValue = input[j];
                if (currentValue >= n && currentValue < m) {
                  m = currentValue;
                }
              }

              // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
              // but guard against overflow
              handledCPCountPlusOne = handledCPCount + 1;
              if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                error("overflow");
              }

              delta += (m - n) * handledCPCountPlusOne;
              n = m;

              for (j = 0; j < inputLength; ++j) {
                currentValue = input[j];

                if (currentValue < n && ++delta > maxInt) {
                  error("overflow");
                }

                if (currentValue == n) {
                  // Represent delta as a generalized variable-length integer
                  for (q = delta, k = base /* no condition */; ; k += base) {
                    t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                    if (q < t) {
                      break;
                    }
                    qMinusT = q - t;
                    baseMinusT = base - t;
                    output.push(stringFromCharCode(digitToBasic(t + (qMinusT % baseMinusT), 0)));
                    q = floor(qMinusT / baseMinusT);
                  }

                  output.push(stringFromCharCode(digitToBasic(q, 0)));
                  bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                  delta = 0;
                  ++handledCPCount;
                }
              }

              ++delta;
              ++n;
            }
            return output.join("");
          }

          /**
           * Converts a Punycode string representing a domain name or an email address
           * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
           * it doesn't matter if you call it on a string that has already been
           * converted to Unicode.
           * @memberOf punycode
           * @param {String} input The Punycoded domain name or email address to
           * convert to Unicode.
           * @returns {String} The Unicode representation of the given Punycode
           * string.
           */
          function toUnicode(input) {
            return mapDomain(input, function (string) {
              return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
            });
          }

          /**
           * Converts a Unicode string representing a domain name or an email address to
           * Punycode. Only the non-ASCII parts of the domain name will be converted,
           * i.e. it doesn't matter if you call it with a domain that's already in
           * ASCII.
           * @memberOf punycode
           * @param {String} input The domain name or email address to convert, as a
           * Unicode string.
           * @returns {String} The Punycode representation of the given domain name or
           * email address.
           */
          function toASCII(input) {
            return mapDomain(input, function (string) {
              return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
            });
          }

          /*--------------------------------------------------------------------------*/

          /** Define the public API */
          punycode = {
            /**
             * A string representing the current Punycode.js version number.
             * @memberOf punycode
             * @type String
             */
            version: "1.4.1",
            /**
             * An object of methods to convert from JavaScript's internal character
             * representation (UCS-2) to Unicode code points, and back.
             * @see <https://mathiasbynens.be/notes/javascript-encoding>
             * @memberOf punycode
             * @type Object
             */
            ucs2: {
              decode: ucs2decode,
              encode: ucs2encode,
            },
            decode: decode,
            encode: encode,
            toASCII: toASCII,
            toUnicode: toUnicode,
          };

          /** Expose `punycode` */
          // Some AMD build optimizers, like r.js, check for specific condition patterns
          // like the following:
          if (true) {
            !((__WEBPACK_AMD_DEFINE_RESULT__ = function () {
              return punycode;
            }.call(exports, __webpack_require__, exports, module)),
            __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
          } else {
          }
        })(this);

        /* WEBPACK VAR INJECTION */
      }).call(this, __webpack_require__(493)(module), __webpack_require__(39));

      /***/
    },
    /* 493 */
    /***/ function (module, exports) {
      module.exports = function (module) {
        if (!module.webpackPolyfill) {
          module.deprecate = function () {};
          module.paths = [];
          // module.parent = undefined by default
          if (!module.children) module.children = [];
          Object.defineProperty(module, "loaded", {
            enumerable: true,
            get: function () {
              return module.l;
            },
          });
          Object.defineProperty(module, "id", {
            enumerable: true,
            get: function () {
              return module.i;
            },
          });
          module.webpackPolyfill = 1;
        }
        return module;
      };

      /***/
    },
    /* 494 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      module.exports = {
        isString: function (arg) {
          return typeof arg === "string";
        },
        isObject: function (arg) {
          return typeof arg === "object" && arg !== null;
        },
        isNull: function (arg) {
          return arg === null;
        },
        isNullOrUndefined: function (arg) {
          return arg == null;
        },
      };

      /***/
    },
    /* 495 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.decode = exports.parse = __webpack_require__(496);
      exports.encode = exports.stringify = __webpack_require__(497);

      /***/
    },
    /* 496 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";
      // Copyright Joyent, Inc. and other Node contributors.
      //
      // Permission is hereby granted, free of charge, to any person obtaining a
      // copy of this software and associated documentation files (the
      // "Software"), to deal in the Software without restriction, including
      // without limitation the rights to use, copy, modify, merge, publish,
      // distribute, sublicense, and/or sell copies of the Software, and to permit
      // persons to whom the Software is furnished to do so, subject to the
      // following conditions:
      //
      // The above copyright notice and this permission notice shall be included
      // in all copies or substantial portions of the Software.
      //
      // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
      // USE OR OTHER DEALINGS IN THE SOFTWARE.

      // If obj.hasOwnProperty has been overridden, then calling
      // obj.hasOwnProperty(prop) will break.
      // See: https://github.com/joyent/node/issues/1707
      function hasOwnProperty(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }

      module.exports = function (qs, sep, eq, options) {
        sep = sep || "&";
        eq = eq || "=";
        var obj = {};

        if (typeof qs !== "string" || qs.length === 0) {
          return obj;
        }

        var regexp = /\+/g;
        qs = qs.split(sep);

        var maxKeys = 1000;
        if (options && typeof options.maxKeys === "number") {
          maxKeys = options.maxKeys;
        }

        var len = qs.length;
        // maxKeys <= 0 means that we should not limit keys count
        if (maxKeys > 0 && len > maxKeys) {
          len = maxKeys;
        }

        for (var i = 0; i < len; ++i) {
          var x = qs[i].replace(regexp, "%20"),
            idx = x.indexOf(eq),
            kstr,
            vstr,
            k,
            v;

          if (idx >= 0) {
            kstr = x.substr(0, idx);
            vstr = x.substr(idx + 1);
          } else {
            kstr = x;
            vstr = "";
          }

          k = decodeURIComponent(kstr);
          v = decodeURIComponent(vstr);

          if (!hasOwnProperty(obj, k)) {
            obj[k] = v;
          } else if (isArray(obj[k])) {
            obj[k].push(v);
          } else {
            obj[k] = [obj[k], v];
          }
        }

        return obj;
      };

      var isArray =
        Array.isArray ||
        function (xs) {
          return Object.prototype.toString.call(xs) === "[object Array]";
        };

      /***/
    },
    /* 497 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";
      // Copyright Joyent, Inc. and other Node contributors.
      //
      // Permission is hereby granted, free of charge, to any person obtaining a
      // copy of this software and associated documentation files (the
      // "Software"), to deal in the Software without restriction, including
      // without limitation the rights to use, copy, modify, merge, publish,
      // distribute, sublicense, and/or sell copies of the Software, and to permit
      // persons to whom the Software is furnished to do so, subject to the
      // following conditions:
      //
      // The above copyright notice and this permission notice shall be included
      // in all copies or substantial portions of the Software.
      //
      // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
      // USE OR OTHER DEALINGS IN THE SOFTWARE.

      var stringifyPrimitive = function (v) {
        switch (typeof v) {
          case "string":
            return v;

          case "boolean":
            return v ? "true" : "false";

          case "number":
            return isFinite(v) ? v : "";

          default:
            return "";
        }
      };

      module.exports = function (obj, sep, eq, name) {
        sep = sep || "&";
        eq = eq || "=";
        if (obj === null) {
          obj = undefined;
        }

        if (typeof obj === "object") {
          return map(objectKeys(obj), function (k) {
            var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
            if (isArray(obj[k])) {
              return map(obj[k], function (v) {
                return ks + encodeURIComponent(stringifyPrimitive(v));
              }).join(sep);
            } else {
              return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
            }
          }).join(sep);
        }

        if (!name) return "";
        return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
      };

      var isArray =
        Array.isArray ||
        function (xs) {
          return Object.prototype.toString.call(xs) === "[object Array]";
        };

      function map(xs, f) {
        if (xs.map) return xs.map(f);
        var res = [];
        for (var i = 0; i < xs.length; i++) {
          res.push(f(xs[i], i));
        }
        return res;
      }

      var objectKeys =
        Object.keys ||
        function (obj) {
          var res = [];
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
          }
          return res;
        };

      /***/
    },
    /* 498 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      var _createClass = (function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      })();

      var _settings = __webpack_require__(346);

      var _settings2 = _interopRequireDefault(_settings);

      var _const = __webpack_require__(343);

      var _TickerListener = __webpack_require__(499);

      var _TickerListener2 = _interopRequireDefault(_TickerListener);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      /**
       * A Ticker class that runs an update loop that other objects listen to.
       * This class is composed around listeners
       * meant for execution on the next requested animation frame.
       * Animation frames are requested only when necessary,
       * e.g. When the ticker is started and the emitter has listeners.
       *
       * @class
       * @memberof PIXI.ticker
       */
      var Ticker = (function () {
        /**
         *
         */
        function Ticker() {
          var _this = this;

          _classCallCheck(this, Ticker);

          /**
           * The first listener. All new listeners added are chained on this.
           * @private
           * @type {TickerListener}
           */
          this._head = new _TickerListener2.default(null, null, Infinity);

          /**
           * Internal current frame request ID
           * @private
           */
          this._requestId = null;

          /**
           * Internal value managed by minFPS property setter and getter.
           * This is the maximum allowed milliseconds between updates.
           * @private
           */
          this._maxElapsedMS = 100;

          /**
           * Whether or not this ticker should invoke the method
           * {@link PIXI.ticker.Ticker#start} automatically
           * when a listener is added.
           *
           * @member {boolean}
           * @default false
           */
          this.autoStart = false;

          /**
           * Scalar time value from last frame to this frame.
           * This value is capped by setting {@link PIXI.ticker.Ticker#minFPS}
           * and is scaled with {@link PIXI.ticker.Ticker#speed}.
           * **Note:** The cap may be exceeded by scaling.
           *
           * @member {number}
           * @default 1
           */
          this.deltaTime = 1;

          /**
           * Time elapsed in milliseconds from last frame to this frame.
           * Opposed to what the scalar {@link PIXI.ticker.Ticker#deltaTime}
           * is based, this value is neither capped nor scaled.
           * If the platform supports DOMHighResTimeStamp,
           * this value will have a precision of 1 µs.
           * Defaults to target frame time
           *
           * @member {number}
           * @default 16.66
           */
          this.elapsedMS = 1 / _settings2.default.TARGET_FPMS;

          /**
           * The last time {@link PIXI.ticker.Ticker#update} was invoked.
           * This value is also reset internally outside of invoking
           * update, but only when a new animation frame is requested.
           * If the platform supports DOMHighResTimeStamp,
           * this value will have a precision of 1 µs.
           *
           * @member {number}
           * @default -1
           */
          this.lastTime = -1;

          /**
           * Factor of current {@link PIXI.ticker.Ticker#deltaTime}.
           * @example
           * // Scales ticker.deltaTime to what would be
           * // the equivalent of approximately 120 FPS
           * ticker.speed = 2;
           *
           * @member {number}
           * @default 1
           */
          this.speed = 1;

          /**
           * Whether or not this ticker has been started.
           * `true` if {@link PIXI.ticker.Ticker#start} has been called.
           * `false` if {@link PIXI.ticker.Ticker#stop} has been called.
           * While `false`, this value may change to `true` in the
           * event of {@link PIXI.ticker.Ticker#autoStart} being `true`
           * and a listener is added.
           *
           * @member {boolean}
           * @default false
           */
          this.started = false;

          /**
           * Internal tick method bound to ticker instance.
           * This is because in early 2015, Function.bind
           * is still 60% slower in high performance scenarios.
           * Also separating frame requests from update method
           * so listeners may be called at any time and with
           * any animation API, just invoke ticker.update(time).
           *
           * @private
           * @param {number} time - Time since last tick.
           */
          this._tick = function (time) {
            _this._requestId = null;

            if (_this.started) {
              // Invoke listeners now
              _this.update(time);
              // Listener side effects may have modified ticker state.
              if (_this.started && _this._requestId === null && _this._head.next) {
                _this._requestId = requestAnimationFrame(_this._tick);
              }
            }
          };
        }

        /**
         * Conditionally requests a new animation frame.
         * If a frame has not already been requested, and if the internal
         * emitter has listeners, a new frame is requested.
         *
         * @private
         */

        Ticker.prototype._requestIfNeeded = function _requestIfNeeded() {
          if (this._requestId === null && this._head.next) {
            // ensure callbacks get correct delta
            this.lastTime = performance.now();
            this._requestId = requestAnimationFrame(this._tick);
          }
        };

        /**
         * Conditionally cancels a pending animation frame.
         *
         * @private
         */

        Ticker.prototype._cancelIfNeeded = function _cancelIfNeeded() {
          if (this._requestId !== null) {
            cancelAnimationFrame(this._requestId);
            this._requestId = null;
          }
        };

        /**
         * Conditionally requests a new animation frame.
         * If the ticker has been started it checks if a frame has not already
         * been requested, and if the internal emitter has listeners. If these
         * conditions are met, a new frame is requested. If the ticker has not
         * been started, but autoStart is `true`, then the ticker starts now,
         * and continues with the previous conditions to request a new frame.
         *
         * @private
         */

        Ticker.prototype._startIfPossible = function _startIfPossible() {
          if (this.started) {
            this._requestIfNeeded();
          } else if (this.autoStart) {
            this.start();
          }
        };

        /**
         * Register a handler for tick events. Calls continuously unless
         * it is removed or the ticker is stopped.
         *
         * @param {Function} fn - The listener function to be added for updates
         * @param {Function} [context] - The listener context
         * @param {number} [priority=PIXI.UPDATE_PRIORITY.NORMAL] - The priority for emitting
         * @returns {PIXI.ticker.Ticker} This instance of a ticker
         */

        Ticker.prototype.add = function add(fn, context) {
          var priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _const.UPDATE_PRIORITY.NORMAL;

          return this._addListener(new _TickerListener2.default(fn, context, priority));
        };

        /**
         * Add a handler for the tick event which is only execute once.
         *
         * @param {Function} fn - The listener function to be added for one update
         * @param {Function} [context] - The listener context
         * @param {number} [priority=PIXI.UPDATE_PRIORITY.NORMAL] - The priority for emitting
         * @returns {PIXI.ticker.Ticker} This instance of a ticker
         */

        Ticker.prototype.addOnce = function addOnce(fn, context) {
          var priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _const.UPDATE_PRIORITY.NORMAL;

          return this._addListener(new _TickerListener2.default(fn, context, priority, true));
        };

        /**
         * Internally adds the event handler so that it can be sorted by priority.
         * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run
         * before the rendering.
         *
         * @private
         * @param {TickerListener} listener - Current listener being added.
         * @returns {PIXI.ticker.Ticker} This instance of a ticker
         */

        Ticker.prototype._addListener = function _addListener(listener) {
          // For attaching to head
          var current = this._head.next;
          var previous = this._head;

          // Add the first item
          if (!current) {
            listener.connect(previous);
          } else {
            // Go from highest to lowest priority
            while (current) {
              if (listener.priority > current.priority) {
                listener.connect(previous);
                break;
              }
              previous = current;
              current = current.next;
            }

            // Not yet connected
            if (!listener.previous) {
              listener.connect(previous);
            }
          }

          this._startIfPossible();

          return this;
        };

        /**
         * Removes any handlers matching the function and context parameters.
         * If no handlers are left after removing, then it cancels the animation frame.
         *
         * @param {Function} fn - The listener function to be removed
         * @param {Function} [context] - The listener context to be removed
         * @returns {PIXI.ticker.Ticker} This instance of a ticker
         */

        Ticker.prototype.remove = function remove(fn, context) {
          var listener = this._head.next;

          while (listener) {
            // We found a match, lets remove it
            // no break to delete all possible matches
            // incase a listener was added 2+ times
            if (listener.match(fn, context)) {
              listener = listener.destroy();
            } else {
              listener = listener.next;
            }
          }

          if (!this._head.next) {
            this._cancelIfNeeded();
          }

          return this;
        };

        /**
         * Starts the ticker. If the ticker has listeners
         * a new animation frame is requested at this point.
         */

        Ticker.prototype.start = function start() {
          if (!this.started) {
            this.started = true;
            this._requestIfNeeded();
          }
        };

        /**
         * Stops the ticker. If the ticker has requested
         * an animation frame it is canceled at this point.
         */

        Ticker.prototype.stop = function stop() {
          if (this.started) {
            this.started = false;
            this._cancelIfNeeded();
          }
        };

        /**
         * Destroy the ticker and don't use after this. Calling
         * this method removes all references to internal events.
         */

        Ticker.prototype.destroy = function destroy() {
          this.stop();

          var listener = this._head.next;

          while (listener) {
            listener = listener.destroy(true);
          }

          this._head.destroy();
          this._head = null;
        };

        /**
         * Triggers an update. An update entails setting the
         * current {@link PIXI.ticker.Ticker#elapsedMS},
         * the current {@link PIXI.ticker.Ticker#deltaTime},
         * invoking all listeners with current deltaTime,
         * and then finally setting {@link PIXI.ticker.Ticker#lastTime}
         * with the value of currentTime that was provided.
         * This method will be called automatically by animation
         * frame callbacks if the ticker instance has been started
         * and listeners are added.
         *
         * @param {number} [currentTime=performance.now()] - the current time of execution
         */

        Ticker.prototype.update = function update() {
          var currentTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : performance.now();

          var elapsedMS = void 0;

          // If the difference in time is zero or negative, we ignore most of the work done here.
          // If there is no valid difference, then should be no reason to let anyone know about it.
          // A zero delta, is exactly that, nothing should update.
          //
          // The difference in time can be negative, and no this does not mean time traveling.
          // This can be the result of a race condition between when an animation frame is requested
          // on the current JavaScript engine event loop, and when the ticker's start method is invoked
          // (which invokes the internal _requestIfNeeded method). If a frame is requested before
          // _requestIfNeeded is invoked, then the callback for the animation frame the ticker requests,
          // can receive a time argument that can be less than the lastTime value that was set within
          // _requestIfNeeded. This difference is in microseconds, but this is enough to cause problems.
          //
          // This check covers this browser engine timing issue, as well as if consumers pass an invalid
          // currentTime value. This may happen if consumers opt-out of the autoStart, and update themselves.

          if (currentTime > this.lastTime) {
            // Save uncapped elapsedMS for measurement
            elapsedMS = this.elapsedMS = currentTime - this.lastTime;

            // cap the milliseconds elapsed used for deltaTime
            if (elapsedMS > this._maxElapsedMS) {
              elapsedMS = this._maxElapsedMS;
            }

            this.deltaTime = elapsedMS * _settings2.default.TARGET_FPMS * this.speed;

            // Cache a local reference, in-case ticker is destroyed
            // during the emit, we can still check for head.next
            var head = this._head;

            // Invoke listeners added to internal emitter
            var listener = head.next;

            while (listener) {
              listener = listener.emit(this.deltaTime);
            }

            if (!head.next) {
              this._cancelIfNeeded();
            }
          } else {
            this.deltaTime = this.elapsedMS = 0;
          }

          this.lastTime = currentTime;
        };

        /**
         * The frames per second at which this ticker is running.
         * The default is approximately 60 in most modern browsers.
         * **Note:** This does not factor in the value of
         * {@link PIXI.ticker.Ticker#speed}, which is specific
         * to scaling {@link PIXI.ticker.Ticker#deltaTime}.
         *
         * @member {number}
         * @readonly
         */

        _createClass(Ticker, [
          {
            key: "FPS",
            get: function get() {
              return 1000 / this.elapsedMS;
            },

            /**
             * Manages the maximum amount of milliseconds allowed to
             * elapse between invoking {@link PIXI.ticker.Ticker#update}.
             * This value is used to cap {@link PIXI.ticker.Ticker#deltaTime},
             * but does not effect the measured value of {@link PIXI.ticker.Ticker#FPS}.
             * When setting this property it is clamped to a value between
             * `0` and `PIXI.settings.TARGET_FPMS * 1000`.
             *
             * @member {number}
             * @default 10
             */
          },
          {
            key: "minFPS",
            get: function get() {
              return 1000 / this._maxElapsedMS;
            },
            set: function set(
              fps // eslint-disable-line require-jsdoc
            ) {
              // Clamp: 0 to TARGET_FPMS
              var minFPMS = Math.min(Math.max(0, fps) / 1000, _settings2.default.TARGET_FPMS);

              this._maxElapsedMS = 1 / minFPMS;
            },
          },
        ]);

        return Ticker;
      })();

      exports.default = Ticker;
      //# sourceMappingURL=Ticker.js.map

      /***/
    },
    /* 499 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      /**
       * Internal class for handling the priority sorting of ticker handlers.
       *
       * @private
       * @class
       * @memberof PIXI.ticker
       */
      var TickerListener = (function () {
        /**
         * Constructor
         *
         * @param {Function} fn - The listener function to be added for one update
         * @param {Function} [context=null] - The listener context
         * @param {number} [priority=0] - The priority for emitting
         * @param {boolean} [once=false] - If the handler should fire once
         */
        function TickerListener(fn) {
          var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          var priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
          var once = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

          _classCallCheck(this, TickerListener);

          /**
           * The handler function to execute.
           * @member {Function}
           */
          this.fn = fn;

          /**
           * The calling to execute.
           * @member {Function}
           */
          this.context = context;

          /**
           * The current priority.
           * @member {number}
           */
          this.priority = priority;

          /**
           * If this should only execute once.
           * @member {boolean}
           */
          this.once = once;

          /**
           * The next item in chain.
           * @member {TickerListener}
           */
          this.next = null;

          /**
           * The previous item in chain.
           * @member {TickerListener}
           */
          this.previous = null;

          /**
           * `true` if this listener has been destroyed already.
           * @member {boolean}
           * @private
           */
          this._destroyed = false;
        }

        /**
         * Simple compare function to figure out if a function and context match.
         *
         * @param {Function} fn - The listener function to be added for one update
         * @param {Function} context - The listener context
         * @return {boolean} `true` if the listener match the arguments
         */

        TickerListener.prototype.match = function match(fn, context) {
          context = context || null;

          return this.fn === fn && this.context === context;
        };

        /**
         * Emit by calling the current function.
         * @param {number} deltaTime - time since the last emit.
         * @return {TickerListener} Next ticker
         */

        TickerListener.prototype.emit = function emit(deltaTime) {
          if (this.fn) {
            if (this.context) {
              this.fn.call(this.context, deltaTime);
            } else {
              this.fn(deltaTime);
            }
          }

          var redirect = this.next;

          if (this.once) {
            this.destroy(true);
          }

          // Soft-destroying should remove
          // the next reference
          if (this._destroyed) {
            this.next = null;
          }

          return redirect;
        };

        /**
         * Connect to the list.
         * @param {TickerListener} previous - Input node, previous listener
         */

        TickerListener.prototype.connect = function connect(previous) {
          this.previous = previous;
          if (previous.next) {
            previous.next.previous = this;
          }
          this.next = previous.next;
          previous.next = this;
        };

        /**
         * Destroy and don't use after this.
         * @param {boolean} [hard = false] `true` to remove the `next` reference, this
         *        is considered a hard destroy. Soft destroy maintains the next reference.
         * @return {TickerListener} The listener to redirect while emitting or removing.
         */

        TickerListener.prototype.destroy = function destroy() {
          var hard = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

          this._destroyed = true;
          this.fn = null;
          this.context = null;

          // Disconnect, hook up next and previous
          if (this.previous) {
            this.previous.next = this.next;
          }

          if (this.next) {
            this.next.previous = this.previous;
          }

          // Redirect to the next item
          var redirect = this.next;

          // Remove references
          this.next = hard ? null : redirect;
          this.previous = null;

          return redirect;
        };

        return TickerListener;
      })();

      exports.default = TickerListener;
      //# sourceMappingURL=TickerListener.js.map

      /***/
    },
    /* 500 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      var _CanvasRenderer = __webpack_require__(359);

      var _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);

      var _const = __webpack_require__(343);

      var _math = __webpack_require__(348);

      var _CanvasTinter = __webpack_require__(364);

      var _CanvasTinter2 = _interopRequireDefault(_CanvasTinter);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var canvasRenderWorldTransform = new _math.Matrix();

      /**
       * @author Mat Groves
       *
       * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/
       * for creating the original PixiJS version!
       * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now
       * share 4 bytes on the vertex buffer
       *
       * Heavily inspired by LibGDX's CanvasSpriteRenderer:
       * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/CanvasSpriteRenderer.java
       */

      /**
       * Renderer dedicated to drawing and batching sprites.
       *
       * @class
       * @private
       * @memberof PIXI
       */

      var CanvasSpriteRenderer = (function () {
        /**
         * @param {PIXI.WebGLRenderer} renderer -The renderer sprite this batch works for.
         */
        function CanvasSpriteRenderer(renderer) {
          _classCallCheck(this, CanvasSpriteRenderer);

          this.renderer = renderer;
        }

        /**
         * Renders the sprite object.
         *
         * @param {PIXI.Sprite} sprite - the sprite to render when using this spritebatch
         */

        CanvasSpriteRenderer.prototype.render = function render(sprite) {
          var texture = sprite._texture;
          var renderer = this.renderer;

          var width = texture._frame.width;
          var height = texture._frame.height;

          var wt = sprite.transform.worldTransform;
          var dx = 0;
          var dy = 0;

          if (texture.orig.width <= 0 || texture.orig.height <= 0 || !texture.baseTexture.source) {
            return;
          }

          renderer.setBlendMode(sprite.blendMode);

          //  Ignore null sources
          if (texture.valid) {
            renderer.context.globalAlpha = sprite.worldAlpha;

            // If smoothingEnabled is supported and we need to change the smoothing property for sprite texture
            var smoothingEnabled = texture.baseTexture.scaleMode === _const.SCALE_MODES.LINEAR;

            if (renderer.smoothProperty && renderer.context[renderer.smoothProperty] !== smoothingEnabled) {
              renderer.context[renderer.smoothProperty] = smoothingEnabled;
            }

            if (texture.trim) {
              dx = texture.trim.width / 2 + texture.trim.x - sprite.anchor.x * texture.orig.width;
              dy = texture.trim.height / 2 + texture.trim.y - sprite.anchor.y * texture.orig.height;
            } else {
              dx = (0.5 - sprite.anchor.x) * texture.orig.width;
              dy = (0.5 - sprite.anchor.y) * texture.orig.height;
            }

            if (texture.rotate) {
              wt.copy(canvasRenderWorldTransform);
              wt = canvasRenderWorldTransform;
              _math.GroupD8.matrixAppendRotationInv(wt, texture.rotate, dx, dy);
              // the anchor has already been applied above, so lets set it to zero
              dx = 0;
              dy = 0;
            }

            dx -= width / 2;
            dy -= height / 2;

            // Allow for pixel rounding
            if (renderer.roundPixels) {
              renderer.context.setTransform(wt.a, wt.b, wt.c, wt.d, (wt.tx * renderer.resolution) | 0, (wt.ty * renderer.resolution) | 0);

              dx = dx | 0;
              dy = dy | 0;
            } else {
              renderer.context.setTransform(wt.a, wt.b, wt.c, wt.d, wt.tx * renderer.resolution, wt.ty * renderer.resolution);
            }

            var resolution = texture.baseTexture.resolution;

            if (sprite.tint !== 0xffffff) {
              if (sprite.cachedTint !== sprite.tint || sprite.tintedTexture.tintId !== sprite._texture._updateID) {
                sprite.cachedTint = sprite.tint;

                // TODO clean up caching - how to clean up the caches?
                sprite.tintedTexture = _CanvasTinter2.default.getTintedTexture(sprite, sprite.tint);
              }

              renderer.context.drawImage(
                sprite.tintedTexture,
                0,
                0,
                width * resolution,
                height * resolution,
                dx * renderer.resolution,
                dy * renderer.resolution,
                width * renderer.resolution,
                height * renderer.resolution
              );
            } else {
              renderer.context.drawImage(
                texture.baseTexture.source,
                texture._frame.x * resolution,
                texture._frame.y * resolution,
                width * resolution,
                height * resolution,
                dx * renderer.resolution,
                dy * renderer.resolution,
                width * renderer.resolution,
                height * renderer.resolution
              );
            }
          }
        };

        /**
         * destroy the sprite object.
         *
         */

        CanvasSpriteRenderer.prototype.destroy = function destroy() {
          this.renderer = null;
        };

        return CanvasSpriteRenderer;
      })();

      exports.default = CanvasSpriteRenderer;

      _CanvasRenderer2.default.registerPlugin("sprite", CanvasSpriteRenderer);
      //# sourceMappingURL=CanvasSpriteRenderer.js.map

      /***/
    },
    /* 501 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      var _const = __webpack_require__(343);

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      /**
       * A set of functions used to handle masking.
       *
       * @class
       * @memberof PIXI
       */
      var CanvasMaskManager = (function () {
        /**
         * @param {PIXI.CanvasRenderer} renderer - The canvas renderer.
         */
        function CanvasMaskManager(renderer) {
          _classCallCheck(this, CanvasMaskManager);

          this.renderer = renderer;
        }

        /**
         * This method adds it to the current stack of masks.
         *
         * @param {object} maskData - the maskData that will be pushed
         */

        CanvasMaskManager.prototype.pushMask = function pushMask(maskData) {
          var renderer = this.renderer;

          renderer.context.save();

          var cacheAlpha = maskData.alpha;
          var transform = maskData.transform.worldTransform;
          var resolution = renderer.resolution;

          renderer.context.setTransform(
            transform.a * resolution,
            transform.b * resolution,
            transform.c * resolution,
            transform.d * resolution,
            transform.tx * resolution,
            transform.ty * resolution
          );

          // TODO suport sprite alpha masks??
          // lots of effort required. If demand is great enough..
          if (!maskData._texture) {
            this.renderGraphicsShape(maskData);
            renderer.context.clip();
          }

          maskData.worldAlpha = cacheAlpha;
        };

        /**
         * Renders a PIXI.Graphics shape.
         *
         * @param {PIXI.Graphics} graphics - The object to render.
         */

        CanvasMaskManager.prototype.renderGraphicsShape = function renderGraphicsShape(graphics) {
          var context = this.renderer.context;
          var len = graphics.graphicsData.length;

          if (len === 0) {
            return;
          }

          context.beginPath();

          for (var i = 0; i < len; i++) {
            var data = graphics.graphicsData[i];
            var shape = data.shape;

            if (data.type === _const.SHAPES.POLY) {
              var points = shape.points;
              var holes = data.holes;
              var outerArea = void 0;
              var innerArea = void 0;

              context.moveTo(points[0], points[1]);

              for (var j = 2; j < points.length; j += 2) {
                context.lineTo(points[j], points[j + 1]);
              }

              // if the first and last point are the same close the path - much neater :)
              if (points[0] === points[points.length - 2] && points[1] === points[points.length - 1]) {
                context.closePath();
              }

              if (holes.length > 0) {
                outerArea = 0;
                for (var _j = 0; _j < points.length; _j += 2) {
                  outerArea += points[_j] * points[_j + 3] - points[_j + 1] * points[_j + 2];
                }

                for (var k = 0; k < holes.length; k++) {
                  points = holes[k].points;

                  innerArea = 0;
                  for (var _j2 = 0; _j2 < points.length; _j2 += 2) {
                    innerArea += points[_j2] * points[_j2 + 3] - points[_j2 + 1] * points[_j2 + 2];
                  }

                  context.moveTo(points[0], points[1]);

                  if (innerArea * outerArea < 0) {
                    for (var _j3 = 2; _j3 < points.length; _j3 += 2) {
                      context.lineTo(points[_j3], points[_j3 + 1]);
                    }
                  } else {
                    for (var _j4 = points.length - 2; _j4 >= 2; _j4 -= 2) {
                      context.lineTo(points[_j4], points[_j4 + 1]);
                    }
                  }
                }
              }
            } else if (data.type === _const.SHAPES.RECT) {
              context.rect(shape.x, shape.y, shape.width, shape.height);
              context.closePath();
            } else if (data.type === _const.SHAPES.CIRC) {
              // TODO - need to be Undefined!
              context.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);
              context.closePath();
            } else if (data.type === _const.SHAPES.ELIP) {
              // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas

              var w = shape.width * 2;
              var h = shape.height * 2;

              var x = shape.x - w / 2;
              var y = shape.y - h / 2;

              var kappa = 0.5522848;
              var ox = (w / 2) * kappa; // control point offset horizontal
              var oy = (h / 2) * kappa; // control point offset vertical
              var xe = x + w; // x-end
              var ye = y + h; // y-end
              var xm = x + w / 2; // x-middle
              var ym = y + h / 2; // y-middle

              context.moveTo(x, ym);
              context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
              context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
              context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
              context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
              context.closePath();
            } else if (data.type === _const.SHAPES.RREC) {
              var rx = shape.x;
              var ry = shape.y;
              var width = shape.width;
              var height = shape.height;
              var radius = shape.radius;

              var maxRadius = (Math.min(width, height) / 2) | 0;

              radius = radius > maxRadius ? maxRadius : radius;

              context.moveTo(rx, ry + radius);
              context.lineTo(rx, ry + height - radius);
              context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);
              context.lineTo(rx + width - radius, ry + height);
              context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);
              context.lineTo(rx + width, ry + radius);
              context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);
              context.lineTo(rx + radius, ry);
              context.quadraticCurveTo(rx, ry, rx, ry + radius);
              context.closePath();
            }
          }
        };

        /**
         * Restores the current drawing context to the state it was before the mask was applied.
         *
         * @param {PIXI.CanvasRenderer} renderer - The renderer context to use.
         */

        CanvasMaskManager.prototype.popMask = function popMask(renderer) {
          renderer.context.restore();
          renderer.invalidateBlendMode();
        };

        /**
         * Destroys this canvas mask manager.
         *
         */

        CanvasMaskManager.prototype.destroy = function destroy() {
          /* empty */
        };

        return CanvasMaskManager;
      })();

      exports.default = CanvasMaskManager;
      //# sourceMappingURL=CanvasMaskManager.js.map

      /***/
    },
    /* 502 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;
      exports.default = mapCanvasBlendModesToPixi;

      var _const = __webpack_require__(343);

      var _canUseNewCanvasBlendModes = __webpack_require__(414);

      var _canUseNewCanvasBlendModes2 = _interopRequireDefault(_canUseNewCanvasBlendModes);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      /**
       * Maps blend combinations to Canvas.
       *
       * @memberof PIXI
       * @function mapCanvasBlendModesToPixi
       * @private
       * @param {string[]} [array=[]] - The array to output into.
       * @return {string[]} Mapped modes.
       */
      function mapCanvasBlendModesToPixi() {
        var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

        if ((0, _canUseNewCanvasBlendModes2.default)()) {
          array[_const.BLEND_MODES.NORMAL] = "source-over";
          array[_const.BLEND_MODES.ADD] = "lighter"; // IS THIS OK???
          array[_const.BLEND_MODES.MULTIPLY] = "multiply";
          array[_const.BLEND_MODES.SCREEN] = "screen";
          array[_const.BLEND_MODES.OVERLAY] = "overlay";
          array[_const.BLEND_MODES.DARKEN] = "darken";
          array[_const.BLEND_MODES.LIGHTEN] = "lighten";
          array[_const.BLEND_MODES.COLOR_DODGE] = "color-dodge";
          array[_const.BLEND_MODES.COLOR_BURN] = "color-burn";
          array[_const.BLEND_MODES.HARD_LIGHT] = "hard-light";
          array[_const.BLEND_MODES.SOFT_LIGHT] = "soft-light";
          array[_const.BLEND_MODES.DIFFERENCE] = "difference";
          array[_const.BLEND_MODES.EXCLUSION] = "exclusion";
          array[_const.BLEND_MODES.HUE] = "hue";
          array[_const.BLEND_MODES.SATURATION] = "saturate";
          array[_const.BLEND_MODES.COLOR] = "color";
          array[_const.BLEND_MODES.LUMINOSITY] = "luminosity";
        } else {
          // this means that the browser does not support the cool new blend modes in canvas 'cough' ie 'cough'
          array[_const.BLEND_MODES.NORMAL] = "source-over";
          array[_const.BLEND_MODES.ADD] = "lighter"; // IS THIS OK???
          array[_const.BLEND_MODES.MULTIPLY] = "source-over";
          array[_const.BLEND_MODES.SCREEN] = "source-over";
          array[_const.BLEND_MODES.OVERLAY] = "source-over";
          array[_const.BLEND_MODES.DARKEN] = "source-over";
          array[_const.BLEND_MODES.LIGHTEN] = "source-over";
          array[_const.BLEND_MODES.COLOR_DODGE] = "source-over";
          array[_const.BLEND_MODES.COLOR_BURN] = "source-over";
          array[_const.BLEND_MODES.HARD_LIGHT] = "source-over";
          array[_const.BLEND_MODES.SOFT_LIGHT] = "source-over";
          array[_const.BLEND_MODES.DIFFERENCE] = "source-over";
          array[_const.BLEND_MODES.EXCLUSION] = "source-over";
          array[_const.BLEND_MODES.HUE] = "source-over";
          array[_const.BLEND_MODES.SATURATION] = "source-over";
          array[_const.BLEND_MODES.COLOR] = "source-over";
          array[_const.BLEND_MODES.LUMINOSITY] = "source-over";
        }
        // not-premultiplied, only for webgl
        array[_const.BLEND_MODES.NORMAL_NPM] = array[_const.BLEND_MODES.NORMAL];
        array[_const.BLEND_MODES.ADD_NPM] = array[_const.BLEND_MODES.ADD];
        array[_const.BLEND_MODES.SCREEN_NPM] = array[_const.BLEND_MODES.SCREEN];

        return array;
      }
      //# sourceMappingURL=mapCanvasBlendModesToPixi.js.map

      /***/
    },
    /* 503 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      var _ObjectRenderer2 = __webpack_require__(365);

      var _ObjectRenderer3 = _interopRequireDefault(_ObjectRenderer2);

      var _WebGLRenderer = __webpack_require__(366);

      var _WebGLRenderer2 = _interopRequireDefault(_WebGLRenderer);

      var _createIndicesForQuads = __webpack_require__(385);

      var _createIndicesForQuads2 = _interopRequireDefault(_createIndicesForQuads);

      var _generateMultiTextureShader = __webpack_require__(515);

      var _generateMultiTextureShader2 = _interopRequireDefault(_generateMultiTextureShader);

      var _checkMaxIfStatmentsInShader = __webpack_require__(516);

      var _checkMaxIfStatmentsInShader2 = _interopRequireDefault(_checkMaxIfStatmentsInShader);

      var _BatchBuffer = __webpack_require__(517);

      var _BatchBuffer2 = _interopRequireDefault(_BatchBuffer);

      var _settings = __webpack_require__(346);

      var _settings2 = _interopRequireDefault(_settings);

      var _utils = __webpack_require__(345);

      var _pixiGlCore = __webpack_require__(350);

      var _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);

      var _bitTwiddle = __webpack_require__(382);

      var _bitTwiddle2 = _interopRequireDefault(_bitTwiddle);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: { value: subClass, enumerable: false, writable: true, configurable: true },
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass);
      }

      var TICK = 0;
      var TEXTURE_TICK = 0;

      /**
       * Renderer dedicated to drawing and batching sprites.
       *
       * @class
       * @private
       * @memberof PIXI
       * @extends PIXI.ObjectRenderer
       */

      var SpriteRenderer = (function (_ObjectRenderer) {
        _inherits(SpriteRenderer, _ObjectRenderer);

        /**
         * @param {PIXI.WebGLRenderer} renderer - The renderer this sprite batch works for.
         */
        function SpriteRenderer(renderer) {
          _classCallCheck(this, SpriteRenderer);

          /**
           * Number of values sent in the vertex buffer.
           * aVertexPosition(2), aTextureCoord(1), aColor(1), aTextureId(1) = 5
           *
           * @member {number}
           */
          var _this = _possibleConstructorReturn(this, _ObjectRenderer.call(this, renderer));

          _this.vertSize = 5;

          /**
           * The size of the vertex information in bytes.
           *
           * @member {number}
           */
          _this.vertByteSize = _this.vertSize * 4;

          /**
           * The number of images in the SpriteRenderer before it flushes.
           *
           * @member {number}
           */
          _this.size = _settings2.default.SPRITE_BATCH_SIZE; // 2000 is a nice balance between mobile / desktop

          // the total number of bytes in our batch
          // let numVerts = this.size * 4 * this.vertByteSize;

          _this.buffers = [];
          for (var i = 1; i <= _bitTwiddle2.default.nextPow2(_this.size); i *= 2) {
            _this.buffers.push(new _BatchBuffer2.default(i * 4 * _this.vertByteSize));
          }

          /**
           * Holds the indices of the geometry (quads) to draw
           *
           * @member {Uint16Array}
           */
          _this.indices = (0, _createIndicesForQuads2.default)(_this.size);

          /**
           * The default shaders that is used if a sprite doesn't have a more specific one.
           * there is a shader for each number of textures that can be rendererd.
           * These shaders will also be generated on the fly as required.
           * @member {PIXI.Shader[]}
           */
          _this.shader = null;

          _this.currentIndex = 0;
          _this.groups = [];

          for (var k = 0; k < _this.size; k++) {
            _this.groups[k] = { textures: [], textureCount: 0, ids: [], size: 0, start: 0, blend: 0 };
          }

          _this.sprites = [];

          _this.vertexBuffers = [];
          _this.vaos = [];

          _this.vaoMax = 2;
          _this.vertexCount = 0;

          _this.renderer.on("prerender", _this.onPrerender, _this);
          return _this;
        }

        /**
         * Sets up the renderer context and necessary buffers.
         *
         * @private
         */

        SpriteRenderer.prototype.onContextChange = function onContextChange() {
          var gl = this.renderer.gl;

          if (this.renderer.legacy) {
            this.MAX_TEXTURES = 1;
          } else {
            // step 1: first check max textures the GPU can handle.
            this.MAX_TEXTURES = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), _settings2.default.SPRITE_MAX_TEXTURES);

            // step 2: check the maximum number of if statements the shader can have too..
            this.MAX_TEXTURES = (0, _checkMaxIfStatmentsInShader2.default)(this.MAX_TEXTURES, gl);
          }

          this.shader = (0, _generateMultiTextureShader2.default)(gl, this.MAX_TEXTURES);

          // create a couple of buffers
          this.indexBuffer = _pixiGlCore2.default.GLBuffer.createIndexBuffer(gl, this.indices, gl.STATIC_DRAW);

          // we use the second shader as the first one depending on your browser may omit aTextureId
          // as it is not used by the shader so is optimized out.

          this.renderer.bindVao(null);

          var attrs = this.shader.attributes;

          for (var i = 0; i < this.vaoMax; i++) {
            /* eslint-disable max-len */
            var vertexBuffer = (this.vertexBuffers[i] = _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, null, gl.STREAM_DRAW));
            /* eslint-enable max-len */

            // build the vao object that will render..
            var vao = this.renderer
              .createVao()
              .addIndex(this.indexBuffer)
              .addAttribute(vertexBuffer, attrs.aVertexPosition, gl.FLOAT, false, this.vertByteSize, 0)
              .addAttribute(vertexBuffer, attrs.aTextureCoord, gl.UNSIGNED_SHORT, true, this.vertByteSize, 2 * 4)
              .addAttribute(vertexBuffer, attrs.aColor, gl.UNSIGNED_BYTE, true, this.vertByteSize, 3 * 4);

            if (attrs.aTextureId) {
              vao.addAttribute(vertexBuffer, attrs.aTextureId, gl.FLOAT, false, this.vertByteSize, 4 * 4);
            }

            this.vaos[i] = vao;
          }

          this.vao = this.vaos[0];
          this.currentBlendMode = 99999;

          this.boundTextures = new Array(this.MAX_TEXTURES);
        };

        /**
         * Called before the renderer starts rendering.
         *
         */

        SpriteRenderer.prototype.onPrerender = function onPrerender() {
          this.vertexCount = 0;
        };

        /**
         * Renders the sprite object.
         *
         * @param {PIXI.Sprite} sprite - the sprite to render when using this spritebatch
         */

        SpriteRenderer.prototype.render = function render(sprite) {
          // TODO set blend modes..
          // check texture..
          if (this.currentIndex >= this.size) {
            this.flush();
          }

          // get the uvs for the texture

          // if the uvs have not updated then no point rendering just yet!
          if (!sprite._texture._uvs) {
            return;
          }

          // push a texture.
          // increment the batchsize
          this.sprites[this.currentIndex++] = sprite;
        };

        /**
         * Renders the content and empties the current batch.
         *
         */

        SpriteRenderer.prototype.flush = function flush() {
          if (this.currentIndex === 0) {
            return;
          }

          var gl = this.renderer.gl;
          var MAX_TEXTURES = this.MAX_TEXTURES;

          var np2 = _bitTwiddle2.default.nextPow2(this.currentIndex);
          var log2 = _bitTwiddle2.default.log2(np2);
          var buffer = this.buffers[log2];

          var sprites = this.sprites;
          var groups = this.groups;

          var float32View = buffer.float32View;
          var uint32View = buffer.uint32View;

          var boundTextures = this.boundTextures;
          var rendererBoundTextures = this.renderer.boundTextures;
          var touch = this.renderer.textureGC.count;

          var index = 0;
          var nextTexture = void 0;
          var currentTexture = void 0;
          var groupCount = 1;
          var textureCount = 0;
          var currentGroup = groups[0];
          var vertexData = void 0;
          var uvs = void 0;
          var blendMode = _utils.premultiplyBlendMode[sprites[0]._texture.baseTexture.premultipliedAlpha ? 1 : 0][sprites[0].blendMode];

          currentGroup.textureCount = 0;
          currentGroup.start = 0;
          currentGroup.blend = blendMode;

          TICK++;

          var i = void 0;

          // copy textures..
          for (i = 0; i < MAX_TEXTURES; ++i) {
            var bt = rendererBoundTextures[i];

            if (bt._enabled === TICK) {
              boundTextures[i] = this.renderer.emptyTextures[i];
              continue;
            }

            boundTextures[i] = bt;
            bt._virtalBoundId = i;
            bt._enabled = TICK;
          }
          TICK++;

          for (i = 0; i < this.currentIndex; ++i) {
            // upload the sprite elemetns...
            // they have all ready been calculated so we just need to push them into the buffer.
            var sprite = sprites[i];

            sprites[i] = null;

            nextTexture = sprite._texture.baseTexture;

            var spriteBlendMode = _utils.premultiplyBlendMode[Number(nextTexture.premultipliedAlpha)][sprite.blendMode];

            if (blendMode !== spriteBlendMode) {
              // finish a group..
              blendMode = spriteBlendMode;

              // force the batch to break!
              currentTexture = null;
              textureCount = MAX_TEXTURES;
              TICK++;
            }

            if (currentTexture !== nextTexture) {
              currentTexture = nextTexture;

              if (nextTexture._enabled !== TICK) {
                if (textureCount === MAX_TEXTURES) {
                  TICK++;

                  currentGroup.size = i - currentGroup.start;

                  textureCount = 0;

                  currentGroup = groups[groupCount++];
                  currentGroup.blend = blendMode;
                  currentGroup.textureCount = 0;
                  currentGroup.start = i;
                }

                nextTexture.touched = touch;

                if (nextTexture._virtalBoundId === -1) {
                  for (var j = 0; j < MAX_TEXTURES; ++j) {
                    var tIndex = (j + TEXTURE_TICK) % MAX_TEXTURES;

                    var t = boundTextures[tIndex];

                    if (t._enabled !== TICK) {
                      TEXTURE_TICK++;

                      t._virtalBoundId = -1;

                      nextTexture._virtalBoundId = tIndex;

                      boundTextures[tIndex] = nextTexture;
                      break;
                    }
                  }
                }

                nextTexture._enabled = TICK;

                currentGroup.textureCount++;
                currentGroup.ids[textureCount] = nextTexture._virtalBoundId;
                currentGroup.textures[textureCount++] = nextTexture;
              }
            }

            vertexData = sprite.vertexData;

            // TODO this sum does not need to be set each frame..
            uvs = sprite._texture._uvs.uvsUint32;

            if (this.renderer.roundPixels) {
              var resolution = this.renderer.resolution;

              // xy
              float32View[index] = ((vertexData[0] * resolution) | 0) / resolution;
              float32View[index + 1] = ((vertexData[1] * resolution) | 0) / resolution;

              // xy
              float32View[index + 5] = ((vertexData[2] * resolution) | 0) / resolution;
              float32View[index + 6] = ((vertexData[3] * resolution) | 0) / resolution;

              // xy
              float32View[index + 10] = ((vertexData[4] * resolution) | 0) / resolution;
              float32View[index + 11] = ((vertexData[5] * resolution) | 0) / resolution;

              // xy
              float32View[index + 15] = ((vertexData[6] * resolution) | 0) / resolution;
              float32View[index + 16] = ((vertexData[7] * resolution) | 0) / resolution;
            } else {
              // xy
              float32View[index] = vertexData[0];
              float32View[index + 1] = vertexData[1];

              // xy
              float32View[index + 5] = vertexData[2];
              float32View[index + 6] = vertexData[3];

              // xy
              float32View[index + 10] = vertexData[4];
              float32View[index + 11] = vertexData[5];

              // xy
              float32View[index + 15] = vertexData[6];
              float32View[index + 16] = vertexData[7];
            }

            uint32View[index + 2] = uvs[0];
            uint32View[index + 7] = uvs[1];
            uint32View[index + 12] = uvs[2];
            uint32View[index + 17] = uvs[3];
            /* eslint-disable max-len */
            var alpha = Math.min(sprite.worldAlpha, 1.0);
            // we dont call extra function if alpha is 1.0, that's faster
            var argb =
              alpha < 1.0 && nextTexture.premultipliedAlpha
                ? (0, _utils.premultiplyTint)(sprite._tintRGB, alpha)
                : sprite._tintRGB + ((alpha * 255) << 24);

            uint32View[index + 3] = uint32View[index + 8] = uint32View[index + 13] = uint32View[index + 18] = argb;
            float32View[index + 4] = float32View[index + 9] = float32View[index + 14] = float32View[index + 19] = nextTexture._virtalBoundId;
            /* eslint-enable max-len */

            index += 20;
          }

          currentGroup.size = i - currentGroup.start;

          if (!_settings2.default.CAN_UPLOAD_SAME_BUFFER) {
            // this is still needed for IOS performance..
            // it really does not like uploading to the same buffer in a single frame!
            if (this.vaoMax <= this.vertexCount) {
              this.vaoMax++;

              var attrs = this.shader.attributes;

              /* eslint-disable max-len */
              var vertexBuffer = (this.vertexBuffers[this.vertexCount] = _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, null, gl.STREAM_DRAW));
              /* eslint-enable max-len */

              // build the vao object that will render..
              var vao = this.renderer
                .createVao()
                .addIndex(this.indexBuffer)
                .addAttribute(vertexBuffer, attrs.aVertexPosition, gl.FLOAT, false, this.vertByteSize, 0)
                .addAttribute(vertexBuffer, attrs.aTextureCoord, gl.UNSIGNED_SHORT, true, this.vertByteSize, 2 * 4)
                .addAttribute(vertexBuffer, attrs.aColor, gl.UNSIGNED_BYTE, true, this.vertByteSize, 3 * 4);

              if (attrs.aTextureId) {
                vao.addAttribute(vertexBuffer, attrs.aTextureId, gl.FLOAT, false, this.vertByteSize, 4 * 4);
              }

              this.vaos[this.vertexCount] = vao;
            }

            this.renderer.bindVao(this.vaos[this.vertexCount]);

            this.vertexBuffers[this.vertexCount].upload(buffer.vertices, 0, false);

            this.vertexCount++;
          } else {
            // lets use the faster option, always use buffer number 0
            this.vertexBuffers[this.vertexCount].upload(buffer.vertices, 0, true);
          }

          for (i = 0; i < MAX_TEXTURES; ++i) {
            rendererBoundTextures[i]._virtalBoundId = -1;
          }

          // render the groups..
          for (i = 0; i < groupCount; ++i) {
            var group = groups[i];
            var groupTextureCount = group.textureCount;

            for (var _j = 0; _j < groupTextureCount; _j++) {
              currentTexture = group.textures[_j];

              // reset virtual ids..
              // lets do a quick check..
              if (rendererBoundTextures[group.ids[_j]] !== currentTexture) {
                this.renderer.bindTexture(currentTexture, group.ids[_j], true);
              }

              // reset the virtualId..
              currentTexture._virtalBoundId = -1;
            }

            // set the blend mode..
            this.renderer.state.setBlendMode(group.blend);

            gl.drawElements(gl.TRIANGLES, group.size * 6, gl.UNSIGNED_SHORT, group.start * 6 * 2);
          }

          // reset elements for the next flush
          this.currentIndex = 0;
        };

        /**
         * Starts a new sprite batch.
         */

        SpriteRenderer.prototype.start = function start() {
          this.renderer.bindShader(this.shader);

          if (_settings2.default.CAN_UPLOAD_SAME_BUFFER) {
            // bind buffer #0, we don't need others
            this.renderer.bindVao(this.vaos[this.vertexCount]);

            this.vertexBuffers[this.vertexCount].bind();
          }
        };

        /**
         * Stops and flushes the current batch.
         *
         */

        SpriteRenderer.prototype.stop = function stop() {
          this.flush();
        };

        /**
         * Destroys the SpriteRenderer.
         *
         */

        SpriteRenderer.prototype.destroy = function destroy() {
          for (var i = 0; i < this.vaoMax; i++) {
            if (this.vertexBuffers[i]) {
              this.vertexBuffers[i].destroy();
            }
            if (this.vaos[i]) {
              this.vaos[i].destroy();
            }
          }

          if (this.indexBuffer) {
            this.indexBuffer.destroy();
          }

          this.renderer.off("prerender", this.onPrerender, this);

          _ObjectRenderer.prototype.destroy.call(this);

          if (this.shader) {
            this.shader.destroy();
            this.shader = null;
          }

          this.vertexBuffers = null;
          this.vaos = null;
          this.indexBuffer = null;
          this.indices = null;

          this.sprites = null;

          for (var _i = 0; _i < this.buffers.length; ++_i) {
            this.buffers[_i].destroy();
          }
        };

        return SpriteRenderer;
      })(_ObjectRenderer3.default);

      exports.default = SpriteRenderer;

      _WebGLRenderer2.default.registerPlugin("sprite", SpriteRenderer);
      //# sourceMappingURL=SpriteRenderer.js.map

      /***/
    },
    /* 504 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      var _WebGLManager2 = __webpack_require__(360);

      var _WebGLManager3 = _interopRequireDefault(_WebGLManager2);

      var _SpriteMaskFilter = __webpack_require__(415);

      var _SpriteMaskFilter2 = _interopRequireDefault(_SpriteMaskFilter);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: { value: subClass, enumerable: false, writable: true, configurable: true },
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass);
      }

      /**
       * @class
       * @extends PIXI.WebGLManager
       * @memberof PIXI
       */
      var MaskManager = (function (_WebGLManager) {
        _inherits(MaskManager, _WebGLManager);

        /**
         * @param {PIXI.WebGLRenderer} renderer - The renderer this manager works for.
         */
        function MaskManager(renderer) {
          _classCallCheck(this, MaskManager);

          // TODO - we don't need both!
          var _this = _possibleConstructorReturn(this, _WebGLManager.call(this, renderer));

          _this.scissor = false;
          _this.scissorData = null;
          _this.scissorRenderTarget = null;

          _this.enableScissor = true;

          _this.alphaMaskPool = [];
          _this.alphaMaskIndex = 0;
          return _this;
        }

        /**
         * Applies the Mask and adds it to the current filter stack.
         *
         * @param {PIXI.DisplayObject} target - Display Object to push the mask to
         * @param {PIXI.Sprite|PIXI.Graphics} maskData - The masking data.
         */

        MaskManager.prototype.pushMask = function pushMask(target, maskData) {
          // TODO the root check means scissor rect will not
          // be used on render textures more info here:
          // https://github.com/pixijs/pixi.js/pull/3545

          if (maskData.texture) {
            this.pushSpriteMask(target, maskData);
          } else if (
            this.enableScissor &&
            !this.scissor &&
            this.renderer._activeRenderTarget.root &&
            !this.renderer.stencilManager.stencilMaskStack.length &&
            maskData.isFastRect()
          ) {
            var matrix = maskData.worldTransform;

            var rot = Math.atan2(matrix.b, matrix.a);

            // use the nearest degree!
            rot = Math.round(rot * (180 / Math.PI));

            if (rot % 90) {
              this.pushStencilMask(maskData);
            } else {
              this.pushScissorMask(target, maskData);
            }
          } else {
            this.pushStencilMask(maskData);
          }
        };

        /**
         * Removes the last mask from the mask stack and doesn't return it.
         *
         * @param {PIXI.DisplayObject} target - Display Object to pop the mask from
         * @param {PIXI.Sprite|PIXI.Graphics} maskData - The masking data.
         */

        MaskManager.prototype.popMask = function popMask(target, maskData) {
          if (maskData.texture) {
            this.popSpriteMask(target, maskData);
          } else if (this.enableScissor && !this.renderer.stencilManager.stencilMaskStack.length) {
            this.popScissorMask(target, maskData);
          } else {
            this.popStencilMask(target, maskData);
          }
        };

        /**
         * Applies the Mask and adds it to the current filter stack.
         *
         * @param {PIXI.RenderTarget} target - Display Object to push the sprite mask to
         * @param {PIXI.Sprite} maskData - Sprite to be used as the mask
         */

        MaskManager.prototype.pushSpriteMask = function pushSpriteMask(target, maskData) {
          var alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];

          if (!alphaMaskFilter) {
            alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new _SpriteMaskFilter2.default(maskData)];
          }

          alphaMaskFilter[0].resolution = this.renderer.resolution;
          alphaMaskFilter[0].maskSprite = maskData;

          var stashFilterArea = target.filterArea;

          target.filterArea = maskData.getBounds(true);
          this.renderer.filterManager.pushFilter(target, alphaMaskFilter);
          target.filterArea = stashFilterArea;

          this.alphaMaskIndex++;
        };

        /**
         * Removes the last filter from the filter stack and doesn't return it.
         *
         */

        MaskManager.prototype.popSpriteMask = function popSpriteMask() {
          this.renderer.filterManager.popFilter();
          this.alphaMaskIndex--;
        };

        /**
         * Applies the Mask and adds it to the current filter stack.
         *
         * @param {PIXI.Sprite|PIXI.Graphics} maskData - The masking data.
         */

        MaskManager.prototype.pushStencilMask = function pushStencilMask(maskData) {
          this.renderer.currentRenderer.stop();
          this.renderer.stencilManager.pushStencil(maskData);
        };

        /**
         * Removes the last filter from the filter stack and doesn't return it.
         *
         */

        MaskManager.prototype.popStencilMask = function popStencilMask() {
          this.renderer.currentRenderer.stop();
          this.renderer.stencilManager.popStencil();
        };

        /**
         *
         * @param {PIXI.DisplayObject} target - Display Object to push the mask to
         * @param {PIXI.Graphics} maskData - The masking data.
         */

        MaskManager.prototype.pushScissorMask = function pushScissorMask(target, maskData) {
          maskData.renderable = true;

          var renderTarget = this.renderer._activeRenderTarget;

          var bounds = maskData.getBounds();

          bounds.fit(renderTarget.size);
          maskData.renderable = false;

          this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST);

          var resolution = this.renderer.resolution;

          this.renderer.gl.scissor(
            bounds.x * resolution,
            (renderTarget.root ? renderTarget.size.height - bounds.y - bounds.height : bounds.y) * resolution,
            bounds.width * resolution,
            bounds.height * resolution
          );

          this.scissorRenderTarget = renderTarget;
          this.scissorData = maskData;
          this.scissor = true;
        };

        /**
         *
         *
         */

        MaskManager.prototype.popScissorMask = function popScissorMask() {
          this.scissorRenderTarget = null;
          this.scissorData = null;
          this.scissor = false;

          // must be scissor!
          var gl = this.renderer.gl;

          gl.disable(gl.SCISSOR_TEST);
        };

        return MaskManager;
      })(_WebGLManager3.default);

      exports.default = MaskManager;
      //# sourceMappingURL=MaskManager.js.map

      /***/
    },
    /* 505 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;
      exports.default = extractUniformsFromSrc;

      var _pixiGlCore = __webpack_require__(350);

      var _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      var defaultValue = _pixiGlCore2.default.shader.defaultValue;

      function extractUniformsFromSrc(vertexSrc, fragmentSrc, mask) {
        var vertUniforms = extractUniformsFromString(vertexSrc, mask);
        var fragUniforms = extractUniformsFromString(fragmentSrc, mask);

        return Object.assign(vertUniforms, fragUniforms);
      }

      function extractUniformsFromString(string) {
        var maskRegex = new RegExp("^(projectionMatrix|uSampler|filterArea|filterClamp)$");

        var uniforms = {};
        var nameSplit = void 0;

        // clean the lines a little - remove extra spaces / tabs etc
        // then split along ';'
        var lines = string.replace(/\s+/g, " ").split(/\s*;\s*/);

        // loop through..
        for (var i = 0; i < lines.length; i++) {
          var line = lines[i].trim();

          if (line.indexOf("uniform") > -1) {
            var splitLine = line.split(" ");
            var type = splitLine[1];

            var name = splitLine[2];
            var size = 1;

            if (name.indexOf("[") > -1) {
              // array!
              nameSplit = name.split(/\[|]/);
              name = nameSplit[0];
              size *= Number(nameSplit[1]);
            }

            if (!name.match(maskRegex)) {
              uniforms[name] = {
                value: defaultValue(type, size),
                name: name,
                type: type,
              };
            }
          }
        }

        return uniforms;
      }
      //# sourceMappingURL=extractUniformsFromSrc.js.map

      /***/
    },
    /* 506 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      var _WebGLManager2 = __webpack_require__(360);

      var _WebGLManager3 = _interopRequireDefault(_WebGLManager2);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: { value: subClass, enumerable: false, writable: true, configurable: true },
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass);
      }

      /**
       * @class
       * @extends PIXI.WebGLManager
       * @memberof PIXI
       */
      var StencilManager = (function (_WebGLManager) {
        _inherits(StencilManager, _WebGLManager);

        /**
         * @param {PIXI.WebGLRenderer} renderer - The renderer this manager works for.
         */
        function StencilManager(renderer) {
          _classCallCheck(this, StencilManager);

          var _this = _possibleConstructorReturn(this, _WebGLManager.call(this, renderer));

          _this.stencilMaskStack = null;
          return _this;
        }

        /**
         * Changes the mask stack that is used by this manager.
         *
         * @param {PIXI.Graphics[]} stencilMaskStack - The mask stack
         */

        StencilManager.prototype.setMaskStack = function setMaskStack(stencilMaskStack) {
          this.stencilMaskStack = stencilMaskStack;

          var gl = this.renderer.gl;

          if (stencilMaskStack.length === 0) {
            gl.disable(gl.STENCIL_TEST);
          } else {
            gl.enable(gl.STENCIL_TEST);
          }
        };

        /**
         * Applies the Mask and adds it to the current stencil stack. @alvin
         *
         * @param {PIXI.Graphics} graphics - The mask
         */

        StencilManager.prototype.pushStencil = function pushStencil(graphics) {
          this.renderer.setObjectRenderer(this.renderer.plugins.graphics);

          this.renderer._activeRenderTarget.attachStencilBuffer();

          var gl = this.renderer.gl;
          var prevMaskCount = this.stencilMaskStack.length;

          if (prevMaskCount === 0) {
            gl.enable(gl.STENCIL_TEST);
          }

          this.stencilMaskStack.push(graphics);

          // Increment the reference stencil value where the new mask overlaps with the old ones.
          gl.colorMask(false, false, false, false);
          gl.stencilFunc(gl.EQUAL, prevMaskCount, this._getBitwiseMask());
          gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
          this.renderer.plugins.graphics.render(graphics);

          this._useCurrent();
        };

        /**
         * Removes the last mask from the stencil stack. @alvin
         */

        StencilManager.prototype.popStencil = function popStencil() {
          this.renderer.setObjectRenderer(this.renderer.plugins.graphics);

          var gl = this.renderer.gl;
          var graphics = this.stencilMaskStack.pop();

          if (this.stencilMaskStack.length === 0) {
            // the stack is empty!
            gl.disable(gl.STENCIL_TEST);
            gl.clear(gl.STENCIL_BUFFER_BIT);
            gl.clearStencil(0);
          } else {
            // Decrement the reference stencil value where the popped mask overlaps with the other ones
            gl.colorMask(false, false, false, false);
            gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
            this.renderer.plugins.graphics.render(graphics);

            this._useCurrent();
          }
        };

        /**
         * Setup renderer to use the current stencil data.
         */

        StencilManager.prototype._useCurrent = function _useCurrent() {
          var gl = this.renderer.gl;

          gl.colorMask(true, true, true, true);
          gl.stencilFunc(gl.EQUAL, this.stencilMaskStack.length, this._getBitwiseMask());
          gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
        };

        /**
         * Fill 1s equal to the number of acitve stencil masks.
         *
         * @return {number} The bitwise mask.
         */

        StencilManager.prototype._getBitwiseMask = function _getBitwiseMask() {
          return (1 << this.stencilMaskStack.length) - 1;
        };

        /**
         * Destroys the mask stack.
         *
         */

        StencilManager.prototype.destroy = function destroy() {
          _WebGLManager3.default.prototype.destroy.call(this);

          this.stencilMaskStack.stencilStack = null;
        };

        return StencilManager;
      })(_WebGLManager3.default);

      exports.default = StencilManager;
      //# sourceMappingURL=StencilManager.js.map

      /***/
    },
    /* 507 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      var _WebGLManager2 = __webpack_require__(360);

      var _WebGLManager3 = _interopRequireDefault(_WebGLManager2);

      var _RenderTarget = __webpack_require__(367);

      var _RenderTarget2 = _interopRequireDefault(_RenderTarget);

      var _Quad = __webpack_require__(418);

      var _Quad2 = _interopRequireDefault(_Quad);

      var _math = __webpack_require__(348);

      var _Shader = __webpack_require__(361);

      var _Shader2 = _interopRequireDefault(_Shader);

      var _filterTransforms = __webpack_require__(508);

      var filterTransforms = _interopRequireWildcard(_filterTransforms);

      var _bitTwiddle = __webpack_require__(382);

      var _bitTwiddle2 = _interopRequireDefault(_bitTwiddle);

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};
          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }
          newObj.default = obj;
          return newObj;
        }
      }

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: { value: subClass, enumerable: false, writable: true, configurable: true },
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass);
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      /**
       * @ignore
       * @class
       */
      var FilterState = (function () {
        /**
         *
         */
        function FilterState() {
          _classCallCheck(this, FilterState);

          this.renderTarget = null;
          this.target = null;
          this.resolution = 1;

          // those three objects are used only for root
          // re-assigned for everything else
          this.sourceFrame = new _math.Rectangle();
          this.destinationFrame = new _math.Rectangle();
          this.filters = [];
        }

        /**
         * clears the state
         */

        FilterState.prototype.clear = function clear() {
          this.filters = null;
          this.target = null;
          this.renderTarget = null;
        };

        return FilterState;
      })();

      var screenKey = "screen";

      /**
       * @class
       * @memberof PIXI
       * @extends PIXI.WebGLManager
       */

      var FilterManager = (function (_WebGLManager) {
        _inherits(FilterManager, _WebGLManager);

        /**
         * @param {PIXI.WebGLRenderer} renderer - The renderer this manager works for.
         */
        function FilterManager(renderer) {
          _classCallCheck(this, FilterManager);

          var _this = _possibleConstructorReturn(this, _WebGLManager.call(this, renderer));

          _this.gl = _this.renderer.gl;
          // know about sprites!
          _this.quad = new _Quad2.default(_this.gl, renderer.state.attribState);

          _this.shaderCache = {};
          // todo add default!
          _this.pool = {};

          _this.filterData = null;

          _this.managedFilters = [];

          _this.renderer.on("prerender", _this.onPrerender, _this);

          _this._screenWidth = renderer.view.width;
          _this._screenHeight = renderer.view.height;
          return _this;
        }

        /**
         * Adds a new filter to the manager.
         *
         * @param {PIXI.DisplayObject} target - The target of the filter to render.
         * @param {PIXI.Filter[]} filters - The filters to apply.
         */

        FilterManager.prototype.pushFilter = function pushFilter(target, filters) {
          var renderer = this.renderer;

          var filterData = this.filterData;

          if (!filterData) {
            filterData = this.renderer._activeRenderTarget.filterStack;

            // add new stack
            var filterState = new FilterState();

            filterState.sourceFrame = filterState.destinationFrame = this.renderer._activeRenderTarget.size;
            filterState.renderTarget = renderer._activeRenderTarget;

            this.renderer._activeRenderTarget.filterData = filterData = {
              index: 0,
              stack: [filterState],
            };

            this.filterData = filterData;
          }

          // get the current filter state..
          var currentState = filterData.stack[++filterData.index];
          var renderTargetFrame = filterData.stack[0].destinationFrame;

          if (!currentState) {
            currentState = filterData.stack[filterData.index] = new FilterState();
          }

          var fullScreen =
            target.filterArea &&
            target.filterArea.x === 0 &&
            target.filterArea.y === 0 &&
            target.filterArea.width === renderer.screen.width &&
            target.filterArea.height === renderer.screen.height;

          // for now we go off the filter of the first resolution..
          var resolution = filters[0].resolution;
          var padding = filters[0].padding | 0;
          var targetBounds = fullScreen ? renderer.screen : target.filterArea || target.getBounds(true);
          var sourceFrame = currentState.sourceFrame;
          var destinationFrame = currentState.destinationFrame;

          sourceFrame.x = ((targetBounds.x * resolution) | 0) / resolution;
          sourceFrame.y = ((targetBounds.y * resolution) | 0) / resolution;
          sourceFrame.width = ((targetBounds.width * resolution) | 0) / resolution;
          sourceFrame.height = ((targetBounds.height * resolution) | 0) / resolution;

          if (!fullScreen) {
            if (filterData.stack[0].renderTarget.transform) {
              //
              // TODO we should fit the rect around the transform..
            } else if (filters[0].autoFit) {
              sourceFrame.fit(renderTargetFrame);
            }

            // lets apply the padding After we fit the element to the screen.
            // this should stop the strange side effects that can occur when cropping to the edges
            sourceFrame.pad(padding);
          }

          destinationFrame.width = sourceFrame.width;
          destinationFrame.height = sourceFrame.height;

          // lets play the padding after we fit the element to the screen.
          // this should stop the strange side effects that can occur when cropping to the edges

          var renderTarget = this.getPotRenderTarget(renderer.gl, sourceFrame.width, sourceFrame.height, resolution);

          currentState.target = target;
          currentState.filters = filters;
          currentState.resolution = resolution;
          currentState.renderTarget = renderTarget;

          // bind the render target to draw the shape in the top corner..

          renderTarget.setFrame(destinationFrame, sourceFrame);

          // bind the render target
          renderer.bindRenderTarget(renderTarget);
          renderTarget.clear();
        };

        /**
         * Pops off the filter and applies it.
         *
         */

        FilterManager.prototype.popFilter = function popFilter() {
          var filterData = this.filterData;

          var lastState = filterData.stack[filterData.index - 1];
          var currentState = filterData.stack[filterData.index];

          this.quad.map(currentState.renderTarget.size, currentState.sourceFrame).upload();

          var filters = currentState.filters;

          if (filters.length === 1) {
            filters[0].apply(this, currentState.renderTarget, lastState.renderTarget, false, currentState);
            this.freePotRenderTarget(currentState.renderTarget);
          } else {
            var flip = currentState.renderTarget;
            var flop = this.getPotRenderTarget(
              this.renderer.gl,
              currentState.sourceFrame.width,
              currentState.sourceFrame.height,
              currentState.resolution
            );

            flop.setFrame(currentState.destinationFrame, currentState.sourceFrame);

            // finally lets clear the render target before drawing to it..
            flop.clear();

            var i = 0;

            for (i = 0; i < filters.length - 1; ++i) {
              filters[i].apply(this, flip, flop, true, currentState);

              var t = flip;

              flip = flop;
              flop = t;
            }

            filters[i].apply(this, flip, lastState.renderTarget, false, currentState);

            this.freePotRenderTarget(flip);
            this.freePotRenderTarget(flop);
          }

          currentState.clear();
          filterData.index--;

          if (filterData.index === 0) {
            this.filterData = null;
          }
        };

        /**
         * Draws a filter.
         *
         * @param {PIXI.Filter} filter - The filter to draw.
         * @param {PIXI.RenderTarget} input - The input render target.
         * @param {PIXI.RenderTarget} output - The target to output to.
         * @param {boolean} clear - Should the output be cleared before rendering to it
         */

        FilterManager.prototype.applyFilter = function applyFilter(filter, input, output, clear) {
          var renderer = this.renderer;
          var gl = renderer.gl;

          var shader = filter.glShaders[renderer.CONTEXT_UID];

          // caching..
          if (!shader) {
            if (filter.glShaderKey) {
              shader = this.shaderCache[filter.glShaderKey];

              if (!shader) {
                shader = new _Shader2.default(this.gl, filter.vertexSrc, filter.fragmentSrc);

                filter.glShaders[renderer.CONTEXT_UID] = this.shaderCache[filter.glShaderKey] = shader;
                this.managedFilters.push(filter);
              }
            } else {
              shader = filter.glShaders[renderer.CONTEXT_UID] = new _Shader2.default(this.gl, filter.vertexSrc, filter.fragmentSrc);
              this.managedFilters.push(filter);
            }

            // TODO - this only needs to be done once?
            renderer.bindVao(null);

            this.quad.initVao(shader);
          }

          renderer.bindVao(this.quad.vao);

          renderer.bindRenderTarget(output);

          if (clear) {
            gl.disable(gl.SCISSOR_TEST);
            renderer.clear(); // [1, 1, 1, 1]);
            gl.enable(gl.SCISSOR_TEST);
          }

          // in case the render target is being masked using a scissor rect
          if (output === renderer.maskManager.scissorRenderTarget) {
            renderer.maskManager.pushScissorMask(null, renderer.maskManager.scissorData);
          }

          renderer.bindShader(shader);

          // free unit 0 for us, doesn't matter what was there
          // don't try to restore it, because syncUniforms can upload it to another slot
          // and it'll be a problem
          var tex = this.renderer.emptyTextures[0];

          this.renderer.boundTextures[0] = tex;
          // this syncs the PixiJS filters  uniforms with glsl uniforms
          this.syncUniforms(shader, filter);

          renderer.state.setBlendMode(filter.blendMode);

          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, input.texture.texture);

          this.quad.vao.draw(this.renderer.gl.TRIANGLES, 6, 0);

          gl.bindTexture(gl.TEXTURE_2D, tex._glTextures[this.renderer.CONTEXT_UID].texture);
        };

        /**
         * Uploads the uniforms of the filter.
         *
         * @param {GLShader} shader - The underlying gl shader.
         * @param {PIXI.Filter} filter - The filter we are synchronizing.
         */

        FilterManager.prototype.syncUniforms = function syncUniforms(shader, filter) {
          var uniformData = filter.uniformData;
          var uniforms = filter.uniforms;

          // 0 is reserved for the PixiJS texture so we start at 1!
          var textureCount = 1;
          var currentState = void 0;

          // filterArea and filterClamp that are handled by FilterManager directly
          // they must not appear in uniformData

          if (shader.uniforms.filterArea) {
            currentState = this.filterData.stack[this.filterData.index];

            var filterArea = shader.uniforms.filterArea;

            filterArea[0] = currentState.renderTarget.size.width;
            filterArea[1] = currentState.renderTarget.size.height;
            filterArea[2] = currentState.sourceFrame.x;
            filterArea[3] = currentState.sourceFrame.y;

            shader.uniforms.filterArea = filterArea;
          }

          // use this to clamp displaced texture coords so they belong to filterArea
          // see displacementFilter fragment shader for an example
          if (shader.uniforms.filterClamp) {
            currentState = currentState || this.filterData.stack[this.filterData.index];

            var filterClamp = shader.uniforms.filterClamp;

            filterClamp[0] = 0;
            filterClamp[1] = 0;
            filterClamp[2] = (currentState.sourceFrame.width - 1) / currentState.renderTarget.size.width;
            filterClamp[3] = (currentState.sourceFrame.height - 1) / currentState.renderTarget.size.height;

            shader.uniforms.filterClamp = filterClamp;
          }

          // TODO Caching layer..
          for (var i in uniformData) {
            if (!shader.uniforms.data[i]) {
              continue;
            }

            var type = uniformData[i].type;

            if (type === "sampler2d" && uniforms[i] !== 0) {
              if (uniforms[i].baseTexture) {
                shader.uniforms[i] = this.renderer.bindTexture(uniforms[i].baseTexture, textureCount);
              } else {
                shader.uniforms[i] = textureCount;

                // TODO
                // this is helpful as renderTargets can also be set.
                // Although thinking about it, we could probably
                // make the filter texture cache return a RenderTexture
                // rather than a renderTarget
                var gl = this.renderer.gl;

                this.renderer.boundTextures[textureCount] = this.renderer.emptyTextures[textureCount];
                gl.activeTexture(gl.TEXTURE0 + textureCount);

                uniforms[i].texture.bind();
              }

              textureCount++;
            } else if (type === "mat3") {
              // check if its PixiJS matrix..
              if (uniforms[i].a !== undefined) {
                shader.uniforms[i] = uniforms[i].toArray(true);
              } else {
                shader.uniforms[i] = uniforms[i];
              }
            } else if (type === "vec2") {
              // check if its a point..
              if (uniforms[i].x !== undefined) {
                var val = shader.uniforms[i] || new Float32Array(2);

                val[0] = uniforms[i].x;
                val[1] = uniforms[i].y;
                shader.uniforms[i] = val;
              } else {
                shader.uniforms[i] = uniforms[i];
              }
            } else if (type === "float") {
              if (shader.uniforms.data[i].value !== uniformData[i]) {
                shader.uniforms[i] = uniforms[i];
              }
            } else {
              shader.uniforms[i] = uniforms[i];
            }
          }
        };

        /**
         * Gets a render target from the pool, or creates a new one.
         *
         * @param {boolean} clear - Should we clear the render texture when we get it?
         * @param {number} resolution - The resolution of the target.
         * @return {PIXI.RenderTarget} The new render target
         */

        FilterManager.prototype.getRenderTarget = function getRenderTarget(clear, resolution) {
          var currentState = this.filterData.stack[this.filterData.index];
          var renderTarget = this.getPotRenderTarget(
            this.renderer.gl,
            currentState.sourceFrame.width,
            currentState.sourceFrame.height,
            resolution || currentState.resolution
          );

          renderTarget.setFrame(currentState.destinationFrame, currentState.sourceFrame);

          return renderTarget;
        };

        /**
         * Returns a render target to the pool.
         *
         * @param {PIXI.RenderTarget} renderTarget - The render target to return.
         */

        FilterManager.prototype.returnRenderTarget = function returnRenderTarget(renderTarget) {
          this.freePotRenderTarget(renderTarget);
        };

        /**
         * Calculates the mapped matrix.
         *
         * TODO playing around here.. this is temporary - (will end up in the shader)
         * this returns a matrix that will normalise map filter cords in the filter to screen space
         *
         * @param {PIXI.Matrix} outputMatrix - the matrix to output to.
         * @return {PIXI.Matrix} The mapped matrix.
         */

        FilterManager.prototype.calculateScreenSpaceMatrix = function calculateScreenSpaceMatrix(outputMatrix) {
          var currentState = this.filterData.stack[this.filterData.index];

          return filterTransforms.calculateScreenSpaceMatrix(outputMatrix, currentState.sourceFrame, currentState.renderTarget.size);
        };

        /**
         * Multiply vTextureCoord to this matrix to achieve (0,0,1,1) for filterArea
         *
         * @param {PIXI.Matrix} outputMatrix - The matrix to output to.
         * @return {PIXI.Matrix} The mapped matrix.
         */

        FilterManager.prototype.calculateNormalizedScreenSpaceMatrix = function calculateNormalizedScreenSpaceMatrix(outputMatrix) {
          var currentState = this.filterData.stack[this.filterData.index];

          return filterTransforms.calculateNormalizedScreenSpaceMatrix(
            outputMatrix,
            currentState.sourceFrame,
            currentState.renderTarget.size,
            currentState.destinationFrame
          );
        };

        /**
         * This will map the filter coord so that a texture can be used based on the transform of a sprite
         *
         * @param {PIXI.Matrix} outputMatrix - The matrix to output to.
         * @param {PIXI.Sprite} sprite - The sprite to map to.
         * @return {PIXI.Matrix} The mapped matrix.
         */

        FilterManager.prototype.calculateSpriteMatrix = function calculateSpriteMatrix(outputMatrix, sprite) {
          var currentState = this.filterData.stack[this.filterData.index];

          return filterTransforms.calculateSpriteMatrix(outputMatrix, currentState.sourceFrame, currentState.renderTarget.size, sprite);
        };

        /**
         * Destroys this Filter Manager.
         *
         * @param {boolean} [contextLost=false] context was lost, do not free shaders
         *
         */

        FilterManager.prototype.destroy = function destroy() {
          var contextLost = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

          var renderer = this.renderer;
          var filters = this.managedFilters;

          renderer.off("prerender", this.onPrerender, this);

          for (var i = 0; i < filters.length; i++) {
            if (!contextLost) {
              filters[i].glShaders[renderer.CONTEXT_UID].destroy();
            }
            delete filters[i].glShaders[renderer.CONTEXT_UID];
          }

          this.shaderCache = {};
          if (!contextLost) {
            this.emptyPool();
          } else {
            this.pool = {};
          }
        };

        /**
         * Gets a Power-of-Two render texture.
         *
         * TODO move to a separate class could be on renderer?
         * also - could cause issue with multiple contexts?
         *
         * @private
         * @param {WebGLRenderingContext} gl - The webgl rendering context
         * @param {number} minWidth - The minimum width of the render target.
         * @param {number} minHeight - The minimum height of the render target.
         * @param {number} resolution - The resolution of the render target.
         * @return {PIXI.RenderTarget} The new render target.
         */

        FilterManager.prototype.getPotRenderTarget = function getPotRenderTarget(gl, minWidth, minHeight, resolution) {
          var key = screenKey;

          minWidth *= resolution;
          minHeight *= resolution;

          if (minWidth !== this._screenWidth || minHeight !== this._screenHeight) {
            // TODO you could return a bigger texture if there is not one in the pool?
            minWidth = _bitTwiddle2.default.nextPow2(minWidth);
            minHeight = _bitTwiddle2.default.nextPow2(minHeight);
            key = ((minWidth & 0xffff) << 16) | (minHeight & 0xffff);
          }

          if (!this.pool[key]) {
            this.pool[key] = [];
          }

          var renderTarget = this.pool[key].pop();

          // creating render target will cause texture to be bound!
          if (!renderTarget) {
            // temporary bypass cache..
            var tex = this.renderer.boundTextures[0];

            gl.activeTexture(gl.TEXTURE0);

            // internally - this will cause a texture to be bound..
            renderTarget = new _RenderTarget2.default(gl, minWidth, minHeight, null, 1);

            // set the current one back
            gl.bindTexture(gl.TEXTURE_2D, tex._glTextures[this.renderer.CONTEXT_UID].texture);
          }

          // manually tweak the resolution...
          // this will not modify the size of the frame buffer, just its resolution.
          renderTarget.resolution = resolution;
          renderTarget.defaultFrame.width = renderTarget.size.width = minWidth / resolution;
          renderTarget.defaultFrame.height = renderTarget.size.height = minHeight / resolution;
          renderTarget.filterPoolKey = key;

          return renderTarget;
        };

        /**
         * Empties the texture pool.
         *
         */

        FilterManager.prototype.emptyPool = function emptyPool() {
          for (var i in this.pool) {
            var textures = this.pool[i];

            if (textures) {
              for (var j = 0; j < textures.length; j++) {
                textures[j].destroy(true);
              }
            }
          }

          this.pool = {};
        };

        /**
         * Frees a render target back into the pool.
         *
         * @param {PIXI.RenderTarget} renderTarget - The renderTarget to free
         */

        FilterManager.prototype.freePotRenderTarget = function freePotRenderTarget(renderTarget) {
          this.pool[renderTarget.filterPoolKey].push(renderTarget);
        };

        /**
         * Called before the renderer starts rendering.
         *
         */

        FilterManager.prototype.onPrerender = function onPrerender() {
          if (this._screenWidth !== this.renderer.view.width || this._screenHeight !== this.renderer.view.height) {
            this._screenWidth = this.renderer.view.width;
            this._screenHeight = this.renderer.view.height;

            var textures = this.pool[screenKey];

            if (textures) {
              for (var j = 0; j < textures.length; j++) {
                textures[j].destroy(true);
              }
            }
            this.pool[screenKey] = [];
          }
        };

        return FilterManager;
      })(_WebGLManager3.default);

      exports.default = FilterManager;
      //# sourceMappingURL=FilterManager.js.map

      /***/
    },
    /* 508 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;
      exports.calculateScreenSpaceMatrix = calculateScreenSpaceMatrix;
      exports.calculateNormalizedScreenSpaceMatrix = calculateNormalizedScreenSpaceMatrix;
      exports.calculateSpriteMatrix = calculateSpriteMatrix;

      var _math = __webpack_require__(348);

      /**
       * Calculates the mapped matrix
       * @param filterArea {Rectangle} The filter area
       * @param sprite {Sprite} the target sprite
       * @param outputMatrix {Matrix} @alvin
       * @private
       */
      // TODO playing around here.. this is temporary - (will end up in the shader)
      // this returns a matrix that will normalise map filter cords in the filter to screen space
      function calculateScreenSpaceMatrix(outputMatrix, filterArea, textureSize) {
        // let worldTransform = sprite.worldTransform.copy(Matrix.TEMP_MATRIX),
        // let texture = {width:1136, height:700};//sprite._texture.baseTexture;

        // TODO unwrap?
        var mappedMatrix = outputMatrix.identity();

        mappedMatrix.translate(filterArea.x / textureSize.width, filterArea.y / textureSize.height);

        mappedMatrix.scale(textureSize.width, textureSize.height);

        return mappedMatrix;
      }

      function calculateNormalizedScreenSpaceMatrix(outputMatrix, filterArea, textureSize) {
        var mappedMatrix = outputMatrix.identity();

        mappedMatrix.translate(filterArea.x / textureSize.width, filterArea.y / textureSize.height);

        var translateScaleX = textureSize.width / filterArea.width;
        var translateScaleY = textureSize.height / filterArea.height;

        mappedMatrix.scale(translateScaleX, translateScaleY);

        return mappedMatrix;
      }

      // this will map the filter coord so that a texture can be used based on the transform of a sprite
      function calculateSpriteMatrix(outputMatrix, filterArea, textureSize, sprite) {
        var orig = sprite._texture.orig;
        var mappedMatrix = outputMatrix.set(textureSize.width, 0, 0, textureSize.height, filterArea.x, filterArea.y);
        var worldTransform = sprite.worldTransform.copy(_math.Matrix.TEMP_MATRIX);

        worldTransform.invert();
        mappedMatrix.prepend(worldTransform);
        mappedMatrix.scale(1.0 / orig.width, 1.0 / orig.height);
        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);

        return mappedMatrix;
      }
      //# sourceMappingURL=filterTransforms.js.map

      /***/
    },
    /* 509 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      var _pixiGlCore = __webpack_require__(350);

      var _const = __webpack_require__(343);

      var _RenderTarget = __webpack_require__(367);

      var _RenderTarget2 = _interopRequireDefault(_RenderTarget);

      var _utils = __webpack_require__(345);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      /**
       * Helper class to create a webGL Texture
       *
       * @class
       * @memberof PIXI
       */
      var TextureManager = (function () {
        /**
         * @param {PIXI.WebGLRenderer} renderer - A reference to the current renderer
         */
        function TextureManager(renderer) {
          _classCallCheck(this, TextureManager);

          /**
           * A reference to the current renderer
           *
           * @member {PIXI.WebGLRenderer}
           */
          this.renderer = renderer;

          /**
           * The current WebGL rendering context
           *
           * @member {WebGLRenderingContext}
           */
          this.gl = renderer.gl;

          /**
           * Track textures in the renderer so we can no longer listen to them on destruction.
           *
           * @member {Array<*>}
           * @private
           */
          this._managedTextures = [];
        }

        /**
         * Binds a texture.
         *
         */

        TextureManager.prototype.bindTexture = function bindTexture() {};
        // empty

        /**
         * Gets a texture.
         *
         */

        TextureManager.prototype.getTexture = function getTexture() {};
        // empty

        /**
         * Updates and/or Creates a WebGL texture for the renderer's context.
         *
         * @param {PIXI.BaseTexture|PIXI.Texture} texture - the texture to update
         * @param {number} location - the location the texture will be bound to.
         * @return {GLTexture} The gl texture.
         */

        TextureManager.prototype.updateTexture = function updateTexture(texture, location) {
          // assume it good!
          // texture = texture.baseTexture || texture;

          var gl = this.gl;

          var isRenderTexture = !!texture._glRenderTargets;

          if (!texture.hasLoaded) {
            return null;
          }

          var boundTextures = this.renderer.boundTextures;

          // if the location is undefined then this may have been called by n event.
          // this being the case the texture may already be bound to a slot. As a texture can only be bound once
          // we need to find its current location if it exists.
          if (location === undefined) {
            location = 0;

            // TODO maybe we can use texture bound ids later on...
            // check if texture is already bound..
            for (var i = 0; i < boundTextures.length; ++i) {
              if (boundTextures[i] === texture) {
                location = i;
                break;
              }
            }
          }

          boundTextures[location] = texture;

          gl.activeTexture(gl.TEXTURE0 + location);

          var glTexture = texture._glTextures[this.renderer.CONTEXT_UID];

          if (!glTexture) {
            if (isRenderTexture) {
              var renderTarget = new _RenderTarget2.default(this.gl, texture.width, texture.height, texture.scaleMode, texture.resolution);

              renderTarget.resize(texture.width, texture.height);
              texture._glRenderTargets[this.renderer.CONTEXT_UID] = renderTarget;
              glTexture = renderTarget.texture;

              // framebuffer constructor disactivates current framebuffer
              if (!this.renderer._activeRenderTarget.root) {
                this.renderer._activeRenderTarget.frameBuffer.bind();
              }
            } else {
              glTexture = new _pixiGlCore.GLTexture(this.gl, null, null, null, null);
              glTexture.bind(location);
              glTexture.premultiplyAlpha = true;
              glTexture.upload(texture.source);
            }

            texture._glTextures[this.renderer.CONTEXT_UID] = glTexture;

            texture.on("update", this.updateTexture, this);
            texture.on("dispose", this.destroyTexture, this);

            this._managedTextures.push(texture);

            if (texture.isPowerOfTwo) {
              if (texture.mipmap) {
                glTexture.enableMipmap();
              }

              if (texture.wrapMode === _const.WRAP_MODES.CLAMP) {
                glTexture.enableWrapClamp();
              } else if (texture.wrapMode === _const.WRAP_MODES.REPEAT) {
                glTexture.enableWrapRepeat();
              } else {
                glTexture.enableWrapMirrorRepeat();
              }
            } else {
              glTexture.enableWrapClamp();
            }

            if (texture.scaleMode === _const.SCALE_MODES.NEAREST) {
              glTexture.enableNearestScaling();
            } else {
              glTexture.enableLinearScaling();
            }
          }
          // the texture already exists so we only need to update it..
          else if (isRenderTexture) {
            texture._glRenderTargets[this.renderer.CONTEXT_UID].resize(texture.width, texture.height);
          } else {
            glTexture.upload(texture.source);
          }

          return glTexture;
        };

        /**
         * Deletes the texture from WebGL
         *
         * @param {PIXI.BaseTexture|PIXI.Texture} texture - the texture to destroy
         * @param {boolean} [skipRemove=false] - Whether to skip removing the texture from the TextureManager.
         */

        TextureManager.prototype.destroyTexture = function destroyTexture(texture, skipRemove) {
          texture = texture.baseTexture || texture;

          if (!texture.hasLoaded) {
            return;
          }

          var renderer = this.renderer;
          var uid = renderer.CONTEXT_UID;
          var glTextures = texture._glTextures;
          var glRenderTargets = texture._glRenderTargets;

          if (glTextures[uid]) {
            renderer.unbindTexture(texture);

            glTextures[uid].destroy();
            texture.off("update", this.updateTexture, this);
            texture.off("dispose", this.destroyTexture, this);

            delete glTextures[uid];

            if (!skipRemove) {
              var i = this._managedTextures.indexOf(texture);

              if (i !== -1) {
                (0, _utils.removeItems)(this._managedTextures, i, 1);
              }
            }
          }

          if (glRenderTargets && glRenderTargets[uid]) {
            if (renderer._activeRenderTarget === glRenderTargets[uid]) {
              renderer.bindRenderTarget(renderer.rootRenderTarget);
            }

            glRenderTargets[uid].destroy();
            delete glRenderTargets[uid];
          }
        };

        /**
         * Deletes all the textures from WebGL
         */

        TextureManager.prototype.removeAll = function removeAll() {
          // empty all the old gl textures as they are useless now
          for (var i = 0; i < this._managedTextures.length; ++i) {
            var texture = this._managedTextures[i];

            if (texture._glTextures[this.renderer.CONTEXT_UID]) {
              delete texture._glTextures[this.renderer.CONTEXT_UID];
            }
          }
        };

        /**
         * Destroys this manager and removes all its textures
         */

        TextureManager.prototype.destroy = function destroy() {
          // destroy managed textures
          for (var i = 0; i < this._managedTextures.length; ++i) {
            var texture = this._managedTextures[i];

            this.destroyTexture(texture, true);

            texture.off("update", this.updateTexture, this);
            texture.off("dispose", this.destroyTexture, this);
          }

          this._managedTextures = null;
        };

        return TextureManager;
      })();

      exports.default = TextureManager;
      //# sourceMappingURL=TextureManager.js.map

      /***/
    },
    /* 510 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      var _const = __webpack_require__(343);

      var _settings = __webpack_require__(346);

      var _settings2 = _interopRequireDefault(_settings);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      /**
       * TextureGarbageCollector. This class manages the GPU and ensures that it does not get clogged
       * up with textures that are no longer being used.
       *
       * @class
       * @memberof PIXI
       */
      var TextureGarbageCollector = (function () {
        /**
         * @param {PIXI.WebGLRenderer} renderer - The renderer this manager works for.
         */
        function TextureGarbageCollector(renderer) {
          _classCallCheck(this, TextureGarbageCollector);

          this.renderer = renderer;

          this.count = 0;
          this.checkCount = 0;
          this.maxIdle = _settings2.default.GC_MAX_IDLE;
          this.checkCountMax = _settings2.default.GC_MAX_CHECK_COUNT;
          this.mode = _settings2.default.GC_MODE;
        }

        /**
         * Checks to see when the last time a texture was used
         * if the texture has not been used for a specified amount of time it will be removed from the GPU
         */

        TextureGarbageCollector.prototype.update = function update() {
          this.count++;

          if (this.mode === _const.GC_MODES.MANUAL) {
            return;
          }

          this.checkCount++;

          if (this.checkCount > this.checkCountMax) {
            this.checkCount = 0;

            this.run();
          }
        };

        /**
         * Checks to see when the last time a texture was used
         * if the texture has not been used for a specified amount of time it will be removed from the GPU
         */

        TextureGarbageCollector.prototype.run = function run() {
          var tm = this.renderer.textureManager;
          var managedTextures = tm._managedTextures;
          var wasRemoved = false;

          for (var i = 0; i < managedTextures.length; i++) {
            var texture = managedTextures[i];

            // only supports non generated textures at the moment!
            if (!texture._glRenderTargets && this.count - texture.touched > this.maxIdle) {
              tm.destroyTexture(texture, true);
              managedTextures[i] = null;
              wasRemoved = true;
            }
          }

          if (wasRemoved) {
            var j = 0;

            for (var _i = 0; _i < managedTextures.length; _i++) {
              if (managedTextures[_i] !== null) {
                managedTextures[j++] = managedTextures[_i];
              }
            }

            managedTextures.length = j;
          }
        };

        /**
         * Removes all the textures within the specified displayObject and its children from the GPU
         *
         * @param {PIXI.DisplayObject} displayObject - the displayObject to remove the textures from.
         */

        TextureGarbageCollector.prototype.unload = function unload(displayObject) {
          var tm = this.renderer.textureManager;

          // only destroy non generated textures
          if (displayObject._texture && displayObject._texture._glRenderTargets) {
            tm.destroyTexture(displayObject._texture, true);
          }

          for (var i = displayObject.children.length - 1; i >= 0; i--) {
            this.unload(displayObject.children[i]);
          }
        };

        return TextureGarbageCollector;
      })();

      exports.default = TextureGarbageCollector;
      //# sourceMappingURL=TextureGarbageCollector.js.map

      /***/
    },
    /* 511 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      var _mapWebGLBlendModesToPixi = __webpack_require__(512);

      var _mapWebGLBlendModesToPixi2 = _interopRequireDefault(_mapWebGLBlendModesToPixi);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var BLEND = 0;
      var DEPTH_TEST = 1;
      var FRONT_FACE = 2;
      var CULL_FACE = 3;
      var BLEND_FUNC = 4;

      /**
       * A WebGL state machines
       *
       * @memberof PIXI
       * @class
       */

      var WebGLState = (function () {
        /**
         * @param {WebGLRenderingContext} gl - The current WebGL rendering context
         */
        function WebGLState(gl) {
          _classCallCheck(this, WebGLState);

          /**
           * The current active state
           *
           * @member {Uint8Array}
           */
          this.activeState = new Uint8Array(16);

          /**
           * The default state
           *
           * @member {Uint8Array}
           */
          this.defaultState = new Uint8Array(16);

          // default blend mode..
          this.defaultState[0] = 1;

          /**
           * The current state index in the stack
           *
           * @member {number}
           * @private
           */
          this.stackIndex = 0;

          /**
           * The stack holding all the different states
           *
           * @member {Array<*>}
           * @private
           */
          this.stack = [];

          /**
           * The current WebGL rendering context
           *
           * @member {WebGLRenderingContext}
           */
          this.gl = gl;

          this.maxAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);

          this.attribState = {
            tempAttribState: new Array(this.maxAttribs),
            attribState: new Array(this.maxAttribs),
          };

          this.blendModes = (0, _mapWebGLBlendModesToPixi2.default)(gl);

          // check we have vao..
          this.nativeVaoExtension =
            gl.getExtension("OES_vertex_array_object") ||
            gl.getExtension("MOZ_OES_vertex_array_object") ||
            gl.getExtension("WEBKIT_OES_vertex_array_object");
        }

        /**
         * Pushes a new active state
         */

        WebGLState.prototype.push = function push() {
          // next state..
          var state = this.stack[this.stackIndex];

          if (!state) {
            state = this.stack[this.stackIndex] = new Uint8Array(16);
          }

          ++this.stackIndex;

          // copy state..
          // set active state so we can force overrides of gl state
          for (var i = 0; i < this.activeState.length; i++) {
            state[i] = this.activeState[i];
          }
        };

        /**
         * Pops a state out
         */

        WebGLState.prototype.pop = function pop() {
          var state = this.stack[--this.stackIndex];

          this.setState(state);
        };

        /**
         * Sets the current state
         *
         * @param {*} state - The state to set.
         */

        WebGLState.prototype.setState = function setState(state) {
          this.setBlend(state[BLEND]);
          this.setDepthTest(state[DEPTH_TEST]);
          this.setFrontFace(state[FRONT_FACE]);
          this.setCullFace(state[CULL_FACE]);
          this.setBlendMode(state[BLEND_FUNC]);
        };

        /**
         * Enables or disabled blending.
         *
         * @param {boolean} value - Turn on or off webgl blending.
         */

        WebGLState.prototype.setBlend = function setBlend(value) {
          value = value ? 1 : 0;

          if (this.activeState[BLEND] === value) {
            return;
          }

          this.activeState[BLEND] = value;
          this.gl[value ? "enable" : "disable"](this.gl.BLEND);
        };

        /**
         * Sets the blend mode.
         *
         * @param {number} value - The blend mode to set to.
         */

        WebGLState.prototype.setBlendMode = function setBlendMode(value) {
          if (value === this.activeState[BLEND_FUNC]) {
            return;
          }

          this.activeState[BLEND_FUNC] = value;

          var mode = this.blendModes[value];

          if (mode.length === 2) {
            this.gl.blendFunc(mode[0], mode[1]);
          } else {
            this.gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
          }
        };

        /**
         * Sets whether to enable or disable depth test.
         *
         * @param {boolean} value - Turn on or off webgl depth testing.
         */

        WebGLState.prototype.setDepthTest = function setDepthTest(value) {
          value = value ? 1 : 0;

          if (this.activeState[DEPTH_TEST] === value) {
            return;
          }

          this.activeState[DEPTH_TEST] = value;
          this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);
        };

        /**
         * Sets whether to enable or disable cull face.
         *
         * @param {boolean} value - Turn on or off webgl cull face.
         */

        WebGLState.prototype.setCullFace = function setCullFace(value) {
          value = value ? 1 : 0;

          if (this.activeState[CULL_FACE] === value) {
            return;
          }

          this.activeState[CULL_FACE] = value;
          this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);
        };

        /**
         * Sets the gl front face.
         *
         * @param {boolean} value - true is clockwise and false is counter-clockwise
         */

        WebGLState.prototype.setFrontFace = function setFrontFace(value) {
          value = value ? 1 : 0;

          if (this.activeState[FRONT_FACE] === value) {
            return;
          }

          this.activeState[FRONT_FACE] = value;
          this.gl.frontFace(this.gl[value ? "CW" : "CCW"]);
        };

        /**
         * Disables all the vaos in use
         *
         */

        WebGLState.prototype.resetAttributes = function resetAttributes() {
          for (var i = 0; i < this.attribState.tempAttribState.length; i++) {
            this.attribState.tempAttribState[i] = 0;
          }

          for (var _i = 0; _i < this.attribState.attribState.length; _i++) {
            this.attribState.attribState[_i] = 0;
          }

          // im going to assume one is always active for performance reasons.
          for (var _i2 = 1; _i2 < this.maxAttribs; _i2++) {
            this.gl.disableVertexAttribArray(_i2);
          }
        };

        // used
        /**
         * Resets all the logic and disables the vaos
         */

        WebGLState.prototype.resetToDefault = function resetToDefault() {
          // unbind any VAO if they exist..
          if (this.nativeVaoExtension) {
            this.nativeVaoExtension.bindVertexArrayOES(null);
          }

          // reset all attributes..
          this.resetAttributes();

          // set active state so we can force overrides of gl state
          for (var i = 0; i < this.activeState.length; ++i) {
            this.activeState[i] = 32;
          }

          this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);

          this.setState(this.defaultState);
        };

        return WebGLState;
      })();

      exports.default = WebGLState;
      //# sourceMappingURL=WebGLState.js.map

      /***/
    },
    /* 512 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;
      exports.default = mapWebGLBlendModesToPixi;

      var _const = __webpack_require__(343);

      /**
       * Maps gl blend combinations to WebGL.
       *
       * @memberof PIXI
       * @function mapWebGLBlendModesToPixi
       * @private
       * @param {WebGLRenderingContext} gl - The rendering context.
       * @param {string[]} [array=[]] - The array to output into.
       * @return {string[]} Mapped modes.
       */
      function mapWebGLBlendModesToPixi(gl) {
        var array = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

        // TODO - premultiply alpha would be different.
        // add a boolean for that!
        array[_const.BLEND_MODES.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[_const.BLEND_MODES.ADD] = [gl.ONE, gl.ONE];
        array[_const.BLEND_MODES.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[_const.BLEND_MODES.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[_const.BLEND_MODES.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[_const.BLEND_MODES.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[_const.BLEND_MODES.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[_const.BLEND_MODES.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[_const.BLEND_MODES.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[_const.BLEND_MODES.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[_const.BLEND_MODES.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[_const.BLEND_MODES.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[_const.BLEND_MODES.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[_const.BLEND_MODES.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[_const.BLEND_MODES.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[_const.BLEND_MODES.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[_const.BLEND_MODES.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];

        // not-premultiplied blend modes
        array[_const.BLEND_MODES.NORMAL_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[_const.BLEND_MODES.ADD_NPM] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
        array[_const.BLEND_MODES.SCREEN_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];

        return array;
      }
      //# sourceMappingURL=mapWebGLBlendModesToPixi.js.map

      /***/
    },
    /* 513 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;
      exports.default = mapWebGLDrawModesToPixi;

      var _const = __webpack_require__(343);

      /**
       * Generic Mask Stack data structure.
       *
       * @memberof PIXI
       * @function mapWebGLDrawModesToPixi
       * @private
       * @param {WebGLRenderingContext} gl - The current WebGL drawing context
       * @param {object} [object={}] - The object to map into
       * @return {object} The mapped draw modes.
       */
      function mapWebGLDrawModesToPixi(gl) {
        var object = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        object[_const.DRAW_MODES.POINTS] = gl.POINTS;
        object[_const.DRAW_MODES.LINES] = gl.LINES;
        object[_const.DRAW_MODES.LINE_LOOP] = gl.LINE_LOOP;
        object[_const.DRAW_MODES.LINE_STRIP] = gl.LINE_STRIP;
        object[_const.DRAW_MODES.TRIANGLES] = gl.TRIANGLES;
        object[_const.DRAW_MODES.TRIANGLE_STRIP] = gl.TRIANGLE_STRIP;
        object[_const.DRAW_MODES.TRIANGLE_FAN] = gl.TRIANGLE_FAN;

        return object;
      }
      //# sourceMappingURL=mapWebGLDrawModesToPixi.js.map

      /***/
    },
    /* 514 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;
      exports.default = validateContext;
      function validateContext(gl) {
        var attributes = gl.getContextAttributes();

        // this is going to be fairly simple for now.. but at least we have room to grow!
        if (!attributes.stencil) {
          /* eslint-disable no-console */
          console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
          /* eslint-enable no-console */
        }
      }
      //# sourceMappingURL=validateContext.js.map

      /***/
    },
    /* 515 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;
      exports.default = generateMultiTextureShader;

      var _Shader = __webpack_require__(361);

      var _Shader2 = _interopRequireDefault(_Shader);

      var _path = __webpack_require__(352);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      var fragTemplate = [
        "varying vec2 vTextureCoord;",
        "varying vec4 vColor;",
        "varying float vTextureId;",
        "uniform sampler2D uSamplers[%count%];",
        "void main(void){",
        "vec4 color;",
        "%forloop%",
        "gl_FragColor = color * vColor;",
        "}",
      ].join("\n");

      function generateMultiTextureShader(gl, maxTextures) {
        var vertexSrc =
          "precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor;\n}\n";
        var fragmentSrc = fragTemplate;

        fragmentSrc = fragmentSrc.replace(/%count%/gi, maxTextures);
        fragmentSrc = fragmentSrc.replace(/%forloop%/gi, generateSampleSrc(maxTextures));

        var shader = new _Shader2.default(gl, vertexSrc, fragmentSrc);

        var sampleValues = [];

        for (var i = 0; i < maxTextures; i++) {
          sampleValues[i] = i;
        }

        shader.bind();
        shader.uniforms.uSamplers = sampleValues;

        return shader;
      }

      function generateSampleSrc(maxTextures) {
        var src = "";

        src += "\n";
        src += "\n";

        for (var i = 0; i < maxTextures; i++) {
          if (i > 0) {
            src += "\nelse ";
          }

          if (i < maxTextures - 1) {
            src += "if(vTextureId < " + i + ".5)";
          }

          src += "\n{";
          src += "\n\tcolor = texture2D(uSamplers[" + i + "], vTextureCoord);";
          src += "\n}";
        }

        src += "\n";
        src += "\n";

        return src;
      }
      //# sourceMappingURL=generateMultiTextureShader.js.map

      /***/
    },
    /* 516 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;
      exports.default = checkMaxIfStatmentsInShader;

      var _pixiGlCore = __webpack_require__(350);

      var _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      var fragTemplate = ["precision mediump float;", "void main(void){", "float test = 0.1;", "%forloop%", "gl_FragColor = vec4(0.0);", "}"].join(
        "\n"
      );

      function checkMaxIfStatmentsInShader(maxIfs, gl) {
        var createTempContext = !gl;

        // @if DEBUG
        if (maxIfs === 0) {
          throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
        }
        // @endif

        if (createTempContext) {
          var tinyCanvas = document.createElement("canvas");

          tinyCanvas.width = 1;
          tinyCanvas.height = 1;

          gl = _pixiGlCore2.default.createContext(tinyCanvas);
        }

        var shader = gl.createShader(gl.FRAGMENT_SHADER);

        while (true) {
          // eslint-disable-line no-constant-condition
          var fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));

          gl.shaderSource(shader, fragmentSrc);
          gl.compileShader(shader);

          if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            maxIfs = (maxIfs / 2) | 0;
          } else {
            // valid!
            break;
          }
        }

        if (createTempContext) {
          // get rid of context
          if (gl.getExtension("WEBGL_lose_context")) {
            gl.getExtension("WEBGL_lose_context").loseContext();
          }
        }

        return maxIfs;
      }

      function generateIfTestSrc(maxIfs) {
        var src = "";

        for (var i = 0; i < maxIfs; ++i) {
          if (i > 0) {
            src += "\nelse ";
          }

          if (i < maxIfs - 1) {
            src += "if(test == " + i + ".0){}";
          }
        }

        return src;
      }
      //# sourceMappingURL=checkMaxIfStatmentsInShader.js.map

      /***/
    },
    /* 517 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      /**
       * @class
       * @memberof PIXI
       */
      var Buffer = (function () {
        /**
         * @param {number} size - The size of the buffer in bytes.
         */
        function Buffer(size) {
          _classCallCheck(this, Buffer);

          this.vertices = new ArrayBuffer(size);

          /**
           * View on the vertices as a Float32Array for positions
           *
           * @member {Float32Array}
           */
          this.float32View = new Float32Array(this.vertices);

          /**
           * View on the vertices as a Uint32Array for uvs
           *
           * @member {Float32Array}
           */
          this.uint32View = new Uint32Array(this.vertices);
        }

        /**
         * Destroys the buffer.
         *
         */

        Buffer.prototype.destroy = function destroy() {
          this.vertices = null;
          this.positions = null;
          this.uvs = null;
          this.colors = null;
        };

        return Buffer;
      })();

      exports.default = Buffer;
      //# sourceMappingURL=BatchBuffer.js.map

      /***/
    },
    /* 518 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      var _createClass = (function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      })();

      var _Sprite2 = __webpack_require__(381);

      var _Sprite3 = _interopRequireDefault(_Sprite2);

      var _Texture = __webpack_require__(353);

      var _Texture2 = _interopRequireDefault(_Texture);

      var _math = __webpack_require__(348);

      var _utils = __webpack_require__(345);

      var _const = __webpack_require__(343);

      var _settings = __webpack_require__(346);

      var _settings2 = _interopRequireDefault(_settings);

      var _TextStyle = __webpack_require__(419);

      var _TextStyle2 = _interopRequireDefault(_TextStyle);

      var _TextMetrics = __webpack_require__(420);

      var _TextMetrics2 = _interopRequireDefault(_TextMetrics);

      var _trimCanvas = __webpack_require__(519);

      var _trimCanvas2 = _interopRequireDefault(_trimCanvas);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: { value: subClass, enumerable: false, writable: true, configurable: true },
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass);
      } /* eslint max-depth: [2, 8] */

      var defaultDestroyOptions = {
        texture: true,
        children: false,
        baseTexture: true,
      };

      /**
       * A Text Object will create a line or multiple lines of text. To split a line you can use '\n' in your text string,
       * or add a wordWrap property set to true and and wordWrapWidth property with a value in the style object.
       *
       * A Text can be created directly from a string and a style object,
       * which can be generated [here](https://pixijs.io/pixi-text-style).
       *
       * ```js
       * let text = new PIXI.Text('This is a PixiJS text',{fontFamily : 'Arial', fontSize: 24, fill : 0xff1010, align : 'center'});
       * ```
       *
       * @class
       * @extends PIXI.Sprite
       * @memberof PIXI
       */

      var Text = (function (_Sprite) {
        _inherits(Text, _Sprite);

        /**
         * @param {string} text - The string that you would like the text to display
         * @param {object|PIXI.TextStyle} [style] - The style parameters
         * @param {HTMLCanvasElement} [canvas] - The canvas element for drawing text
         */
        function Text(text, style, canvas) {
          _classCallCheck(this, Text);

          canvas = canvas || document.createElement("canvas");

          canvas.width = 3;
          canvas.height = 3;

          var texture = _Texture2.default.fromCanvas(canvas, _settings2.default.SCALE_MODE, "text");

          texture.orig = new _math.Rectangle();
          texture.trim = new _math.Rectangle();

          // base texture is already automatically added to the cache, now adding the actual texture
          var _this = _possibleConstructorReturn(this, _Sprite.call(this, texture));

          _Texture2.default.addToCache(_this._texture, _this._texture.baseTexture.textureCacheIds[0]);

          /**
           * The canvas element that everything is drawn to
           *
           * @member {HTMLCanvasElement}
           */
          _this.canvas = canvas;

          /**
           * The canvas 2d context that everything is drawn with
           * @member {CanvasRenderingContext2D}
           */
          _this.context = _this.canvas.getContext("2d");

          /**
           * The resolution / device pixel ratio of the canvas. This is set automatically by the renderer.
           * @member {number}
           * @default 1
           */
          _this.resolution = _settings2.default.RESOLUTION;

          /**
           * Private tracker for the current text.
           *
           * @member {string}
           * @private
           */
          _this._text = null;

          /**
           * Private tracker for the current style.
           *
           * @member {object}
           * @private
           */
          _this._style = null;
          /**
           * Private listener to track style changes.
           *
           * @member {Function}
           * @private
           */
          _this._styleListener = null;

          /**
           * Private tracker for the current font.
           *
           * @member {string}
           * @private
           */
          _this._font = "";

          _this.text = text;
          _this.style = style;

          _this.localStyleID = -1;
          return _this;
        }

        /**
         * Renders text and updates it when needed.
         *
         * @private
         * @param {boolean} respectDirty - Whether to abort updating the text if the Text isn't dirty and the function is called.
         */

        Text.prototype.updateText = function updateText(respectDirty) {
          var style = this._style;

          // check if style has changed..
          if (this.localStyleID !== style.styleID) {
            this.dirty = true;
            this.localStyleID = style.styleID;
          }

          if (!this.dirty && respectDirty) {
            return;
          }

          this._font = this._style.toFontString();

          var context = this.context;
          var measured = _TextMetrics2.default.measureText(this._text, this._style, this._style.wordWrap, this.canvas);
          var width = measured.width;
          var height = measured.height;
          var lines = measured.lines;
          var lineHeight = measured.lineHeight;
          var lineWidths = measured.lineWidths;
          var maxLineWidth = measured.maxLineWidth;
          var fontProperties = measured.fontProperties;

          this.canvas.width = Math.ceil((Math.max(1, width) + style.padding * 2) * this.resolution);
          this.canvas.height = Math.ceil((Math.max(1, height) + style.padding * 2) * this.resolution);

          context.scale(this.resolution, this.resolution);

          context.clearRect(0, 0, this.canvas.width, this.canvas.height);

          context.font = this._font;
          context.strokeStyle = style.stroke;
          context.lineWidth = style.strokeThickness;
          context.textBaseline = style.textBaseline;
          context.lineJoin = style.lineJoin;
          context.miterLimit = style.miterLimit;

          var linePositionX = void 0;
          var linePositionY = void 0;

          if (style.dropShadow) {
            context.fillStyle = style.dropShadowColor;
            context.globalAlpha = style.dropShadowAlpha;
            context.shadowBlur = style.dropShadowBlur;

            if (style.dropShadowBlur > 0) {
              context.shadowColor = style.dropShadowColor;
            }

            var xShadowOffset = Math.cos(style.dropShadowAngle) * style.dropShadowDistance;
            var yShadowOffset = Math.sin(style.dropShadowAngle) * style.dropShadowDistance;

            for (var i = 0; i < lines.length; i++) {
              linePositionX = style.strokeThickness / 2;
              linePositionY = style.strokeThickness / 2 + i * lineHeight + fontProperties.ascent;

              if (style.align === "right") {
                linePositionX += maxLineWidth - lineWidths[i];
              } else if (style.align === "center") {
                linePositionX += (maxLineWidth - lineWidths[i]) / 2;
              }

              if (style.fill) {
                this.drawLetterSpacing(lines[i], linePositionX + xShadowOffset + style.padding, linePositionY + yShadowOffset + style.padding);

                if (style.stroke && style.strokeThickness) {
                  context.strokeStyle = style.dropShadowColor;
                  this.drawLetterSpacing(
                    lines[i],
                    linePositionX + xShadowOffset + style.padding,
                    linePositionY + yShadowOffset + style.padding,
                    true
                  );
                  context.strokeStyle = style.stroke;
                }
              }
            }
          }

          // reset the shadow blur and alpha that was set by the drop shadow, for the regular text
          context.shadowBlur = 0;
          context.globalAlpha = 1;

          // set canvas text styles
          context.fillStyle = this._generateFillStyle(style, lines);

          // draw lines line by line
          for (var _i = 0; _i < lines.length; _i++) {
            linePositionX = style.strokeThickness / 2;
            linePositionY = style.strokeThickness / 2 + _i * lineHeight + fontProperties.ascent;

            if (style.align === "right") {
              linePositionX += maxLineWidth - lineWidths[_i];
            } else if (style.align === "center") {
              linePositionX += (maxLineWidth - lineWidths[_i]) / 2;
            }

            if (style.stroke && style.strokeThickness) {
              this.drawLetterSpacing(lines[_i], linePositionX + style.padding, linePositionY + style.padding, true);
            }

            if (style.fill) {
              this.drawLetterSpacing(lines[_i], linePositionX + style.padding, linePositionY + style.padding);
            }
          }

          this.updateTexture();
        };

        /**
         * Render the text with letter-spacing.
         * @param {string} text - The text to draw
         * @param {number} x - Horizontal position to draw the text
         * @param {number} y - Vertical position to draw the text
         * @param {boolean} [isStroke=false] - Is this drawing for the outside stroke of the
         *  text? If not, it's for the inside fill
         * @private
         */

        Text.prototype.drawLetterSpacing = function drawLetterSpacing(text, x, y) {
          var isStroke = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

          var style = this._style;

          // letterSpacing of 0 means normal
          var letterSpacing = style.letterSpacing;

          if (letterSpacing === 0) {
            if (isStroke) {
              this.context.strokeText(text, x, y);
            } else {
              this.context.fillText(text, x, y);
            }

            return;
          }

          var characters = String.prototype.split.call(text, "");
          var currentPosition = x;
          var index = 0;
          var current = "";
          var previousWidth = this.context.measureText(text).width;
          var currentWidth = 0;

          while (index < text.length) {
            current = characters[index++];
            if (isStroke) {
              this.context.strokeText(current, currentPosition, y);
            } else {
              this.context.fillText(current, currentPosition, y);
            }
            currentWidth = this.context.measureText(text.substring(index)).width;
            currentPosition += previousWidth - currentWidth + letterSpacing;
            previousWidth = currentWidth;
          }
        };

        /**
         * Updates texture size based on canvas size
         *
         * @private
         */

        Text.prototype.updateTexture = function updateTexture() {
          var canvas = this.canvas;

          if (this._style.trim) {
            var trimmed = (0, _trimCanvas2.default)(canvas);

            if (trimmed.data) {
              canvas.width = trimmed.width;
              canvas.height = trimmed.height;
              this.context.putImageData(trimmed.data, 0, 0);
            }
          }

          var texture = this._texture;
          var style = this._style;
          var padding = style.trim ? 0 : style.padding;
          var baseTexture = texture.baseTexture;

          baseTexture.hasLoaded = true;
          baseTexture.resolution = this.resolution;

          baseTexture.realWidth = canvas.width;
          baseTexture.realHeight = canvas.height;
          baseTexture.width = canvas.width / this.resolution;
          baseTexture.height = canvas.height / this.resolution;

          texture.trim.width = texture._frame.width = canvas.width / this.resolution;
          texture.trim.height = texture._frame.height = canvas.height / this.resolution;
          texture.trim.x = -padding;
          texture.trim.y = -padding;

          texture.orig.width = texture._frame.width - padding * 2;
          texture.orig.height = texture._frame.height - padding * 2;

          // call sprite onTextureUpdate to update scale if _width or _height were set
          this._onTextureUpdate();

          baseTexture.emit("update", baseTexture);

          this.dirty = false;
        };

        /**
         * Renders the object using the WebGL renderer
         *
         * @param {PIXI.WebGLRenderer} renderer - The renderer
         */

        Text.prototype.renderWebGL = function renderWebGL(renderer) {
          if (this.resolution !== renderer.resolution) {
            this.resolution = renderer.resolution;
            this.dirty = true;
          }

          this.updateText(true);

          _Sprite.prototype.renderWebGL.call(this, renderer);
        };

        /**
         * Renders the object using the Canvas renderer
         *
         * @private
         * @param {PIXI.CanvasRenderer} renderer - The renderer
         */

        Text.prototype._renderCanvas = function _renderCanvas(renderer) {
          if (this.resolution !== renderer.resolution) {
            this.resolution = renderer.resolution;
            this.dirty = true;
          }

          this.updateText(true);

          _Sprite.prototype._renderCanvas.call(this, renderer);
        };

        /**
         * Gets the local bounds of the text object.
         *
         * @param {Rectangle} rect - The output rectangle.
         * @return {Rectangle} The bounds.
         */

        Text.prototype.getLocalBounds = function getLocalBounds(rect) {
          this.updateText(true);

          return _Sprite.prototype.getLocalBounds.call(this, rect);
        };

        /**
         * calculates the bounds of the Text as a rectangle. The bounds calculation takes the worldTransform into account.
         */

        Text.prototype._calculateBounds = function _calculateBounds() {
          this.updateText(true);
          this.calculateVertices();
          // if we have already done this on THIS frame.
          this._bounds.addQuad(this.vertexData);
        };

        /**
         * Method to be called upon a TextStyle change.
         * @private
         */

        Text.prototype._onStyleChange = function _onStyleChange() {
          this.dirty = true;
        };

        /**
         * Generates the fill style. Can automatically generate a gradient based on the fill style being an array
         *
         * @private
         * @param {object} style - The style.
         * @param {string[]} lines - The lines of text.
         * @return {string|number|CanvasGradient} The fill style
         */

        Text.prototype._generateFillStyle = function _generateFillStyle(style, lines) {
          if (!Array.isArray(style.fill)) {
            return style.fill;
          }

          // cocoon on canvas+ cannot generate textures, so use the first colour instead
          if (navigator.isCocoonJS) {
            return style.fill[0];
          }

          // the gradient will be evenly spaced out according to how large the array is.
          // ['#FF0000', '#00FF00', '#0000FF'] would created stops at 0.25, 0.5 and 0.75
          var gradient = void 0;
          var totalIterations = void 0;
          var currentIteration = void 0;
          var stop = void 0;

          var width = this.canvas.width / this.resolution;
          var height = this.canvas.height / this.resolution;

          // make a copy of the style settings, so we can manipulate them later
          var fill = style.fill.slice();
          var fillGradientStops = style.fillGradientStops.slice();

          // wanting to evenly distribute the fills. So an array of 4 colours should give fills of 0.25, 0.5 and 0.75
          if (!fillGradientStops.length) {
            var lengthPlus1 = fill.length + 1;

            for (var i = 1; i < lengthPlus1; ++i) {
              fillGradientStops.push(i / lengthPlus1);
            }
          }

          // stop the bleeding of the last gradient on the line above to the top gradient of the this line
          // by hard defining the first gradient colour at point 0, and last gradient colour at point 1
          fill.unshift(style.fill[0]);
          fillGradientStops.unshift(0);

          fill.push(style.fill[style.fill.length - 1]);
          fillGradientStops.push(1);

          if (style.fillGradientType === _const.TEXT_GRADIENT.LINEAR_VERTICAL) {
            // start the gradient at the top center of the canvas, and end at the bottom middle of the canvas
            gradient = this.context.createLinearGradient(width / 2, 0, width / 2, height);

            // we need to repeat the gradient so that each individual line of text has the same vertical gradient effect
            // ['#FF0000', '#00FF00', '#0000FF'] over 2 lines would create stops at 0.125, 0.25, 0.375, 0.625, 0.75, 0.875
            totalIterations = (fill.length + 1) * lines.length;
            currentIteration = 0;
            for (var _i2 = 0; _i2 < lines.length; _i2++) {
              currentIteration += 1;
              for (var j = 0; j < fill.length; j++) {
                if (typeof fillGradientStops[j] === "number") {
                  stop = fillGradientStops[j] / lines.length + _i2 / lines.length;
                } else {
                  stop = currentIteration / totalIterations;
                }
                gradient.addColorStop(stop, fill[j]);
                currentIteration++;
              }
            }
          } else {
            // start the gradient at the center left of the canvas, and end at the center right of the canvas
            gradient = this.context.createLinearGradient(0, height / 2, width, height / 2);

            // can just evenly space out the gradients in this case, as multiple lines makes no difference
            // to an even left to right gradient
            totalIterations = fill.length + 1;
            currentIteration = 1;

            for (var _i3 = 0; _i3 < fill.length; _i3++) {
              if (typeof fillGradientStops[_i3] === "number") {
                stop = fillGradientStops[_i3];
              } else {
                stop = currentIteration / totalIterations;
              }
              gradient.addColorStop(stop, fill[_i3]);
              currentIteration++;
            }
          }

          return gradient;
        };

        /**
         * Destroys this text object.
         * Note* Unlike a Sprite, a Text object will automatically destroy its baseTexture and texture as
         * the majority of the time the texture will not be shared with any other Sprites.
         *
         * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
         *  have been set to that value
         * @param {boolean} [options.children=false] - if set to true, all the children will have their
         *  destroy method called as well. 'options' will be passed on to those calls.
         * @param {boolean} [options.texture=true] - Should it destroy the current texture of the sprite as well
         * @param {boolean} [options.baseTexture=true] - Should it destroy the base texture of the sprite as well
         */

        Text.prototype.destroy = function destroy(options) {
          if (typeof options === "boolean") {
            options = { children: options };
          }

          options = Object.assign({}, defaultDestroyOptions, options);

          _Sprite.prototype.destroy.call(this, options);

          // make sure to reset the the context and canvas.. dont want this hanging around in memory!
          this.context = null;
          this.canvas = null;

          this._style = null;
        };

        /**
         * The width of the Text, setting this will actually modify the scale to achieve the value set
         *
         * @member {number}
         */

        _createClass(Text, [
          {
            key: "width",
            get: function get() {
              this.updateText(true);

              return Math.abs(this.scale.x) * this._texture.orig.width;
            },
            set: function set(
              value // eslint-disable-line require-jsdoc
            ) {
              this.updateText(true);

              var s = (0, _utils.sign)(this.scale.x) || 1;

              this.scale.x = (s * value) / this._texture.orig.width;
              this._width = value;
            },

            /**
             * The height of the Text, setting this will actually modify the scale to achieve the value set
             *
             * @member {number}
             */
          },
          {
            key: "height",
            get: function get() {
              this.updateText(true);

              return Math.abs(this.scale.y) * this._texture.orig.height;
            },
            set: function set(
              value // eslint-disable-line require-jsdoc
            ) {
              this.updateText(true);

              var s = (0, _utils.sign)(this.scale.y) || 1;

              this.scale.y = (s * value) / this._texture.orig.height;
              this._height = value;
            },

            /**
             * Set the style of the text. Set up an event listener to listen for changes on the style
             * object and mark the text as dirty.
             *
             * @member {object|PIXI.TextStyle}
             */
          },
          {
            key: "style",
            get: function get() {
              return this._style;
            },
            set: function set(
              style // eslint-disable-line require-jsdoc
            ) {
              style = style || {};

              if (style instanceof _TextStyle2.default) {
                this._style = style;
              } else {
                this._style = new _TextStyle2.default(style);
              }

              this.localStyleID = -1;
              this.dirty = true;
            },

            /**
             * Set the copy for the text object. To split a line you can use '\n'.
             *
             * @member {string}
             */
          },
          {
            key: "text",
            get: function get() {
              return this._text;
            },
            set: function set(
              text // eslint-disable-line require-jsdoc
            ) {
              text = String(text === "" || text === null || text === undefined ? " " : text);

              if (this._text === text) {
                return;
              }
              this._text = text;
              this.dirty = true;
            },
          },
        ]);

        return Text;
      })(_Sprite3.default);

      exports.default = Text;
      //# sourceMappingURL=Text.js.map

      /***/
    },
    /* 519 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;
      exports.default = trimCanvas;
      /**
       * Trim transparent borders from a canvas
       *
       * @memberof PIXI
       * @function trimCanvas
       * @private
       * @param {HTMLCanvasElement} canvas - the canvas to trim
       * @returns {object} Trim data
       */
      function trimCanvas(canvas) {
        // https://gist.github.com/remy/784508

        var width = canvas.width;
        var height = canvas.height;

        var context = canvas.getContext("2d");
        var imageData = context.getImageData(0, 0, width, height);
        var pixels = imageData.data;
        var len = pixels.length;

        var bound = {
          top: null,
          left: null,
          right: null,
          bottom: null,
        };
        var data = null;
        var i = void 0;
        var x = void 0;
        var y = void 0;

        for (i = 0; i < len; i += 4) {
          if (pixels[i + 3] !== 0) {
            x = (i / 4) % width;
            y = ~~(i / 4 / width);

            if (bound.top === null) {
              bound.top = y;
            }

            if (bound.left === null) {
              bound.left = x;
            } else if (x < bound.left) {
              bound.left = x;
            }

            if (bound.right === null) {
              bound.right = x + 1;
            } else if (bound.right < x) {
              bound.right = x + 1;
            }

            if (bound.bottom === null) {
              bound.bottom = y;
            } else if (bound.bottom < y) {
              bound.bottom = y;
            }
          }
        }

        if (bound.top !== null) {
          width = bound.right - bound.left;
          height = bound.bottom - bound.top + 1;
          data = context.getImageData(bound.left, bound.top, width, height);
        }

        return {
          height: height,
          width: width,
          data: data,
        };
      }
      //# sourceMappingURL=trimCanvas.js.map

      /***/
    },
    /* 520 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      var _Container2 = __webpack_require__(358);

      var _Container3 = _interopRequireDefault(_Container2);

      var _RenderTexture = __webpack_require__(384);

      var _RenderTexture2 = _interopRequireDefault(_RenderTexture);

      var _Texture = __webpack_require__(353);

      var _Texture2 = _interopRequireDefault(_Texture);

      var _GraphicsData = __webpack_require__(421);

      var _GraphicsData2 = _interopRequireDefault(_GraphicsData);

      var _Sprite = __webpack_require__(381);

      var _Sprite2 = _interopRequireDefault(_Sprite);

      var _math = __webpack_require__(348);

      var _utils = __webpack_require__(345);

      var _const = __webpack_require__(343);

      var _Bounds = __webpack_require__(377);

      var _Bounds2 = _interopRequireDefault(_Bounds);

      var _bezierCurveTo2 = __webpack_require__(521);

      var _bezierCurveTo3 = _interopRequireDefault(_bezierCurveTo2);

      var _CanvasRenderer = __webpack_require__(359);

      var _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: { value: subClass, enumerable: false, writable: true, configurable: true },
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass);
      }

      var canvasRenderer = void 0;
      var tempMatrix = new _math.Matrix();
      var tempPoint = new _math.Point();
      var tempColor1 = new Float32Array(4);
      var tempColor2 = new Float32Array(4);

      /**
       * The Graphics class contains methods used to draw primitive shapes such as lines, circles and
       * rectangles to the display, and to color and fill them.
       *
       * @class
       * @extends PIXI.Container
       * @memberof PIXI
       */

      var Graphics = (function (_Container) {
        _inherits(Graphics, _Container);

        /**
         *
         * @param {boolean} [nativeLines=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP
         */
        function Graphics() {
          var nativeLines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

          _classCallCheck(this, Graphics);

          /**
           * The alpha value used when filling the Graphics object.
           *
           * @member {number}
           * @default 1
           */
          var _this = _possibleConstructorReturn(this, _Container.call(this));

          _this.fillAlpha = 1;

          /**
           * The width (thickness) of any lines drawn.
           *
           * @member {number}
           * @default 0
           */
          _this.lineWidth = 0;

          /**
           * If true the lines will be draw using LINES instead of TRIANGLE_STRIP
           *
           * @member {boolean}
           */
          _this.nativeLines = nativeLines;

          /**
           * The color of any lines drawn.
           *
           * @member {string}
           * @default 0
           */
          _this.lineColor = 0;

          /**
           * The alignment of any lines drawn (0.5 = middle, 1 = outter, 0 = inner).
           *
           * @member {number}
           * @default 0.5
           */
          _this.lineAlignment = 0.5;

          /**
           * Graphics data
           *
           * @member {PIXI.GraphicsData[]}
           * @private
           */
          _this.graphicsData = [];

          /**
           * The tint applied to the graphic shape. This is a hex value. Apply a value of 0xFFFFFF to
           * reset the tint.
           *
           * @member {number}
           * @default 0xFFFFFF
           */
          _this.tint = 0xffffff;

          /**
           * The previous tint applied to the graphic shape. Used to compare to the current tint and
           * check if theres change.
           *
           * @member {number}
           * @private
           * @default 0xFFFFFF
           */
          _this._prevTint = 0xffffff;

          /**
           * The blend mode to be applied to the graphic shape. Apply a value of
           * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
           *
           * @member {number}
           * @default PIXI.BLEND_MODES.NORMAL;
           * @see PIXI.BLEND_MODES
           */
          _this.blendMode = _const.BLEND_MODES.NORMAL;

          /**
           * Current path
           *
           * @member {PIXI.GraphicsData}
           * @private
           */
          _this.currentPath = null;

          /**
           * Array containing some WebGL-related properties used by the WebGL renderer.
           *
           * @member {object<number, object>}
           * @private
           */
          // TODO - _webgl should use a prototype object, not a random undocumented object...
          _this._webGL = {};

          /**
           * Whether this shape is being used as a mask.
           *
           * @member {boolean}
           */
          _this.isMask = false;

          /**
           * The bounds' padding used for bounds calculation.
           *
           * @member {number}
           */
          _this.boundsPadding = 0;

          /**
           * A cache of the local bounds to prevent recalculation.
           *
           * @member {PIXI.Rectangle}
           * @private
           */
          _this._localBounds = new _Bounds2.default();

          /**
           * Used to detect if the graphics object has changed. If this is set to true then the graphics
           * object will be recalculated.
           *
           * @member {boolean}
           * @private
           */
          _this.dirty = 0;

          /**
           * Used to detect if we need to do a fast rect check using the id compare method
           * @type {Number}
           */
          _this.fastRectDirty = -1;

          /**
           * Used to detect if we clear the graphics webGL data
           * @type {Number}
           */
          _this.clearDirty = 0;

          /**
           * Used to detect if we we need to recalculate local bounds
           * @type {Number}
           */
          _this.boundsDirty = -1;

          /**
           * Used to detect if the cached sprite object needs to be updated.
           *
           * @member {boolean}
           * @private
           */
          _this.cachedSpriteDirty = false;

          _this._spriteRect = null;
          _this._fastRect = false;

          _this._prevRectTint = null;
          _this._prevRectFillColor = null;

          /**
           * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.
           * This is useful if your graphics element does not change often, as it will speed up the rendering
           * of the object in exchange for taking up texture memory. It is also useful if you need the graphics
           * object to be anti-aliased, because it will be rendered using canvas. This is not recommended if
           * you are constantly redrawing the graphics element.
           *
           * @name cacheAsBitmap
           * @member {boolean}
           * @memberof PIXI.Graphics#
           * @default false
           */
          return _this;
        }

        /**
         * Creates a new Graphics object with the same values as this one.
         * Note that the only the properties of the object are cloned, not its transform (position,scale,etc)
         *
         * @return {PIXI.Graphics} A clone of the graphics object
         */

        Graphics.prototype.clone = function clone() {
          var clone = new Graphics();

          clone.renderable = this.renderable;
          clone.fillAlpha = this.fillAlpha;
          clone.lineWidth = this.lineWidth;
          clone.lineColor = this.lineColor;
          clone.lineAlignment = this.lineAlignment;
          clone.tint = this.tint;
          clone.blendMode = this.blendMode;
          clone.isMask = this.isMask;
          clone.boundsPadding = this.boundsPadding;
          clone.dirty = 0;
          clone.cachedSpriteDirty = this.cachedSpriteDirty;

          // copy graphics data
          for (var i = 0; i < this.graphicsData.length; ++i) {
            clone.graphicsData.push(this.graphicsData[i].clone());
          }

          clone.currentPath = clone.graphicsData[clone.graphicsData.length - 1];

          clone.updateLocalBounds();

          return clone;
        };

        /**
         * Calculate length of quadratic curve
         * @see {@link http://www.malczak.linuxpl.com/blog/quadratic-bezier-curve-length/}
         * for the detailed explanation of math behind this.
         *
         * @private
         * @param {number} fromX - x-coordinate of curve start point
         * @param {number} fromY - y-coordinate of curve start point
         * @param {number} cpX - x-coordinate of curve control point
         * @param {number} cpY - y-coordinate of curve control point
         * @param {number} toX - x-coordinate of curve end point
         * @param {number} toY - y-coordinate of curve end point
         * @return {number} Length of quadratic curve
         */

        Graphics.prototype._quadraticCurveLength = function _quadraticCurveLength(fromX, fromY, cpX, cpY, toX, toY) {
          var ax = fromX - 2.0 * cpX + toX;
          var ay = fromY - 2.0 * cpY + toY;
          var bx = 2.0 * cpX - 2.0 * fromX;
          var by = 2.0 * cpY - 2.0 * fromY;
          var a = 4.0 * (ax * ax + ay * ay);
          var b = 4.0 * (ax * bx + ay * by);
          var c = bx * bx + by * by;

          var s = 2.0 * Math.sqrt(a + b + c);
          var a2 = Math.sqrt(a);
          var a32 = 2.0 * a * a2;
          var c2 = 2.0 * Math.sqrt(c);
          var ba = b / a2;

          return (a32 * s + a2 * b * (s - c2) + (4.0 * c * a - b * b) * Math.log((2.0 * a2 + ba + s) / (ba + c2))) / (4.0 * a32);
        };

        /**
         * Calculate length of bezier curve.
         * Analytical solution is impossible, since it involves an integral that does not integrate in general.
         * Therefore numerical solution is used.
         *
         * @private
         * @param {number} fromX - Starting point x
         * @param {number} fromY - Starting point y
         * @param {number} cpX - Control point x
         * @param {number} cpY - Control point y
         * @param {number} cpX2 - Second Control point x
         * @param {number} cpY2 - Second Control point y
         * @param {number} toX - Destination point x
         * @param {number} toY - Destination point y
         * @return {number} Length of bezier curve
         */

        Graphics.prototype._bezierCurveLength = function _bezierCurveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {
          var n = 10;
          var result = 0.0;
          var t = 0.0;
          var t2 = 0.0;
          var t3 = 0.0;
          var nt = 0.0;
          var nt2 = 0.0;
          var nt3 = 0.0;
          var x = 0.0;
          var y = 0.0;
          var dx = 0.0;
          var dy = 0.0;
          var prevX = fromX;
          var prevY = fromY;

          for (var i = 1; i <= n; ++i) {
            t = i / n;
            t2 = t * t;
            t3 = t2 * t;
            nt = 1.0 - t;
            nt2 = nt * nt;
            nt3 = nt2 * nt;

            x = nt3 * fromX + 3.0 * nt2 * t * cpX + 3.0 * nt * t2 * cpX2 + t3 * toX;
            y = nt3 * fromY + 3.0 * nt2 * t * cpY + 3 * nt * t2 * cpY2 + t3 * toY;
            dx = prevX - x;
            dy = prevY - y;
            prevX = x;
            prevY = y;

            result += Math.sqrt(dx * dx + dy * dy);
          }

          return result;
        };

        /**
         * Calculate number of segments for the curve based on its length to ensure its smoothness.
         *
         * @private
         * @param {number} length - length of curve
         * @return {number} Number of segments
         */

        Graphics.prototype._segmentsCount = function _segmentsCount(length) {
          var result = Math.ceil(length / Graphics.CURVES.maxLength);

          if (result < Graphics.CURVES.minSegments) {
            result = Graphics.CURVES.minSegments;
          } else if (result > Graphics.CURVES.maxSegments) {
            result = Graphics.CURVES.maxSegments;
          }

          return result;
        };

        /**
         * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo()
         * method or the drawCircle() method.
         *
         * @param {number} [lineWidth=0] - width of the line to draw, will update the objects stored style
         * @param {number} [color=0] - color of the line to draw, will update the objects stored style
         * @param {number} [alpha=1] - alpha of the line to draw, will update the objects stored style
         * @param {number} [alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
         * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
         */

        Graphics.prototype.lineStyle = function lineStyle() {
          var lineWidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
          var color = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          var alpha = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
          var alignment = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.5;

          this.lineWidth = lineWidth;
          this.lineColor = color;
          this.lineAlpha = alpha;
          this.lineAlignment = alignment;

          if (this.currentPath) {
            if (this.currentPath.shape.points.length) {
              // halfway through a line? start a new one!
              var shape = new _math.Polygon(this.currentPath.shape.points.slice(-2));

              shape.closed = false;

              this.drawShape(shape);
            } else {
              // otherwise its empty so lets just set the line properties
              this.currentPath.lineWidth = this.lineWidth;
              this.currentPath.lineColor = this.lineColor;
              this.currentPath.lineAlpha = this.lineAlpha;
              this.currentPath.lineAlignment = this.lineAlignment;
            }
          }

          return this;
        };

        /**
         * Moves the current drawing position to x, y.
         *
         * @param {number} x - the X coordinate to move to
         * @param {number} y - the Y coordinate to move to
         * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
         */

        Graphics.prototype.moveTo = function moveTo(x, y) {
          var shape = new _math.Polygon([x, y]);

          shape.closed = false;
          this.drawShape(shape);

          return this;
        };

        /**
         * Draws a line using the current line style from the current drawing position to (x, y);
         * The current drawing position is then set to (x, y).
         *
         * @param {number} x - the X coordinate to draw to
         * @param {number} y - the Y coordinate to draw to
         * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
         */

        Graphics.prototype.lineTo = function lineTo(x, y) {
          var points = this.currentPath.shape.points;

          var fromX = points[points.length - 2];
          var fromY = points[points.length - 1];

          if (fromX !== x || fromY !== y) {
            points.push(x, y);
            this.dirty++;
          }

          return this;
        };

        /**
         * Calculate the points for a quadratic bezier curve and then draws it.
         * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
         *
         * @param {number} cpX - Control point x
         * @param {number} cpY - Control point y
         * @param {number} toX - Destination point x
         * @param {number} toY - Destination point y
         * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
         */

        Graphics.prototype.quadraticCurveTo = function quadraticCurveTo(cpX, cpY, toX, toY) {
          if (this.currentPath) {
            if (this.currentPath.shape.points.length === 0) {
              this.currentPath.shape.points = [0, 0];
            }
          } else {
            this.moveTo(0, 0);
          }

          var points = this.currentPath.shape.points;
          var xa = 0;
          var ya = 0;

          if (points.length === 0) {
            this.moveTo(0, 0);
          }

          var fromX = points[points.length - 2];
          var fromY = points[points.length - 1];
          var n = Graphics.CURVES.adaptive ? this._segmentsCount(this._quadraticCurveLength(fromX, fromY, cpX, cpY, toX, toY)) : 20;

          for (var i = 1; i <= n; ++i) {
            var j = i / n;

            xa = fromX + (cpX - fromX) * j;
            ya = fromY + (cpY - fromY) * j;

            points.push(xa + (cpX + (toX - cpX) * j - xa) * j, ya + (cpY + (toY - cpY) * j - ya) * j);
          }

          this.dirty++;

          return this;
        };

        /**
         * Calculate the points for a bezier curve and then draws it.
         *
         * @param {number} cpX - Control point x
         * @param {number} cpY - Control point y
         * @param {number} cpX2 - Second Control point x
         * @param {number} cpY2 - Second Control point y
         * @param {number} toX - Destination point x
         * @param {number} toY - Destination point y
         * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
         */

        Graphics.prototype.bezierCurveTo = function bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {
          if (this.currentPath) {
            if (this.currentPath.shape.points.length === 0) {
              this.currentPath.shape.points = [0, 0];
            }
          } else {
            this.moveTo(0, 0);
          }

          var points = this.currentPath.shape.points;

          var fromX = points[points.length - 2];
          var fromY = points[points.length - 1];

          points.length -= 2;

          var n = Graphics.CURVES.adaptive ? this._segmentsCount(this._bezierCurveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY)) : 20;

          (0, _bezierCurveTo3.default)(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY, n, points);

          this.dirty++;

          return this;
        };

        /**
         * The arcTo() method creates an arc/curve between two tangents on the canvas.
         *
         * "borrowed" from https://code.google.com/p/fxcanvas/ - thanks google!
         *
         * @param {number} x1 - The x-coordinate of the beginning of the arc
         * @param {number} y1 - The y-coordinate of the beginning of the arc
         * @param {number} x2 - The x-coordinate of the end of the arc
         * @param {number} y2 - The y-coordinate of the end of the arc
         * @param {number} radius - The radius of the arc
         * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
         */

        Graphics.prototype.arcTo = function arcTo(x1, y1, x2, y2, radius) {
          if (this.currentPath) {
            if (this.currentPath.shape.points.length === 0) {
              this.currentPath.shape.points.push(x1, y1);
            }
          } else {
            this.moveTo(x1, y1);
          }

          var points = this.currentPath.shape.points;
          var fromX = points[points.length - 2];
          var fromY = points[points.length - 1];
          var a1 = fromY - y1;
          var b1 = fromX - x1;
          var a2 = y2 - y1;
          var b2 = x2 - x1;
          var mm = Math.abs(a1 * b2 - b1 * a2);

          if (mm < 1.0e-8 || radius === 0) {
            if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
              points.push(x1, y1);
            }
          } else {
            var dd = a1 * a1 + b1 * b1;
            var cc = a2 * a2 + b2 * b2;
            var tt = a1 * a2 + b1 * b2;
            var k1 = (radius * Math.sqrt(dd)) / mm;
            var k2 = (radius * Math.sqrt(cc)) / mm;
            var j1 = (k1 * tt) / dd;
            var j2 = (k2 * tt) / cc;
            var cx = k1 * b2 + k2 * b1;
            var cy = k1 * a2 + k2 * a1;
            var px = b1 * (k2 + j1);
            var py = a1 * (k2 + j1);
            var qx = b2 * (k1 + j2);
            var qy = a2 * (k1 + j2);
            var startAngle = Math.atan2(py - cy, px - cx);
            var endAngle = Math.atan2(qy - cy, qx - cx);

            this.arc(cx + x1, cy + y1, radius, startAngle, endAngle, b1 * a2 > b2 * a1);
          }

          this.dirty++;

          return this;
        };

        /**
         * The arc method creates an arc/curve (used to create circles, or parts of circles).
         *
         * @param {number} cx - The x-coordinate of the center of the circle
         * @param {number} cy - The y-coordinate of the center of the circle
         * @param {number} radius - The radius of the circle
         * @param {number} startAngle - The starting angle, in radians (0 is at the 3 o'clock position
         *  of the arc's circle)
         * @param {number} endAngle - The ending angle, in radians
         * @param {boolean} [anticlockwise=false] - Specifies whether the drawing should be
         *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true
         *  indicates counter-clockwise.
         * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
         */

        Graphics.prototype.arc = function arc(cx, cy, radius, startAngle, endAngle) {
          var anticlockwise = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

          if (startAngle === endAngle) {
            return this;
          }

          if (!anticlockwise && endAngle <= startAngle) {
            endAngle += _const.PI_2;
          } else if (anticlockwise && startAngle <= endAngle) {
            startAngle += _const.PI_2;
          }

          var sweep = endAngle - startAngle;
          var segs = Graphics.CURVES.adaptive ? this._segmentsCount(Math.abs(sweep) * radius) : Math.ceil(Math.abs(sweep) / _const.PI_2) * 40;

          if (sweep === 0) {
            return this;
          }

          var startX = cx + Math.cos(startAngle) * radius;
          var startY = cy + Math.sin(startAngle) * radius;

          // If the currentPath exists, take its points. Otherwise call `moveTo` to start a path.
          var points = this.currentPath ? this.currentPath.shape.points : null;

          if (points) {
            // We check how far our start is from the last existing point
            var xDiff = Math.abs(points[points.length - 2] - startX);
            var yDiff = Math.abs(points[points.length - 1] - startY);

            if (xDiff < 0.001 && yDiff < 0.001) {
              // If the point is very close, we don't add it, since this would lead to artifacts
              // during tesselation due to floating point imprecision.
            } else {
              points.push(startX, startY);
            }
          } else {
            this.moveTo(startX, startY);
            points = this.currentPath.shape.points;
          }

          var theta = sweep / (segs * 2);
          var theta2 = theta * 2;

          var cTheta = Math.cos(theta);
          var sTheta = Math.sin(theta);

          var segMinus = segs - 1;

          var remainder = (segMinus % 1) / segMinus;

          for (var i = 0; i <= segMinus; ++i) {
            var real = i + remainder * i;

            var angle = theta + startAngle + theta2 * real;

            var c = Math.cos(angle);
            var s = -Math.sin(angle);

            points.push((cTheta * c + sTheta * s) * radius + cx, (cTheta * -s + sTheta * c) * radius + cy);
          }

          this.dirty++;

          return this;
        };

        /**
         * Specifies a simple one-color fill that subsequent calls to other Graphics methods
         * (such as lineTo() or drawCircle()) use when drawing.
         *
         * @param {number} [color=0] - the color of the fill
         * @param {number} [alpha=1] - the alpha of the fill
         * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
         */

        Graphics.prototype.beginFill = function beginFill() {
          var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
          var alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

          this.filling = true;
          this.fillColor = color;
          this.fillAlpha = alpha;

          if (this.currentPath) {
            if (this.currentPath.shape.points.length <= 2) {
              this.currentPath.fill = this.filling;
              this.currentPath.fillColor = this.fillColor;
              this.currentPath.fillAlpha = this.fillAlpha;
            }
          }

          return this;
        };

        /**
         * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.
         *
         * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
         */

        Graphics.prototype.endFill = function endFill() {
          this.filling = false;
          this.fillColor = null;
          this.fillAlpha = 1;

          return this;
        };

        /**
         *
         * @param {number} x - The X coord of the top-left of the rectangle
         * @param {number} y - The Y coord of the top-left of the rectangle
         * @param {number} width - The width of the rectangle
         * @param {number} height - The height of the rectangle
         * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
         */

        Graphics.prototype.drawRect = function drawRect(x, y, width, height) {
          this.drawShape(new _math.Rectangle(x, y, width, height));

          return this;
        };

        /**
         *
         * @param {number} x - The X coord of the top-left of the rectangle
         * @param {number} y - The Y coord of the top-left of the rectangle
         * @param {number} width - The width of the rectangle
         * @param {number} height - The height of the rectangle
         * @param {number} radius - Radius of the rectangle corners
         * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
         */

        Graphics.prototype.drawRoundedRect = function drawRoundedRect(x, y, width, height, radius) {
          this.drawShape(new _math.RoundedRectangle(x, y, width, height, radius));

          return this;
        };

        /**
         * Draws a circle.
         *
         * @param {number} x - The X coordinate of the center of the circle
         * @param {number} y - The Y coordinate of the center of the circle
         * @param {number} radius - The radius of the circle
         * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
         */

        Graphics.prototype.drawCircle = function drawCircle(x, y, radius) {
          this.drawShape(new _math.Circle(x, y, radius));

          return this;
        };

        /**
         * Draws an ellipse.
         *
         * @param {number} x - The X coordinate of the center of the ellipse
         * @param {number} y - The Y coordinate of the center of the ellipse
         * @param {number} width - The half width of the ellipse
         * @param {number} height - The half height of the ellipse
         * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
         */

        Graphics.prototype.drawEllipse = function drawEllipse(x, y, width, height) {
          this.drawShape(new _math.Ellipse(x, y, width, height));

          return this;
        };

        /**
         * Draws a polygon using the given path.
         *
         * @param {number[]|PIXI.Point[]|PIXI.Polygon} path - The path data used to construct the polygon.
         * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
         */

        Graphics.prototype.drawPolygon = function drawPolygon(path) {
          // prevents an argument assignment deopt
          // see section 3.1: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
          var points = path;

          var closed = true;

          if (points instanceof _math.Polygon) {
            closed = points.closed;
            points = points.points;
          }

          if (!Array.isArray(points)) {
            // prevents an argument leak deopt
            // see section 3.2: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
            points = new Array(arguments.length);

            for (var i = 0; i < points.length; ++i) {
              points[i] = arguments[i]; // eslint-disable-line prefer-rest-params
            }
          }

          var shape = new _math.Polygon(points);

          shape.closed = closed;

          this.drawShape(shape);

          return this;
        };

        /**
         * Draw a star shape with an abitrary number of points.
         *
         * @param {number} x - Center X position of the star
         * @param {number} y - Center Y position of the star
         * @param {number} points - The number of points of the star, must be > 1
         * @param {number} radius - The outer radius of the star
         * @param {number} [innerRadius] - The inner radius between points, default half `radius`
         * @param {number} [rotation=0] - The rotation of the star in radians, where 0 is vertical
         * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
         */

        Graphics.prototype.drawStar = function drawStar(x, y, points, radius, innerRadius) {
          var rotation = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

          innerRadius = innerRadius || radius / 2;

          var startAngle = (-1 * Math.PI) / 2 + rotation;
          var len = points * 2;
          var delta = _const.PI_2 / len;
          var polygon = [];

          for (var i = 0; i < len; i++) {
            var r = i % 2 ? innerRadius : radius;
            var angle = i * delta + startAngle;

            polygon.push(x + r * Math.cos(angle), y + r * Math.sin(angle));
          }

          return this.drawPolygon(polygon);
        };

        /**
         * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.
         *
         * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
         */

        Graphics.prototype.clear = function clear() {
          if (this.lineWidth || this.filling || this.graphicsData.length > 0) {
            this.lineWidth = 0;
            this.lineAlignment = 0.5;

            this.filling = false;

            this.boundsDirty = -1;
            this.canvasTintDirty = -1;
            this.dirty++;
            this.clearDirty++;
            this.graphicsData.length = 0;
          }

          this.currentPath = null;
          this._spriteRect = null;

          return this;
        };

        /**
         * True if graphics consists of one rectangle, and thus, can be drawn like a Sprite and
         * masked with gl.scissor.
         *
         * @returns {boolean} True if only 1 rect.
         */

        Graphics.prototype.isFastRect = function isFastRect() {
          return this.graphicsData.length === 1 && this.graphicsData[0].shape.type === _const.SHAPES.RECT && !this.graphicsData[0].lineWidth;
        };

        /**
         * Renders the object using the WebGL renderer
         *
         * @private
         * @param {PIXI.WebGLRenderer} renderer - The renderer
         */

        Graphics.prototype._renderWebGL = function _renderWebGL(renderer) {
          // if the sprite is not visible or the alpha is 0 then no need to render this element
          if (this.dirty !== this.fastRectDirty) {
            this.fastRectDirty = this.dirty;
            this._fastRect = this.isFastRect();
          }

          // TODO this check can be moved to dirty?
          if (this._fastRect) {
            this._renderSpriteRect(renderer);
          } else {
            renderer.setObjectRenderer(renderer.plugins.graphics);
            renderer.plugins.graphics.render(this);
          }
        };

        /**
         * Renders a sprite rectangle.
         *
         * @private
         * @param {PIXI.WebGLRenderer} renderer - The renderer
         */

        Graphics.prototype._renderSpriteRect = function _renderSpriteRect(renderer) {
          var rect = this.graphicsData[0].shape;

          if (!this._spriteRect) {
            this._spriteRect = new _Sprite2.default(new _Texture2.default(_Texture2.default.WHITE));
          }

          var sprite = this._spriteRect;
          var fillColor = this.graphicsData[0].fillColor;

          if (this.tint === 0xffffff) {
            sprite.tint = fillColor;
          } else if (this.tint !== this._prevRectTint || fillColor !== this._prevRectFillColor) {
            var t1 = tempColor1;
            var t2 = tempColor2;

            (0, _utils.hex2rgb)(fillColor, t1);
            (0, _utils.hex2rgb)(this.tint, t2);

            t1[0] *= t2[0];
            t1[1] *= t2[1];
            t1[2] *= t2[2];

            sprite.tint = (0, _utils.rgb2hex)(t1);

            this._prevRectTint = this.tint;
            this._prevRectFillColor = fillColor;
          }

          sprite.alpha = this.graphicsData[0].fillAlpha;
          sprite.worldAlpha = this.worldAlpha * sprite.alpha;
          sprite.blendMode = this.blendMode;

          sprite._texture._frame.width = rect.width;
          sprite._texture._frame.height = rect.height;

          sprite.transform.worldTransform = this.transform.worldTransform;

          sprite.anchor.set(-rect.x / rect.width, -rect.y / rect.height);
          sprite._onAnchorUpdate();

          sprite._renderWebGL(renderer);
        };

        /**
         * Renders the object using the Canvas renderer
         *
         * @private
         * @param {PIXI.CanvasRenderer} renderer - The renderer
         */

        Graphics.prototype._renderCanvas = function _renderCanvas(renderer) {
          if (this.isMask === true) {
            return;
          }

          renderer.plugins.graphics.render(this);
        };

        /**
         * Retrieves the bounds of the graphic shape as a rectangle object
         *
         * @private
         */

        Graphics.prototype._calculateBounds = function _calculateBounds() {
          if (this.boundsDirty !== this.dirty) {
            this.boundsDirty = this.dirty;
            this.updateLocalBounds();

            this.cachedSpriteDirty = true;
          }

          var lb = this._localBounds;

          this._bounds.addFrame(this.transform, lb.minX, lb.minY, lb.maxX, lb.maxY);
        };

        /**
         * Tests if a point is inside this graphics object
         *
         * @param {PIXI.Point} point - the point to test
         * @return {boolean} the result of the test
         */

        Graphics.prototype.containsPoint = function containsPoint(point) {
          this.worldTransform.applyInverse(point, tempPoint);

          var graphicsData = this.graphicsData;

          for (var i = 0; i < graphicsData.length; ++i) {
            var data = graphicsData[i];

            if (!data.fill) {
              continue;
            }

            // only deal with fills..
            if (data.shape) {
              if (data.shape.contains(tempPoint.x, tempPoint.y)) {
                var hitHole = false;

                if (data.holes) {
                  for (var _i = 0; _i < data.holes.length; _i++) {
                    var hole = data.holes[_i];

                    if (hole.contains(tempPoint.x, tempPoint.y)) {
                      hitHole = true;
                      break;
                    }
                  }
                }

                if (!hitHole) {
                  return true;
                }
              }
            }
          }

          return false;
        };

        /**
         * Update the bounds of the object
         *
         */

        Graphics.prototype.updateLocalBounds = function updateLocalBounds() {
          var minX = Infinity;
          var maxX = -Infinity;

          var minY = Infinity;
          var maxY = -Infinity;

          if (this.graphicsData.length) {
            var shape = 0;
            var x = 0;
            var y = 0;
            var w = 0;
            var h = 0;

            for (var i = 0; i < this.graphicsData.length; i++) {
              var data = this.graphicsData[i];
              var type = data.type;
              var lineWidth = data.lineWidth;
              var lineAlignment = data.lineAlignment;

              var lineOffset = lineWidth * lineAlignment;

              shape = data.shape;

              if (type === _const.SHAPES.RECT || type === _const.SHAPES.RREC) {
                x = shape.x - lineOffset;
                y = shape.y - lineOffset;
                w = shape.width + lineOffset * 2;
                h = shape.height + lineOffset * 2;

                minX = x < minX ? x : minX;
                maxX = x + w > maxX ? x + w : maxX;

                minY = y < minY ? y : minY;
                maxY = y + h > maxY ? y + h : maxY;
              } else if (type === _const.SHAPES.CIRC) {
                x = shape.x;
                y = shape.y;
                w = shape.radius + lineOffset;
                h = shape.radius + lineOffset;

                minX = x - w < minX ? x - w : minX;
                maxX = x + w > maxX ? x + w : maxX;

                minY = y - h < minY ? y - h : minY;
                maxY = y + h > maxY ? y + h : maxY;
              } else if (type === _const.SHAPES.ELIP) {
                x = shape.x;
                y = shape.y;
                w = shape.width + lineOffset;
                h = shape.height + lineOffset;

                minX = x - w < minX ? x - w : minX;
                maxX = x + w > maxX ? x + w : maxX;

                minY = y - h < minY ? y - h : minY;
                maxY = y + h > maxY ? y + h : maxY;
              } else {
                // POLY
                var points = shape.points;
                var x2 = 0;
                var y2 = 0;
                var dx = 0;
                var dy = 0;
                var rw = 0;
                var rh = 0;
                var cx = 0;
                var cy = 0;

                for (var j = 0; j + 2 < points.length; j += 2) {
                  x = points[j];
                  y = points[j + 1];
                  x2 = points[j + 2];
                  y2 = points[j + 3];
                  dx = Math.abs(x2 - x);
                  dy = Math.abs(y2 - y);
                  h = lineOffset * 2;
                  w = Math.sqrt(dx * dx + dy * dy);

                  if (w < 1e-9) {
                    continue;
                  }

                  rw = ((h / w) * dy + dx) / 2;
                  rh = ((h / w) * dx + dy) / 2;
                  cx = (x2 + x) / 2;
                  cy = (y2 + y) / 2;

                  minX = cx - rw < minX ? cx - rw : minX;
                  maxX = cx + rw > maxX ? cx + rw : maxX;

                  minY = cy - rh < minY ? cy - rh : minY;
                  maxY = cy + rh > maxY ? cy + rh : maxY;
                }
              }
            }
          } else {
            minX = 0;
            maxX = 0;
            minY = 0;
            maxY = 0;
          }

          var padding = this.boundsPadding;

          this._localBounds.minX = minX - padding;
          this._localBounds.maxX = maxX + padding;

          this._localBounds.minY = minY - padding;
          this._localBounds.maxY = maxY + padding;
        };

        /**
         * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.
         *
         * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.
         * @return {PIXI.GraphicsData} The generated GraphicsData object.
         */

        Graphics.prototype.drawShape = function drawShape(shape) {
          if (this.currentPath) {
            // check current path!
            if (this.currentPath.shape.points.length <= 2) {
              this.graphicsData.pop();
            }
          }

          this.currentPath = null;

          var data = new _GraphicsData2.default(
            this.lineWidth,
            this.lineColor,
            this.lineAlpha,
            this.fillColor,
            this.fillAlpha,
            this.filling,
            this.nativeLines,
            shape,
            this.lineAlignment
          );

          this.graphicsData.push(data);

          if (data.type === _const.SHAPES.POLY) {
            data.shape.closed = data.shape.closed;
            this.currentPath = data;
          }

          this.dirty++;

          return data;
        };

        /**
         * Generates a canvas texture.
         *
         * @param {number} scaleMode - The scale mode of the texture.
         * @param {number} resolution - The resolution of the texture.
         * @return {PIXI.Texture} The new texture.
         */

        Graphics.prototype.generateCanvasTexture = function generateCanvasTexture(scaleMode) {
          var resolution = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

          var bounds = this.getLocalBounds();

          var canvasBuffer = _RenderTexture2.default.create(bounds.width, bounds.height, scaleMode, resolution);

          if (!canvasRenderer) {
            canvasRenderer = new _CanvasRenderer2.default();
          }

          this.transform.updateLocalTransform();
          this.transform.localTransform.copy(tempMatrix);

          tempMatrix.invert();

          tempMatrix.tx -= bounds.x;
          tempMatrix.ty -= bounds.y;

          canvasRenderer.render(this, canvasBuffer, true, tempMatrix);

          var texture = _Texture2.default.fromCanvas(canvasBuffer.baseTexture._canvasRenderTarget.canvas, scaleMode, "graphics");

          texture.baseTexture.resolution = resolution;
          texture.baseTexture.update();

          return texture;
        };

        /**
         * Closes the current path.
         *
         * @return {PIXI.Graphics} Returns itself.
         */

        Graphics.prototype.closePath = function closePath() {
          // ok so close path assumes next one is a hole!
          var currentPath = this.currentPath;

          if (currentPath && currentPath.shape) {
            currentPath.shape.close();
          }

          return this;
        };

        /**
         * Adds a hole in the current path.
         *
         * @return {PIXI.Graphics} Returns itself.
         */

        Graphics.prototype.addHole = function addHole() {
          // this is a hole!
          var hole = this.graphicsData.pop();

          this.currentPath = this.graphicsData[this.graphicsData.length - 1];

          this.currentPath.addHole(hole.shape);
          this.currentPath = null;

          return this;
        };

        /**
         * Destroys the Graphics object.
         *
         * @param {object|boolean} [options] - Options parameter. A boolean will act as if all
         *  options have been set to that value
         * @param {boolean} [options.children=false] - if set to true, all the children will have
         *  their destroy method called as well. 'options' will be passed on to those calls.
         * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true
         *  Should it destroy the texture of the child sprite
         * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
         *  Should it destroy the base texture of the child sprite
         */

        Graphics.prototype.destroy = function destroy(options) {
          _Container.prototype.destroy.call(this, options);

          // destroy each of the GraphicsData objects
          for (var i = 0; i < this.graphicsData.length; ++i) {
            this.graphicsData[i].destroy();
          }

          // for each webgl data entry, destroy the WebGLGraphicsData
          for (var id in this._webGL) {
            for (var j = 0; j < this._webGL[id].data.length; ++j) {
              this._webGL[id].data[j].destroy();
            }
          }

          if (this._spriteRect) {
            this._spriteRect.destroy();
          }

          this.graphicsData = null;

          this.currentPath = null;
          this._webGL = null;
          this._localBounds = null;
        };

        return Graphics;
      })(_Container3.default);

      exports.default = Graphics;

      Graphics._SPRITE_TEXTURE = null;

      /**
       * Graphics curves resolution settings. If `adaptive` flag is set to `true`,
       * the resolution is calculated based on the curve's length to ensure better visual quality.
       * Adaptive draw works with `bezierCurveTo` and `quadraticCurveTo`.
       *
       * @static
       * @constant
       * @memberof PIXI.Graphics
       * @name CURVES
       * @type {object}
       * @property {boolean} adaptive=false - flag indicating if the resolution should be adaptive
       * @property {number} maxLength=10 - maximal length of a single segment of the curve (if adaptive = false, ignored)
       * @property {number} minSegments=8 - minimal number of segments in the curve (if adaptive = false, ignored)
       * @property {number} maxSegments=2048 - maximal number of segments in the curve (if adaptive = false, ignored)
       */
      Graphics.CURVES = {
        adaptive: false,
        maxLength: 10,
        minSegments: 8,
        maxSegments: 2048,
      };
      //# sourceMappingURL=Graphics.js.map

      /***/
    },
    /* 521 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;
      exports.default = bezierCurveTo;
      /**
       * Calculate the points for a bezier curve and then draws it.
       *
       * Ignored from docs since it is not directly exposed.
       *
       * @ignore
       * @param {number} fromX - Starting point x
       * @param {number} fromY - Starting point y
       * @param {number} cpX - Control point x
       * @param {number} cpY - Control point y
       * @param {number} cpX2 - Second Control point x
       * @param {number} cpY2 - Second Control point y
       * @param {number} toX - Destination point x
       * @param {number} toY - Destination point y
       * @param {number} n - Number of segments approximating the bezier curve
       * @param {number[]} [path=[]] - Path array to push points into
       * @return {number[]} Array of points of the curve
       */
      function bezierCurveTo(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY, n) {
        var path = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : [];

        var dt = 0;
        var dt2 = 0;
        var dt3 = 0;
        var t2 = 0;
        var t3 = 0;

        path.push(fromX, fromY);

        for (var i = 1, j = 0; i <= n; ++i) {
          j = i / n;

          dt = 1 - j;
          dt2 = dt * dt;
          dt3 = dt2 * dt;

          t2 = j * j;
          t3 = t2 * j;

          path.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);
        }

        return path;
      }
      //# sourceMappingURL=bezierCurveTo.js.map

      /***/
    },
    /* 522 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      var _utils = __webpack_require__(345);

      var _const = __webpack_require__(343);

      var _ObjectRenderer2 = __webpack_require__(365);

      var _ObjectRenderer3 = _interopRequireDefault(_ObjectRenderer2);

      var _WebGLRenderer = __webpack_require__(366);

      var _WebGLRenderer2 = _interopRequireDefault(_WebGLRenderer);

      var _WebGLGraphicsData = __webpack_require__(523);

      var _WebGLGraphicsData2 = _interopRequireDefault(_WebGLGraphicsData);

      var _PrimitiveShader = __webpack_require__(524);

      var _PrimitiveShader2 = _interopRequireDefault(_PrimitiveShader);

      var _buildPoly = __webpack_require__(525);

      var _buildPoly2 = _interopRequireDefault(_buildPoly);

      var _buildRectangle = __webpack_require__(526);

      var _buildRectangle2 = _interopRequireDefault(_buildRectangle);

      var _buildRoundedRectangle = __webpack_require__(527);

      var _buildRoundedRectangle2 = _interopRequireDefault(_buildRoundedRectangle);

      var _buildCircle = __webpack_require__(528);

      var _buildCircle2 = _interopRequireDefault(_buildCircle);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: { value: subClass, enumerable: false, writable: true, configurable: true },
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass);
      }

      /**
       * Renders the graphics object.
       *
       * @class
       * @memberof PIXI
       * @extends PIXI.ObjectRenderer
       */
      var GraphicsRenderer = (function (_ObjectRenderer) {
        _inherits(GraphicsRenderer, _ObjectRenderer);

        /**
         * @param {PIXI.WebGLRenderer} renderer - The renderer this object renderer works for.
         */
        function GraphicsRenderer(renderer) {
          _classCallCheck(this, GraphicsRenderer);

          var _this = _possibleConstructorReturn(this, _ObjectRenderer.call(this, renderer));

          _this.graphicsDataPool = [];

          _this.primitiveShader = null;

          _this.gl = renderer.gl;

          // easy access!
          _this.CONTEXT_UID = 0;
          return _this;
        }

        /**
         * Called when there is a WebGL context change
         *
         * @private
         *
         */

        GraphicsRenderer.prototype.onContextChange = function onContextChange() {
          this.gl = this.renderer.gl;
          this.CONTEXT_UID = this.renderer.CONTEXT_UID;
          this.primitiveShader = new _PrimitiveShader2.default(this.gl);
        };

        /**
         * Destroys this renderer.
         *
         */

        GraphicsRenderer.prototype.destroy = function destroy() {
          _ObjectRenderer3.default.prototype.destroy.call(this);

          for (var i = 0; i < this.graphicsDataPool.length; ++i) {
            this.graphicsDataPool[i].destroy();
          }

          this.graphicsDataPool = null;
        };

        /**
         * Renders a graphics object.
         *
         * @param {PIXI.Graphics} graphics - The graphics object to render.
         */

        GraphicsRenderer.prototype.render = function render(graphics) {
          var renderer = this.renderer;
          var gl = renderer.gl;

          var webGLData = void 0;
          var webGL = graphics._webGL[this.CONTEXT_UID];

          if (!webGL || graphics.dirty !== webGL.dirty) {
            this.updateGraphics(graphics);

            webGL = graphics._webGL[this.CONTEXT_UID];
          }

          // This  could be speeded up for sure!
          var shader = this.primitiveShader;

          renderer.bindShader(shader);
          renderer.state.setBlendMode(graphics.blendMode);

          for (var i = 0, n = webGL.data.length; i < n; i++) {
            webGLData = webGL.data[i];
            var shaderTemp = webGLData.shader;

            renderer.bindShader(shaderTemp);
            shaderTemp.uniforms.translationMatrix = graphics.transform.worldTransform.toArray(true);
            shaderTemp.uniforms.tint = (0, _utils.hex2rgb)(graphics.tint);
            shaderTemp.uniforms.alpha = graphics.worldAlpha;

            renderer.bindVao(webGLData.vao);

            if (webGLData.nativeLines) {
              gl.drawArrays(gl.LINES, 0, webGLData.points.length / 6);
            } else {
              webGLData.vao.draw(gl.TRIANGLE_STRIP, webGLData.indices.length);
            }
          }
        };

        /**
         * Updates the graphics object
         *
         * @private
         * @param {PIXI.Graphics} graphics - The graphics object to update
         */

        GraphicsRenderer.prototype.updateGraphics = function updateGraphics(graphics) {
          var gl = this.renderer.gl;

          // get the contexts graphics object
          var webGL = graphics._webGL[this.CONTEXT_UID];

          // if the graphics object does not exist in the webGL context time to create it!
          if (!webGL) {
            webGL = graphics._webGL[this.CONTEXT_UID] = { lastIndex: 0, data: [], gl: gl, clearDirty: -1, dirty: -1 };
          }

          // flag the graphics as not dirty as we are about to update it...
          webGL.dirty = graphics.dirty;

          // if the user cleared the graphics object we will need to clear every object
          if (graphics.clearDirty !== webGL.clearDirty) {
            webGL.clearDirty = graphics.clearDirty;

            // loop through and return all the webGLDatas to the object pool so than can be reused later on
            for (var i = 0; i < webGL.data.length; i++) {
              this.graphicsDataPool.push(webGL.data[i]);
            }

            // clear the array and reset the index..
            webGL.data.length = 0;
            webGL.lastIndex = 0;
          }

          var webGLData = void 0;
          var webGLDataNativeLines = void 0;

          // loop through the graphics datas and construct each one..
          // if the object is a complex fill then the new stencil buffer technique will be used
          // other wise graphics objects will be pushed into a batch..
          for (var _i = webGL.lastIndex; _i < graphics.graphicsData.length; _i++) {
            var data = graphics.graphicsData[_i];

            // TODO - this can be simplified
            webGLData = this.getWebGLData(webGL, 0);

            if (data.nativeLines && data.lineWidth) {
              webGLDataNativeLines = this.getWebGLData(webGL, 0, true);
              webGL.lastIndex++;
            }

            if (data.type === _const.SHAPES.POLY) {
              (0, _buildPoly2.default)(data, webGLData, webGLDataNativeLines);
            }
            if (data.type === _const.SHAPES.RECT) {
              (0, _buildRectangle2.default)(data, webGLData, webGLDataNativeLines);
            } else if (data.type === _const.SHAPES.CIRC || data.type === _const.SHAPES.ELIP) {
              (0, _buildCircle2.default)(data, webGLData, webGLDataNativeLines);
            } else if (data.type === _const.SHAPES.RREC) {
              (0, _buildRoundedRectangle2.default)(data, webGLData, webGLDataNativeLines);
            }

            webGL.lastIndex++;
          }

          this.renderer.bindVao(null);

          // upload all the dirty data...
          for (var _i2 = 0; _i2 < webGL.data.length; _i2++) {
            webGLData = webGL.data[_i2];

            if (webGLData.dirty) {
              webGLData.upload();
            }
          }
        };

        /**
         *
         * @private
         * @param {WebGLRenderingContext} gl - the current WebGL drawing context
         * @param {number} type - TODO @Alvin
         * @param {number} nativeLines - indicate whether the webGLData use for nativeLines.
         * @return {*} TODO
         */

        GraphicsRenderer.prototype.getWebGLData = function getWebGLData(gl, type, nativeLines) {
          var webGLData = gl.data[gl.data.length - 1];

          if (!webGLData || webGLData.nativeLines !== nativeLines || webGLData.points.length > 320000) {
            webGLData =
              this.graphicsDataPool.pop() ||
              new _WebGLGraphicsData2.default(this.renderer.gl, this.primitiveShader, this.renderer.state.attribsState);
            webGLData.nativeLines = nativeLines;
            webGLData.reset(type);
            gl.data.push(webGLData);
          }

          webGLData.dirty = true;

          return webGLData;
        };

        return GraphicsRenderer;
      })(_ObjectRenderer3.default);

      exports.default = GraphicsRenderer;

      _WebGLRenderer2.default.registerPlugin("graphics", GraphicsRenderer);
      //# sourceMappingURL=GraphicsRenderer.js.map

      /***/
    },
    /* 523 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      var _pixiGlCore = __webpack_require__(350);

      var _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      /**
       * An object containing WebGL specific properties to be used by the WebGL renderer
       *
       * @class
       * @private
       * @memberof PIXI
       */
      var WebGLGraphicsData = (function () {
        /**
         * @param {WebGLRenderingContext} gl - The current WebGL drawing context
         * @param {PIXI.Shader} shader - The shader
         * @param {object} attribsState - The state for the VAO
         */
        function WebGLGraphicsData(gl, shader, attribsState) {
          _classCallCheck(this, WebGLGraphicsData);

          /**
           * The current WebGL drawing context
           *
           * @member {WebGLRenderingContext}
           */
          this.gl = gl;

          // TODO does this need to be split before uploading??
          /**
           * An array of color components (r,g,b)
           * @member {number[]}
           */
          this.color = [0, 0, 0]; // color split!

          /**
           * An array of points to draw
           * @member {PIXI.Point[]}
           */
          this.points = [];

          /**
           * The indices of the vertices
           * @member {number[]}
           */
          this.indices = [];
          /**
           * The main buffer
           * @member {WebGLBuffer}
           */
          this.buffer = _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl);

          /**
           * The index buffer
           * @member {WebGLBuffer}
           */
          this.indexBuffer = _pixiGlCore2.default.GLBuffer.createIndexBuffer(gl);

          /**
           * Whether this graphics is dirty or not
           * @member {boolean}
           */
          this.dirty = true;

          /**
           * Whether this graphics is nativeLines or not
           * @member {boolean}
           */
          this.nativeLines = false;

          this.glPoints = null;
          this.glIndices = null;

          /**
           *
           * @member {PIXI.Shader}
           */
          this.shader = shader;

          this.vao = new _pixiGlCore2.default.VertexArrayObject(gl, attribsState)
            .addIndex(this.indexBuffer)
            .addAttribute(this.buffer, shader.attributes.aVertexPosition, gl.FLOAT, false, 4 * 6, 0)
            .addAttribute(this.buffer, shader.attributes.aColor, gl.FLOAT, false, 4 * 6, 2 * 4);
        }

        /**
         * Resets the vertices and the indices
         */

        WebGLGraphicsData.prototype.reset = function reset() {
          this.points.length = 0;
          this.indices.length = 0;
        };

        /**
         * Binds the buffers and uploads the data
         */

        WebGLGraphicsData.prototype.upload = function upload() {
          this.glPoints = new Float32Array(this.points);
          this.buffer.upload(this.glPoints);

          this.glIndices = new Uint16Array(this.indices);
          this.indexBuffer.upload(this.glIndices);

          this.dirty = false;
        };

        /**
         * Empties all the data
         */

        WebGLGraphicsData.prototype.destroy = function destroy() {
          this.color = null;
          this.points = null;
          this.indices = null;

          this.vao.destroy();
          this.buffer.destroy();
          this.indexBuffer.destroy();

          this.gl = null;

          this.buffer = null;
          this.indexBuffer = null;

          this.glPoints = null;
          this.glIndices = null;
        };

        return WebGLGraphicsData;
      })();

      exports.default = WebGLGraphicsData;
      //# sourceMappingURL=WebGLGraphicsData.js.map

      /***/
    },
    /* 524 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      var _Shader2 = __webpack_require__(361);

      var _Shader3 = _interopRequireDefault(_Shader2);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: { value: subClass, enumerable: false, writable: true, configurable: true },
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass);
      }

      /**
       * This shader is used to draw simple primitive shapes for {@link PIXI.Graphics}.
       *
       * @class
       * @memberof PIXI
       * @extends PIXI.Shader
       */
      var PrimitiveShader = (function (_Shader) {
        _inherits(PrimitiveShader, _Shader);

        /**
         * @param {WebGLRenderingContext} gl - The webgl shader manager this shader works for.
         */
        function PrimitiveShader(gl) {
          _classCallCheck(this, PrimitiveShader);

          return _possibleConstructorReturn(
            this,
            _Shader.call(
              this,
              gl,
              // vertex shader
              [
                "attribute vec2 aVertexPosition;",
                "attribute vec4 aColor;",
                "uniform mat3 translationMatrix;",
                "uniform mat3 projectionMatrix;",
                "uniform float alpha;",
                "uniform vec3 tint;",
                "varying vec4 vColor;",
                "void main(void){",
                "   gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);",
                "   vColor = aColor * vec4(tint * alpha, alpha);",
                "}",
              ].join("\n"),
              // fragment shader
              ["varying vec4 vColor;", "void main(void){", "   gl_FragColor = vColor;", "}"].join("\n")
            )
          );
        }

        return PrimitiveShader;
      })(_Shader3.default);

      exports.default = PrimitiveShader;
      //# sourceMappingURL=PrimitiveShader.js.map

      /***/
    },
    /* 525 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;
      exports.default = buildPoly;

      var _buildLine = __webpack_require__(368);

      var _buildLine2 = _interopRequireDefault(_buildLine);

      var _utils = __webpack_require__(345);

      var _earcut = __webpack_require__(380);

      var _earcut2 = _interopRequireDefault(_earcut);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      /**
       * Builds a polygon to draw
       *
       * Ignored from docs since it is not directly exposed.
       *
       * @ignore
       * @private
       * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
       * @param {object} webGLData - an object containing all the webGL-specific information to create this shape
       * @param {object} webGLDataNativeLines - an object containing all the webGL-specific information to create nativeLines
       */
      function buildPoly(graphicsData, webGLData, webGLDataNativeLines) {
        graphicsData.points = graphicsData.shape.points.slice();

        var points = graphicsData.points;

        if (graphicsData.fill && points.length >= 6) {
          var holeArray = [];
          // Process holes..
          var holes = graphicsData.holes;

          for (var i = 0; i < holes.length; i++) {
            var hole = holes[i];

            holeArray.push(points.length / 2);

            points = points.concat(hole.points);
          }

          // get first and last point.. figure out the middle!
          var verts = webGLData.points;
          var indices = webGLData.indices;

          var length = points.length / 2;

          // sort color
          var color = (0, _utils.hex2rgb)(graphicsData.fillColor);
          var alpha = graphicsData.fillAlpha;
          var r = color[0] * alpha;
          var g = color[1] * alpha;
          var b = color[2] * alpha;

          var triangles = (0, _earcut2.default)(points, holeArray, 2);

          if (!triangles) {
            return;
          }

          var vertPos = verts.length / 6;

          for (var _i = 0; _i < triangles.length; _i += 3) {
            indices.push(triangles[_i] + vertPos);
            indices.push(triangles[_i] + vertPos);
            indices.push(triangles[_i + 1] + vertPos);
            indices.push(triangles[_i + 2] + vertPos);
            indices.push(triangles[_i + 2] + vertPos);
          }

          for (var _i2 = 0; _i2 < length; _i2++) {
            verts.push(points[_i2 * 2], points[_i2 * 2 + 1], r, g, b, alpha);
          }
        }

        if (graphicsData.lineWidth > 0) {
          (0, _buildLine2.default)(graphicsData, webGLData, webGLDataNativeLines);
        }
      }
      //# sourceMappingURL=buildPoly.js.map

      /***/
    },
    /* 526 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;
      exports.default = buildRectangle;

      var _buildLine = __webpack_require__(368);

      var _buildLine2 = _interopRequireDefault(_buildLine);

      var _utils = __webpack_require__(345);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      /**
       * Builds a rectangle to draw
       *
       * Ignored from docs since it is not directly exposed.
       *
       * @ignore
       * @private
       * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
       * @param {object} webGLData - an object containing all the webGL-specific information to create this shape
       * @param {object} webGLDataNativeLines - an object containing all the webGL-specific information to create nativeLines
       */
      function buildRectangle(graphicsData, webGLData, webGLDataNativeLines) {
        // --- //
        // need to convert points to a nice regular data
        //
        var rectData = graphicsData.shape;
        var x = rectData.x;
        var y = rectData.y;
        var width = rectData.width;
        var height = rectData.height;

        if (graphicsData.fill) {
          var color = (0, _utils.hex2rgb)(graphicsData.fillColor);
          var alpha = graphicsData.fillAlpha;

          var r = color[0] * alpha;
          var g = color[1] * alpha;
          var b = color[2] * alpha;

          var verts = webGLData.points;
          var indices = webGLData.indices;

          var vertPos = verts.length / 6;

          // start
          verts.push(x, y);
          verts.push(r, g, b, alpha);

          verts.push(x + width, y);
          verts.push(r, g, b, alpha);

          verts.push(x, y + height);
          verts.push(r, g, b, alpha);

          verts.push(x + width, y + height);
          verts.push(r, g, b, alpha);

          // insert 2 dead triangles..
          indices.push(vertPos, vertPos, vertPos + 1, vertPos + 2, vertPos + 3, vertPos + 3);
        }

        if (graphicsData.lineWidth) {
          var tempPoints = graphicsData.points;

          graphicsData.points = [x, y, x + width, y, x + width, y + height, x, y + height, x, y];

          (0, _buildLine2.default)(graphicsData, webGLData, webGLDataNativeLines);

          graphicsData.points = tempPoints;
        }
      }
      //# sourceMappingURL=buildRectangle.js.map

      /***/
    },
    /* 527 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;
      exports.default = buildRoundedRectangle;

      var _earcut = __webpack_require__(380);

      var _earcut2 = _interopRequireDefault(_earcut);

      var _buildLine = __webpack_require__(368);

      var _buildLine2 = _interopRequireDefault(_buildLine);

      var _utils = __webpack_require__(345);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      /**
       * Builds a rounded rectangle to draw
       *
       * Ignored from docs since it is not directly exposed.
       *
       * @ignore
       * @private
       * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
       * @param {object} webGLData - an object containing all the webGL-specific information to create this shape
       * @param {object} webGLDataNativeLines - an object containing all the webGL-specific information to create nativeLines
       */
      function buildRoundedRectangle(graphicsData, webGLData, webGLDataNativeLines) {
        var rrectData = graphicsData.shape;
        var x = rrectData.x;
        var y = rrectData.y;
        var width = rrectData.width;
        var height = rrectData.height;

        var radius = rrectData.radius;

        var recPoints = [];

        recPoints.push(x + radius, y);
        quadraticBezierCurve(x + width - radius, y, x + width, y, x + width, y + radius, recPoints);
        quadraticBezierCurve(x + width, y + height - radius, x + width, y + height, x + width - radius, y + height, recPoints);
        quadraticBezierCurve(x + radius, y + height, x, y + height, x, y + height - radius, recPoints);
        quadraticBezierCurve(x, y + radius, x, y, x + radius + 0.0000000001, y, recPoints);

        // this tiny number deals with the issue that occurs when points overlap and earcut fails to triangulate the item.
        // TODO - fix this properly, this is not very elegant.. but it works for now.

        if (graphicsData.fill) {
          var color = (0, _utils.hex2rgb)(graphicsData.fillColor);
          var alpha = graphicsData.fillAlpha;

          var r = color[0] * alpha;
          var g = color[1] * alpha;
          var b = color[2] * alpha;

          var verts = webGLData.points;
          var indices = webGLData.indices;

          var vecPos = verts.length / 6;

          var triangles = (0, _earcut2.default)(recPoints, null, 2);

          for (var i = 0, j = triangles.length; i < j; i += 3) {
            indices.push(triangles[i] + vecPos);
            indices.push(triangles[i] + vecPos);
            indices.push(triangles[i + 1] + vecPos);
            indices.push(triangles[i + 2] + vecPos);
            indices.push(triangles[i + 2] + vecPos);
          }

          for (var _i = 0, _j = recPoints.length; _i < _j; _i++) {
            verts.push(recPoints[_i], recPoints[++_i], r, g, b, alpha);
          }
        }

        if (graphicsData.lineWidth) {
          var tempPoints = graphicsData.points;

          graphicsData.points = recPoints;

          (0, _buildLine2.default)(graphicsData, webGLData, webGLDataNativeLines);

          graphicsData.points = tempPoints;
        }
      }

      /**
       * Calculate a single point for a quadratic bezier curve.
       * Utility function used by quadraticBezierCurve.
       * Ignored from docs since it is not directly exposed.
       *
       * @ignore
       * @private
       * @param {number} n1 - first number
       * @param {number} n2 - second number
       * @param {number} perc - percentage
       * @return {number} the result
       *
       */
      function getPt(n1, n2, perc) {
        var diff = n2 - n1;

        return n1 + diff * perc;
      }

      /**
       * Calculate the points for a quadratic bezier curve. (helper function..)
       * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
       *
       * Ignored from docs since it is not directly exposed.
       *
       * @ignore
       * @private
       * @param {number} fromX - Origin point x
       * @param {number} fromY - Origin point x
       * @param {number} cpX - Control point x
       * @param {number} cpY - Control point y
       * @param {number} toX - Destination point x
       * @param {number} toY - Destination point y
       * @param {number[]} [out=[]] - The output array to add points into. If not passed, a new array is created.
       * @return {number[]} an array of points
       */
      function quadraticBezierCurve(fromX, fromY, cpX, cpY, toX, toY) {
        var out = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [];

        var n = 20;
        var points = out;

        var xa = 0;
        var ya = 0;
        var xb = 0;
        var yb = 0;
        var x = 0;
        var y = 0;

        for (var i = 0, j = 0; i <= n; ++i) {
          j = i / n;

          // The Green Line
          xa = getPt(fromX, cpX, j);
          ya = getPt(fromY, cpY, j);
          xb = getPt(cpX, toX, j);
          yb = getPt(cpY, toY, j);

          // The Black Dot
          x = getPt(xa, xb, j);
          y = getPt(ya, yb, j);

          points.push(x, y);
        }

        return points;
      }
      //# sourceMappingURL=buildRoundedRectangle.js.map

      /***/
    },
    /* 528 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;
      exports.default = buildCircle;

      var _buildLine = __webpack_require__(368);

      var _buildLine2 = _interopRequireDefault(_buildLine);

      var _const = __webpack_require__(343);

      var _utils = __webpack_require__(345);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      /**
       * Builds a circle to draw
       *
       * Ignored from docs since it is not directly exposed.
       *
       * @ignore
       * @private
       * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object to draw
       * @param {object} webGLData - an object containing all the webGL-specific information to create this shape
       * @param {object} webGLDataNativeLines - an object containing all the webGL-specific information to create nativeLines
       */
      function buildCircle(graphicsData, webGLData, webGLDataNativeLines) {
        // need to convert points to a nice regular data
        var circleData = graphicsData.shape;
        var x = circleData.x;
        var y = circleData.y;
        var width = void 0;
        var height = void 0;

        // TODO - bit hacky??
        if (graphicsData.type === _const.SHAPES.CIRC) {
          width = circleData.radius;
          height = circleData.radius;
        } else {
          width = circleData.width;
          height = circleData.height;
        }

        if (width === 0 || height === 0) {
          return;
        }

        var totalSegs = Math.floor(30 * Math.sqrt(circleData.radius)) || Math.floor(15 * Math.sqrt(circleData.width + circleData.height));

        var seg = (Math.PI * 2) / totalSegs;

        if (graphicsData.fill) {
          var color = (0, _utils.hex2rgb)(graphicsData.fillColor);
          var alpha = graphicsData.fillAlpha;

          var r = color[0] * alpha;
          var g = color[1] * alpha;
          var b = color[2] * alpha;

          var verts = webGLData.points;
          var indices = webGLData.indices;

          var vecPos = verts.length / 6;

          indices.push(vecPos);

          for (var i = 0; i < totalSegs + 1; i++) {
            verts.push(x, y, r, g, b, alpha);

            verts.push(x + Math.sin(seg * i) * width, y + Math.cos(seg * i) * height, r, g, b, alpha);

            indices.push(vecPos++, vecPos++);
          }

          indices.push(vecPos - 1);
        }

        if (graphicsData.lineWidth) {
          var tempPoints = graphicsData.points;

          graphicsData.points = [];

          for (var _i = 0; _i < totalSegs; _i++) {
            graphicsData.points.push(x + Math.sin(seg * -_i) * width, y + Math.cos(seg * -_i) * height);
          }

          graphicsData.points.push(graphicsData.points[0], graphicsData.points[1]);

          (0, _buildLine2.default)(graphicsData, webGLData, webGLDataNativeLines);

          graphicsData.points = tempPoints;
        }
      }
      //# sourceMappingURL=buildCircle.js.map

      /***/
    },
    /* 529 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      var _CanvasRenderer = __webpack_require__(359);

      var _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);

      var _const = __webpack_require__(343);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      /**
       * @author Mat Groves
       *
       * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/
       * for creating the original PixiJS version!
       * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they
       * now share 4 bytes on the vertex buffer
       *
       * Heavily inspired by LibGDX's CanvasGraphicsRenderer:
       * https://github.com/libgdx/libgdx/blob/1.0.0/gdx/src/com/badlogic/gdx/graphics/glutils/ShapeRenderer.java
       */

      /**
       * Renderer dedicated to drawing and batching graphics objects.
       *
       * @class
       * @private
       * @memberof PIXI
       */
      var CanvasGraphicsRenderer = (function () {
        /**
         * @param {PIXI.CanvasRenderer} renderer - The current PIXI renderer.
         */
        function CanvasGraphicsRenderer(renderer) {
          _classCallCheck(this, CanvasGraphicsRenderer);

          this.renderer = renderer;
        }

        /**
         * Renders a Graphics object to a canvas.
         *
         * @param {PIXI.Graphics} graphics - the actual graphics object to render
         */

        CanvasGraphicsRenderer.prototype.render = function render(graphics) {
          var renderer = this.renderer;
          var context = renderer.context;
          var worldAlpha = graphics.worldAlpha;
          var transform = graphics.transform.worldTransform;
          var resolution = renderer.resolution;

          context.setTransform(
            transform.a * resolution,
            transform.b * resolution,
            transform.c * resolution,
            transform.d * resolution,
            transform.tx * resolution,
            transform.ty * resolution
          );

          // update tint if graphics was dirty
          if (graphics.canvasTintDirty !== graphics.dirty || graphics._prevTint !== graphics.tint) {
            this.updateGraphicsTint(graphics);
          }

          renderer.setBlendMode(graphics.blendMode);

          for (var i = 0; i < graphics.graphicsData.length; i++) {
            var data = graphics.graphicsData[i];
            var shape = data.shape;

            var fillColor = data._fillTint;
            var lineColor = data._lineTint;

            context.lineWidth = data.lineWidth;

            if (data.type === _const.SHAPES.POLY) {
              context.beginPath();

              var points = shape.points;
              var holes = data.holes;
              var outerArea = void 0;
              var innerArea = void 0;
              var px = void 0;
              var py = void 0;

              context.moveTo(points[0], points[1]);

              for (var j = 2; j < points.length; j += 2) {
                context.lineTo(points[j], points[j + 1]);
              }

              // if the first and last point are the same close the path - much neater :)
              if (shape.closed) {
                context.closePath();
              }

              if (holes.length > 0) {
                outerArea = 0;
                px = points[0];
                py = points[1];
                for (var _j = 2; _j + 2 < points.length; _j += 2) {
                  outerArea += (points[_j] - px) * (points[_j + 3] - py) - (points[_j + 2] - px) * (points[_j + 1] - py);
                }

                for (var k = 0; k < holes.length; k++) {
                  points = holes[k].points;

                  if (!points) {
                    continue;
                  }

                  innerArea = 0;
                  px = points[0];
                  py = points[1];
                  for (var _j2 = 2; _j2 + 2 < points.length; _j2 += 2) {
                    innerArea += (points[_j2] - px) * (points[_j2 + 3] - py) - (points[_j2 + 2] - px) * (points[_j2 + 1] - py);
                  }

                  if (innerArea * outerArea < 0) {
                    context.moveTo(points[0], points[1]);

                    for (var _j3 = 2; _j3 < points.length; _j3 += 2) {
                      context.lineTo(points[_j3], points[_j3 + 1]);
                    }
                  } else {
                    context.moveTo(points[points.length - 2], points[points.length - 1]);

                    for (var _j4 = points.length - 4; _j4 >= 0; _j4 -= 2) {
                      context.lineTo(points[_j4], points[_j4 + 1]);
                    }
                  }

                  if (holes[k].close) {
                    context.closePath();
                  }
                }
              }

              if (data.fill) {
                context.globalAlpha = data.fillAlpha * worldAlpha;
                context.fillStyle = "#" + ("00000" + (fillColor | 0).toString(16)).substr(-6);
                context.fill();
              }
              if (data.lineWidth) {
                context.globalAlpha = data.lineAlpha * worldAlpha;
                context.strokeStyle = "#" + ("00000" + (lineColor | 0).toString(16)).substr(-6);
                context.stroke();
              }
            } else if (data.type === _const.SHAPES.RECT) {
              if (data.fillColor || data.fillColor === 0) {
                context.globalAlpha = data.fillAlpha * worldAlpha;
                context.fillStyle = "#" + ("00000" + (fillColor | 0).toString(16)).substr(-6);
                context.fillRect(shape.x, shape.y, shape.width, shape.height);
              }
              if (data.lineWidth) {
                context.globalAlpha = data.lineAlpha * worldAlpha;
                context.strokeStyle = "#" + ("00000" + (lineColor | 0).toString(16)).substr(-6);
                context.strokeRect(shape.x, shape.y, shape.width, shape.height);
              }
            } else if (data.type === _const.SHAPES.CIRC) {
              // TODO - need to be Undefined!
              context.beginPath();
              context.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);
              context.closePath();

              if (data.fill) {
                context.globalAlpha = data.fillAlpha * worldAlpha;
                context.fillStyle = "#" + ("00000" + (fillColor | 0).toString(16)).substr(-6);
                context.fill();
              }
              if (data.lineWidth) {
                context.globalAlpha = data.lineAlpha * worldAlpha;
                context.strokeStyle = "#" + ("00000" + (lineColor | 0).toString(16)).substr(-6);
                context.stroke();
              }
            } else if (data.type === _const.SHAPES.ELIP) {
              // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas

              var w = shape.width * 2;
              var h = shape.height * 2;

              var x = shape.x - w / 2;
              var y = shape.y - h / 2;

              context.beginPath();

              var kappa = 0.5522848;
              var ox = (w / 2) * kappa; // control point offset horizontal
              var oy = (h / 2) * kappa; // control point offset vertical
              var xe = x + w; // x-end
              var ye = y + h; // y-end
              var xm = x + w / 2; // x-middle
              var ym = y + h / 2; // y-middle

              context.moveTo(x, ym);
              context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
              context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
              context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
              context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);

              context.closePath();

              if (data.fill) {
                context.globalAlpha = data.fillAlpha * worldAlpha;
                context.fillStyle = "#" + ("00000" + (fillColor | 0).toString(16)).substr(-6);
                context.fill();
              }
              if (data.lineWidth) {
                context.globalAlpha = data.lineAlpha * worldAlpha;
                context.strokeStyle = "#" + ("00000" + (lineColor | 0).toString(16)).substr(-6);
                context.stroke();
              }
            } else if (data.type === _const.SHAPES.RREC) {
              var rx = shape.x;
              var ry = shape.y;
              var width = shape.width;
              var height = shape.height;
              var radius = shape.radius;

              var maxRadius = (Math.min(width, height) / 2) | 0;

              radius = radius > maxRadius ? maxRadius : radius;

              context.beginPath();
              context.moveTo(rx, ry + radius);
              context.lineTo(rx, ry + height - radius);
              context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);
              context.lineTo(rx + width - radius, ry + height);
              context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);
              context.lineTo(rx + width, ry + radius);
              context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);
              context.lineTo(rx + radius, ry);
              context.quadraticCurveTo(rx, ry, rx, ry + radius);
              context.closePath();

              if (data.fillColor || data.fillColor === 0) {
                context.globalAlpha = data.fillAlpha * worldAlpha;
                context.fillStyle = "#" + ("00000" + (fillColor | 0).toString(16)).substr(-6);
                context.fill();
              }

              if (data.lineWidth) {
                context.globalAlpha = data.lineAlpha * worldAlpha;
                context.strokeStyle = "#" + ("00000" + (lineColor | 0).toString(16)).substr(-6);
                context.stroke();
              }
            }
          }
        };

        /**
         * Updates the tint of a graphics object
         *
         * @private
         * @param {PIXI.Graphics} graphics - the graphics that will have its tint updated
         */

        CanvasGraphicsRenderer.prototype.updateGraphicsTint = function updateGraphicsTint(graphics) {
          graphics._prevTint = graphics.tint;
          graphics.canvasTintDirty = graphics.dirty;

          var tintR = ((graphics.tint >> 16) & 0xff) / 255;
          var tintG = ((graphics.tint >> 8) & 0xff) / 255;
          var tintB = (graphics.tint & 0xff) / 255;

          for (var i = 0; i < graphics.graphicsData.length; ++i) {
            var data = graphics.graphicsData[i];

            var fillColor = data.fillColor | 0;
            var lineColor = data.lineColor | 0;

            // super inline, cos optimization :)
            data._fillTint =
              (((((fillColor >> 16) & 0xff) / 255) * tintR * 255) << 16) +
              (((((fillColor >> 8) & 0xff) / 255) * tintG * 255) << 8) +
              ((fillColor & 0xff) / 255) * tintB * 255;

            data._lineTint =
              (((((lineColor >> 16) & 0xff) / 255) * tintR * 255) << 16) +
              (((((lineColor >> 8) & 0xff) / 255) * tintG * 255) << 8) +
              ((lineColor & 0xff) / 255) * tintB * 255;
          }
        };

        /**
         * Renders a polygon.
         *
         * @param {PIXI.Point[]} points - The points to render
         * @param {boolean} close - Should the polygon be closed
         * @param {CanvasRenderingContext2D} context - The rendering context to use
         */

        CanvasGraphicsRenderer.prototype.renderPolygon = function renderPolygon(points, close, context) {
          context.moveTo(points[0], points[1]);

          for (var j = 1; j < points.length / 2; ++j) {
            context.lineTo(points[j * 2], points[j * 2 + 1]);
          }

          if (close) {
            context.closePath();
          }
        };

        /**
         * destroy graphics object
         *
         */

        CanvasGraphicsRenderer.prototype.destroy = function destroy() {
          this.renderer = null;
        };

        return CanvasGraphicsRenderer;
      })();

      exports.default = CanvasGraphicsRenderer;

      _CanvasRenderer2.default.registerPlugin("graphics", CanvasGraphicsRenderer);
      //# sourceMappingURL=CanvasGraphicsRenderer.js.map

      /***/
    },
    /* 530 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      var _createClass = (function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      })();

      var _ = __webpack_require__(344);

      var _utils = __webpack_require__(345);

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      /**
       * Utility class for maintaining reference to a collection
       * of Textures on a single Spritesheet.
       *
       * To access a sprite sheet from your code pass its JSON data file to Pixi's loader:
       *
       * ```js
       * PIXI.loader.add("images/spritesheet.json").load(setup);
       *
       * function setup() {
       *   let sheet = PIXI.loader.resources["images/spritesheet.json"].spritesheet;
       *   ...
       * }
       * ```
       * With the `sheet.textures` you can create Sprite objects,`sheet.animations` can be used to create an AnimatedSprite.
       *
       * Sprite sheets can be packed using tools like {@link https://codeandweb.com/texturepacker|TexturePacker},
       * {@link https://renderhjs.net/shoebox/|Shoebox} or {@link https://github.com/krzysztof-o/spritesheet.js|Spritesheet.js}.
       * Default anchor points (see {@link PIXI.Texture#defaultAnchor}) and grouping of animation sprites are currently only
       * supported by TexturePacker.
       *
       * @class
       * @memberof PIXI
       */
      var Spritesheet = (function () {
        _createClass(Spritesheet, null, [
          {
            key: "BATCH_SIZE",

            /**
             * The maximum number of Textures to build per process.
             *
             * @type {number}
             * @default 1000
             */
            get: function get() {
              return 1000;
            },

            /**
             * @param {PIXI.BaseTexture} baseTexture Reference to the source BaseTexture object.
             * @param {Object} data - Spritesheet image data.
             * @param {string} [resolutionFilename] - The filename to consider when determining
             *        the resolution of the spritesheet. If not provided, the imageUrl will
             *        be used on the BaseTexture.
             */
          },
        ]);

        function Spritesheet(baseTexture, data) {
          var resolutionFilename = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

          _classCallCheck(this, Spritesheet);

          /**
           * Reference to ths source texture
           * @type {PIXI.BaseTexture}
           */
          this.baseTexture = baseTexture;

          /**
           * A map containing all textures of the sprite sheet.
           * Can be used to create a {@link PIXI.Sprite|Sprite}:
           * ```js
           * new PIXI.Sprite(sheet.textures["image.png"]);
           * ```
           * @member {Object}
           */
          this.textures = {};

          /**
           * A map containing the textures for each animation.
           * Can be used to create an {@link PIXI.extras.AnimatedSprite|AnimatedSprite}:
           * ```js
           * new PIXI.extras.AnimatedSprite(sheet.animations["anim_name"])
           * ```
           * @member {Object}
           */
          this.animations = {};

          /**
           * Reference to the original JSON data.
           * @type {Object}
           */
          this.data = data;

          /**
           * The resolution of the spritesheet.
           * @type {number}
           */
          this.resolution = this._updateResolution(resolutionFilename || this.baseTexture.imageUrl);

          /**
           * Map of spritesheet frames.
           * @type {Object}
           * @private
           */
          this._frames = this.data.frames;

          /**
           * Collection of frame names.
           * @type {string[]}
           * @private
           */
          this._frameKeys = Object.keys(this._frames);

          /**
           * Current batch index being processed.
           * @type {number}
           * @private
           */
          this._batchIndex = 0;

          /**
           * Callback when parse is completed.
           * @type {Function}
           * @private
           */
          this._callback = null;
        }

        /**
         * Generate the resolution from the filename or fallback
         * to the meta.scale field of the JSON data.
         *
         * @private
         * @param {string} resolutionFilename - The filename to use for resolving
         *        the default resolution.
         * @return {number} Resolution to use for spritesheet.
         */

        Spritesheet.prototype._updateResolution = function _updateResolution(resolutionFilename) {
          var scale = this.data.meta.scale;

          // Use a defaultValue of `null` to check if a url-based resolution is set
          var resolution = (0, _utils.getResolutionOfUrl)(resolutionFilename, null);

          // No resolution found via URL
          if (resolution === null) {
            // Use the scale value or default to 1
            resolution = scale !== undefined ? parseFloat(scale) : 1;
          }

          // For non-1 resolutions, update baseTexture
          if (resolution !== 1) {
            this.baseTexture.resolution = resolution;
            this.baseTexture.update();
          }

          return resolution;
        };

        /**
         * Parser spritesheet from loaded data. This is done asynchronously
         * to prevent creating too many Texture within a single process.
         *
         * @param {Function} callback - Callback when complete returns
         *        a map of the Textures for this spritesheet.
         */

        Spritesheet.prototype.parse = function parse(callback) {
          this._batchIndex = 0;
          this._callback = callback;

          if (this._frameKeys.length <= Spritesheet.BATCH_SIZE) {
            this._processFrames(0);
            this._processAnimations();
            this._parseComplete();
          } else {
            this._nextBatch();
          }
        };

        /**
         * Process a batch of frames
         *
         * @private
         * @param {number} initialFrameIndex - The index of frame to start.
         */

        Spritesheet.prototype._processFrames = function _processFrames(initialFrameIndex) {
          var frameIndex = initialFrameIndex;
          var maxFrames = Spritesheet.BATCH_SIZE;
          var sourceScale = this.baseTexture.sourceScale;

          while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
            var i = this._frameKeys[frameIndex];
            var data = this._frames[i];
            var rect = data.frame;

            if (rect) {
              var frame = null;
              var trim = null;
              var sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;

              var orig = new _.Rectangle(
                0,
                0,
                Math.floor(sourceSize.w * sourceScale) / this.resolution,
                Math.floor(sourceSize.h * sourceScale) / this.resolution
              );

              if (data.rotated) {
                frame = new _.Rectangle(
                  Math.floor(rect.x * sourceScale) / this.resolution,
                  Math.floor(rect.y * sourceScale) / this.resolution,
                  Math.floor(rect.h * sourceScale) / this.resolution,
                  Math.floor(rect.w * sourceScale) / this.resolution
                );
              } else {
                frame = new _.Rectangle(
                  Math.floor(rect.x * sourceScale) / this.resolution,
                  Math.floor(rect.y * sourceScale) / this.resolution,
                  Math.floor(rect.w * sourceScale) / this.resolution,
                  Math.floor(rect.h * sourceScale) / this.resolution
                );
              }

              //  Check to see if the sprite is trimmed
              if (data.trimmed !== false && data.spriteSourceSize) {
                trim = new _.Rectangle(
                  Math.floor(data.spriteSourceSize.x * sourceScale) / this.resolution,
                  Math.floor(data.spriteSourceSize.y * sourceScale) / this.resolution,
                  Math.floor(rect.w * sourceScale) / this.resolution,
                  Math.floor(rect.h * sourceScale) / this.resolution
                );
              }

              this.textures[i] = new _.Texture(this.baseTexture, frame, orig, trim, data.rotated ? 2 : 0, data.anchor);

              // lets also add the frame to pixi's global cache for fromFrame and fromImage functions
              _.Texture.addToCache(this.textures[i], i);
            }

            frameIndex++;
          }
        };

        /**
         * Parse animations config
         *
         * @private
         */

        Spritesheet.prototype._processAnimations = function _processAnimations() {
          var animations = this.data.animations || {};

          for (var animName in animations) {
            this.animations[animName] = [];
            for (
              var _iterator = animations[animName],
                _isArray = Array.isArray(_iterator),
                _i = 0,
                _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();
              ;

            ) {
              var _ref;

              if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
              } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
              }

              var frameName = _ref;

              this.animations[animName].push(this.textures[frameName]);
            }
          }
        };

        /**
         * The parse has completed.
         *
         * @private
         */

        Spritesheet.prototype._parseComplete = function _parseComplete() {
          var callback = this._callback;

          this._callback = null;
          this._batchIndex = 0;
          callback.call(this, this.textures);
        };

        /**
         * Begin the next batch of textures.
         *
         * @private
         */

        Spritesheet.prototype._nextBatch = function _nextBatch() {
          var _this = this;

          this._processFrames(this._batchIndex * Spritesheet.BATCH_SIZE);
          this._batchIndex++;
          setTimeout(function () {
            if (_this._batchIndex * Spritesheet.BATCH_SIZE < _this._frameKeys.length) {
              _this._nextBatch();
            } else {
              _this._processAnimations();
              _this._parseComplete();
            }
          }, 0);
        };

        /**
         * Destroy Spritesheet and don't use after this.
         *
         * @param {boolean} [destroyBase=false] Whether to destroy the base texture as well
         */

        Spritesheet.prototype.destroy = function destroy() {
          var destroyBase = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

          for (var i in this.textures) {
            this.textures[i].destroy();
          }
          this._frames = null;
          this._frameKeys = null;
          this.data = null;
          this.textures = null;
          if (destroyBase) {
            this.baseTexture.destroy();
          }
          this.baseTexture = null;
        };

        return Spritesheet;
      })();

      exports.default = Spritesheet;
      //# sourceMappingURL=Spritesheet.js.map

      /***/
    },
    /* 531 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;
      exports.default = deprecation;
      // provide method to give a stack track for warnings
      // useful for tracking-down where deprecated methods/properties/classes
      // are being used within the code

      // A map of warning messages already fired
      var warnings = {};

      // provide method to give a stack track for warnings
      // useful for tracking-down where deprecated methods/properties/classes
      // are being used within the code
      function warn(msg) {
        // Ignore duplicat
        if (warnings[msg]) {
          return;
        }

        /* eslint-disable no-console */
        var stack = new Error().stack;

        // Handle IE < 10 and Safari < 6
        if (typeof stack === "undefined") {
          console.warn("Deprecation Warning: ", msg);
        } else {
          // chop off the stack trace which includes pixi.js internal calls
          stack = stack.split("\n").splice(3).join("\n");

          if (console.groupCollapsed) {
            console.groupCollapsed(
              "%cDeprecation Warning: %c%s",
              "color:#614108;background:#fffbe6",
              "font-weight:normal;color:#614108;background:#fffbe6",
              msg
            );
            console.warn(stack);
            console.groupEnd();
          } else {
            console.warn("Deprecation Warning: ", msg);
            console.warn(stack);
          }
        }
        /* eslint-enable no-console */

        warnings[msg] = true;
      }

      function deprecation(core) {
        var mesh = core.mesh,
          particles = core.particles,
          extras = core.extras,
          filters = core.filters,
          prepare = core.prepare,
          loaders = core.loaders,
          interaction = core.interaction;

        Object.defineProperties(core, {
          /**
           * @class
           * @private
           * @name SpriteBatch
           * @memberof PIXI
           * @see PIXI.ParticleContainer
           * @throws {ReferenceError} SpriteBatch does not exist any more, please use the new ParticleContainer instead.
           * @deprecated since version 3.0.0
           */
          SpriteBatch: {
            get: function get() {
              throw new ReferenceError("SpriteBatch does not exist any more, " + "please use the new ParticleContainer instead.");
            },
          },

          /**
           * @class
           * @private
           * @name AssetLoader
           * @memberof PIXI
           * @see PIXI.loaders.Loader
           * @throws {ReferenceError} The loader system was overhauled in PixiJS v3,
           * please see the new PIXI.loaders.Loader class.
           * @deprecated since version 3.0.0
           */
          AssetLoader: {
            get: function get() {
              throw new ReferenceError("The loader system was overhauled in PixiJS v3, " + "please see the new PIXI.loaders.Loader class.");
            },
          },

          /**
           * @class
           * @private
           * @name Stage
           * @memberof PIXI
           * @see PIXI.Container
           * @deprecated since version 3.0.0
           */
          Stage: {
            get: function get() {
              warn("You do not need to use a PIXI Stage any more, you can simply render any container.");

              return core.Container;
            },
          },

          /**
           * @class
           * @private
           * @name DisplayObjectContainer
           * @memberof PIXI
           * @see PIXI.Container
           * @deprecated since version 3.0.0
           */
          DisplayObjectContainer: {
            get: function get() {
              warn("DisplayObjectContainer has been shortened to Container, please use Container from now on.");

              return core.Container;
            },
          },

          /**
           * @class
           * @private
           * @name Strip
           * @memberof PIXI
           * @see PIXI.mesh.Mesh
           * @deprecated since version 3.0.0
           */
          Strip: {
            get: function get() {
              warn("The Strip class has been renamed to Mesh and moved to mesh.Mesh, please use mesh.Mesh from now on.");

              return mesh.Mesh;
            },
          },

          /**
           * @class
           * @private
           * @name Rope
           * @memberof PIXI
           * @see PIXI.mesh.Rope
           * @deprecated since version 3.0.0
           */
          Rope: {
            get: function get() {
              warn("The Rope class has been moved to mesh.Rope, please use mesh.Rope from now on.");

              return mesh.Rope;
            },
          },

          /**
           * @class
           * @private
           * @name ParticleContainer
           * @memberof PIXI
           * @see PIXI.particles.ParticleContainer
           * @deprecated since version 4.0.0
           */
          ParticleContainer: {
            get: function get() {
              warn(
                "The ParticleContainer class has been moved to particles.ParticleContainer, " + "please use particles.ParticleContainer from now on."
              );

              return particles.ParticleContainer;
            },
          },

          /**
           * @class
           * @private
           * @name MovieClip
           * @memberof PIXI
           * @see PIXI.extras.MovieClip
           * @deprecated since version 3.0.0
           */
          MovieClip: {
            get: function get() {
              warn("The MovieClip class has been moved to extras.AnimatedSprite, please use extras.AnimatedSprite.");

              return extras.AnimatedSprite;
            },
          },

          /**
           * @class
           * @private
           * @name TilingSprite
           * @memberof PIXI
           * @see PIXI.extras.TilingSprite
           * @deprecated since version 3.0.0
           */
          TilingSprite: {
            get: function get() {
              warn("The TilingSprite class has been moved to extras.TilingSprite, " + "please use extras.TilingSprite from now on.");

              return extras.TilingSprite;
            },
          },

          /**
           * @class
           * @private
           * @name BitmapText
           * @memberof PIXI
           * @see PIXI.extras.BitmapText
           * @deprecated since version 3.0.0
           */
          BitmapText: {
            get: function get() {
              warn("The BitmapText class has been moved to extras.BitmapText, " + "please use extras.BitmapText from now on.");

              return extras.BitmapText;
            },
          },

          /**
           * @class
           * @private
           * @name blendModes
           * @memberof PIXI
           * @see PIXI.BLEND_MODES
           * @deprecated since version 3.0.0
           */
          blendModes: {
            get: function get() {
              warn("The blendModes has been moved to BLEND_MODES, please use BLEND_MODES from now on.");

              return core.BLEND_MODES;
            },
          },

          /**
           * @class
           * @private
           * @name scaleModes
           * @memberof PIXI
           * @see PIXI.SCALE_MODES
           * @deprecated since version 3.0.0
           */
          scaleModes: {
            get: function get() {
              warn("The scaleModes has been moved to SCALE_MODES, please use SCALE_MODES from now on.");

              return core.SCALE_MODES;
            },
          },

          /**
           * @class
           * @private
           * @name BaseTextureCache
           * @memberof PIXI
           * @see PIXI.utils.BaseTextureCache
           * @deprecated since version 3.0.0
           */
          BaseTextureCache: {
            get: function get() {
              warn("The BaseTextureCache class has been moved to utils.BaseTextureCache, " + "please use utils.BaseTextureCache from now on.");

              return core.utils.BaseTextureCache;
            },
          },

          /**
           * @class
           * @private
           * @name TextureCache
           * @memberof PIXI
           * @see PIXI.utils.TextureCache
           * @deprecated since version 3.0.0
           */
          TextureCache: {
            get: function get() {
              warn("The TextureCache class has been moved to utils.TextureCache, " + "please use utils.TextureCache from now on.");

              return core.utils.TextureCache;
            },
          },

          /**
           * @namespace
           * @private
           * @name math
           * @memberof PIXI
           * @see PIXI
           * @deprecated since version 3.0.6
           */
          math: {
            get: function get() {
              warn("The math namespace is deprecated, please access members already accessible on PIXI.");

              return core;
            },
          },

          /**
           * @class
           * @private
           * @name PIXI.AbstractFilter
           * @see PIXI.Filter
           * @deprecated since version 3.0.6
           */
          AbstractFilter: {
            get: function get() {
              warn("AstractFilter has been renamed to Filter, please use PIXI.Filter");

              return core.Filter;
            },
          },

          /**
           * @class
           * @private
           * @name PIXI.TransformManual
           * @see PIXI.TransformBase
           * @deprecated since version 4.0.0
           */
          TransformManual: {
            get: function get() {
              warn("TransformManual has been renamed to TransformBase, please update your pixi-spine");

              return core.TransformBase;
            },
          },

          /**
           * @static
           * @constant
           * @name PIXI.TARGET_FPMS
           * @see PIXI.settings.TARGET_FPMS
           * @deprecated since version 4.2.0
           */
          TARGET_FPMS: {
            get: function get() {
              warn("PIXI.TARGET_FPMS has been deprecated, please use PIXI.settings.TARGET_FPMS");

              return core.settings.TARGET_FPMS;
            },
            set: function set(value) {
              warn("PIXI.TARGET_FPMS has been deprecated, please use PIXI.settings.TARGET_FPMS");

              core.settings.TARGET_FPMS = value;
            },
          },

          /**
           * @static
           * @constant
           * @name PIXI.FILTER_RESOLUTION
           * @see PIXI.settings.FILTER_RESOLUTION
           * @deprecated since version 4.2.0
           */
          FILTER_RESOLUTION: {
            get: function get() {
              warn("PIXI.FILTER_RESOLUTION has been deprecated, please use PIXI.settings.FILTER_RESOLUTION");

              return core.settings.FILTER_RESOLUTION;
            },
            set: function set(value) {
              warn("PIXI.FILTER_RESOLUTION has been deprecated, please use PIXI.settings.FILTER_RESOLUTION");

              core.settings.FILTER_RESOLUTION = value;
            },
          },

          /**
           * @static
           * @constant
           * @name PIXI.RESOLUTION
           * @see PIXI.settings.RESOLUTION
           * @deprecated since version 4.2.0
           */
          RESOLUTION: {
            get: function get() {
              warn("PIXI.RESOLUTION has been deprecated, please use PIXI.settings.RESOLUTION");

              return core.settings.RESOLUTION;
            },
            set: function set(value) {
              warn("PIXI.RESOLUTION has been deprecated, please use PIXI.settings.RESOLUTION");

              core.settings.RESOLUTION = value;
            },
          },

          /**
           * @static
           * @constant
           * @name PIXI.MIPMAP_TEXTURES
           * @see PIXI.settings.MIPMAP_TEXTURES
           * @deprecated since version 4.2.0
           */
          MIPMAP_TEXTURES: {
            get: function get() {
              warn("PIXI.MIPMAP_TEXTURES has been deprecated, please use PIXI.settings.MIPMAP_TEXTURES");

              return core.settings.MIPMAP_TEXTURES;
            },
            set: function set(value) {
              warn("PIXI.MIPMAP_TEXTURES has been deprecated, please use PIXI.settings.MIPMAP_TEXTURES");

              core.settings.MIPMAP_TEXTURES = value;
            },
          },

          /**
           * @static
           * @constant
           * @name PIXI.SPRITE_BATCH_SIZE
           * @see PIXI.settings.SPRITE_BATCH_SIZE
           * @deprecated since version 4.2.0
           */
          SPRITE_BATCH_SIZE: {
            get: function get() {
              warn("PIXI.SPRITE_BATCH_SIZE has been deprecated, please use PIXI.settings.SPRITE_BATCH_SIZE");

              return core.settings.SPRITE_BATCH_SIZE;
            },
            set: function set(value) {
              warn("PIXI.SPRITE_BATCH_SIZE has been deprecated, please use PIXI.settings.SPRITE_BATCH_SIZE");

              core.settings.SPRITE_BATCH_SIZE = value;
            },
          },

          /**
           * @static
           * @constant
           * @name PIXI.SPRITE_MAX_TEXTURES
           * @see PIXI.settings.SPRITE_MAX_TEXTURES
           * @deprecated since version 4.2.0
           */
          SPRITE_MAX_TEXTURES: {
            get: function get() {
              warn("PIXI.SPRITE_MAX_TEXTURES has been deprecated, please use PIXI.settings.SPRITE_MAX_TEXTURES");

              return core.settings.SPRITE_MAX_TEXTURES;
            },
            set: function set(value) {
              warn("PIXI.SPRITE_MAX_TEXTURES has been deprecated, please use PIXI.settings.SPRITE_MAX_TEXTURES");

              core.settings.SPRITE_MAX_TEXTURES = value;
            },
          },

          /**
           * @static
           * @constant
           * @name PIXI.RETINA_PREFIX
           * @see PIXI.settings.RETINA_PREFIX
           * @deprecated since version 4.2.0
           */
          RETINA_PREFIX: {
            get: function get() {
              warn("PIXI.RETINA_PREFIX has been deprecated, please use PIXI.settings.RETINA_PREFIX");

              return core.settings.RETINA_PREFIX;
            },
            set: function set(value) {
              warn("PIXI.RETINA_PREFIX has been deprecated, please use PIXI.settings.RETINA_PREFIX");

              core.settings.RETINA_PREFIX = value;
            },
          },

          /**
           * @static
           * @constant
           * @name PIXI.DEFAULT_RENDER_OPTIONS
           * @see PIXI.settings.RENDER_OPTIONS
           * @deprecated since version 4.2.0
           */
          DEFAULT_RENDER_OPTIONS: {
            get: function get() {
              warn("PIXI.DEFAULT_RENDER_OPTIONS has been deprecated, please use PIXI.settings.DEFAULT_RENDER_OPTIONS");

              return core.settings.RENDER_OPTIONS;
            },
          },
        });

        // Move the default properties to settings
        var defaults = [
          { parent: "TRANSFORM_MODE", target: "TRANSFORM_MODE" },
          { parent: "GC_MODES", target: "GC_MODE" },
          { parent: "WRAP_MODES", target: "WRAP_MODE" },
          { parent: "SCALE_MODES", target: "SCALE_MODE" },
          { parent: "PRECISION", target: "PRECISION_FRAGMENT" },
        ];

        var _loop = function _loop(i) {
          var deprecation = defaults[i];

          Object.defineProperty(core[deprecation.parent], "DEFAULT", {
            get: function get() {
              warn("PIXI." + deprecation.parent + ".DEFAULT has been deprecated, " + ("please use PIXI.settings." + deprecation.target));

              return core.settings[deprecation.target];
            },
            set: function set(value) {
              warn("PIXI." + deprecation.parent + ".DEFAULT has been deprecated, " + ("please use PIXI.settings." + deprecation.target));

              core.settings[deprecation.target] = value;
            },
          });
        };

        for (var i = 0; i < defaults.length; i++) {
          _loop(i);
        }

        Object.defineProperties(core.settings, {
          /**
           * @static
           * @name PRECISION
           * @memberof PIXI.settings
           * @see PIXI.PRECISION
           * @deprecated since version 4.4.0
           */
          PRECISION: {
            get: function get() {
              warn("PIXI.settings.PRECISION has been deprecated, please use PIXI.settings.PRECISION_FRAGMENT");

              return core.settings.PRECISION_FRAGMENT;
            },
            set: function set(value) {
              warn("PIXI.settings.PRECISION has been deprecated, please use PIXI.settings.PRECISION_FRAGMENT");

              core.settings.PRECISION_FRAGMENT = value;
            },
          },
        });

        if (extras.AnimatedSprite) {
          Object.defineProperties(extras, {
            /**
             * @class
             * @name MovieClip
             * @memberof PIXI.extras
             * @see PIXI.extras.AnimatedSprite
             * @deprecated since version 4.2.0
             */
            MovieClip: {
              get: function get() {
                warn("The MovieClip class has been renamed to AnimatedSprite, please use AnimatedSprite from now on.");

                return extras.AnimatedSprite;
              },
            },
          });
        }

        if (extras) {
          Object.defineProperties(extras, {
            /**
             * @class
             * @name TextureTransform
             * @memberof PIXI.extras
             * @see PIXI.TextureMatrix
             * @deprecated since version 4.6.0
             */
            TextureTransform: {
              get: function get() {
                warn("The TextureTransform class has been renamed to TextureMatrix, " + "please use PIXI.TextureMatrix from now on.");

                return core.TextureMatrix;
              },
            },
          });
        }

        core.DisplayObject.prototype.generateTexture = function generateTexture(renderer, scaleMode, resolution) {
          warn("generateTexture has moved to the renderer, please use renderer.generateTexture(displayObject)");

          return renderer.generateTexture(this, scaleMode, resolution);
        };

        core.Graphics.prototype.generateTexture = function generateTexture(scaleMode, resolution) {
          warn(
            "graphics generate texture has moved to the renderer. " +
              "Or to render a graphics to a texture using canvas please use generateCanvasTexture"
          );

          return this.generateCanvasTexture(scaleMode, resolution);
        };

        /**
         * @method
         * @name PIXI.GroupD8.isSwapWidthHeight
         * @see PIXI.GroupD8.isVertical
         * @param {number} rotation - The number to check.
         * @returns {boolean} Whether or not the direction is vertical
         * @deprecated since version 4.6.0
         */
        core.GroupD8.isSwapWidthHeight = function isSwapWidthHeight(rotation) {
          warn("GroupD8.isSwapWidthHeight was renamed to GroupD8.isVertical");

          return core.GroupD8.isVertical(rotation);
        };

        core.RenderTexture.prototype.render = function render(displayObject, matrix, clear, updateTransform) {
          this.legacyRenderer.render(displayObject, this, clear, matrix, !updateTransform);
          warn("RenderTexture.render is now deprecated, please use renderer.render(displayObject, renderTexture)");
        };

        core.RenderTexture.prototype.getImage = function getImage(target) {
          warn("RenderTexture.getImage is now deprecated, please use renderer.extract.image(target)");

          return this.legacyRenderer.extract.image(target);
        };

        core.RenderTexture.prototype.getBase64 = function getBase64(target) {
          warn("RenderTexture.getBase64 is now deprecated, please use renderer.extract.base64(target)");

          return this.legacyRenderer.extract.base64(target);
        };

        core.RenderTexture.prototype.getCanvas = function getCanvas(target) {
          warn("RenderTexture.getCanvas is now deprecated, please use renderer.extract.canvas(target)");

          return this.legacyRenderer.extract.canvas(target);
        };

        core.RenderTexture.prototype.getPixels = function getPixels(target) {
          warn("RenderTexture.getPixels is now deprecated, please use renderer.extract.pixels(target)");

          return this.legacyRenderer.pixels(target);
        };

        /**
         * @method
         * @private
         * @name PIXI.Sprite#setTexture
         * @see PIXI.Sprite#texture
         * @deprecated since version 3.0.0
         * @param {PIXI.Texture} texture - The texture to set to.
         */
        core.Sprite.prototype.setTexture = function setTexture(texture) {
          this.texture = texture;
          warn("setTexture is now deprecated, please use the texture property, e.g : sprite.texture = texture;");
        };

        if (extras.BitmapText) {
          /**
           * @method
           * @name PIXI.extras.BitmapText#setText
           * @see PIXI.extras.BitmapText#text
           * @deprecated since version 3.0.0
           * @param {string} text - The text to set to.
           */
          extras.BitmapText.prototype.setText = function setText(text) {
            this.text = text;
            warn("setText is now deprecated, please use the text property, e.g : myBitmapText.text = 'my text';");
          };
        }

        /**
         * @method
         * @name PIXI.Text#setText
         * @see PIXI.Text#text
         * @deprecated since version 3.0.0
         * @param {string} text - The text to set to.
         */
        core.Text.prototype.setText = function setText(text) {
          this.text = text;
          warn("setText is now deprecated, please use the text property, e.g : myText.text = 'my text';");
        };

        /**
         * Calculates the ascent, descent and fontSize of a given fontStyle
         *
         * @name PIXI.Text.calculateFontProperties
         * @see PIXI.TextMetrics.measureFont
         * @deprecated since version 4.5.0
         * @param {string} font - String representing the style of the font
         * @return {Object} Font properties object
         */
        core.Text.calculateFontProperties = function calculateFontProperties(font) {
          warn("Text.calculateFontProperties is now deprecated, please use the TextMetrics.measureFont");

          return core.TextMetrics.measureFont(font);
        };

        Object.defineProperties(core.Text, {
          fontPropertiesCache: {
            get: function get() {
              warn("Text.fontPropertiesCache is deprecated");

              return core.TextMetrics._fonts;
            },
          },
          fontPropertiesCanvas: {
            get: function get() {
              warn("Text.fontPropertiesCanvas is deprecated");

              return core.TextMetrics._canvas;
            },
          },
          fontPropertiesContext: {
            get: function get() {
              warn("Text.fontPropertiesContext is deprecated");

              return core.TextMetrics._context;
            },
          },
        });

        /**
         * @method
         * @name PIXI.Text#setStyle
         * @see PIXI.Text#style
         * @deprecated since version 3.0.0
         * @param {*} style - The style to set to.
         */
        core.Text.prototype.setStyle = function setStyle(style) {
          this.style = style;
          warn("setStyle is now deprecated, please use the style property, e.g : myText.style = style;");
        };

        /**
         * @method
         * @name PIXI.Text#determineFontProperties
         * @see PIXI.Text#measureFontProperties
         * @deprecated since version 4.2.0
         * @private
         * @param {string} fontStyle - String representing the style of the font
         * @return {Object} Font properties object
         */
        core.Text.prototype.determineFontProperties = function determineFontProperties(fontStyle) {
          warn("determineFontProperties is now deprecated, please use TextMetrics.measureFont method");

          return core.TextMetrics.measureFont(fontStyle);
        };

        /**
         * @method
         * @name PIXI.Text.getFontStyle
         * @see PIXI.TextMetrics.getFontStyle
         * @deprecated since version 4.5.0
         * @param {PIXI.TextStyle} style - The style to use.
         * @return {string} Font string
         */
        core.Text.getFontStyle = function getFontStyle(style) {
          warn("getFontStyle is now deprecated, please use TextStyle.toFontString() instead");

          style = style || {};

          if (!(style instanceof core.TextStyle)) {
            style = new core.TextStyle(style);
          }

          return style.toFontString();
        };

        Object.defineProperties(core.TextStyle.prototype, {
          /**
           * Set all properties of a font as a single string
           *
           * @name PIXI.TextStyle#font
           * @deprecated since version 4.0.0
           */
          font: {
            get: function get() {
              warn(
                "text style property 'font' is now deprecated, please use the " +
                  "'fontFamily', 'fontSize', 'fontStyle', 'fontVariant' and 'fontWeight' properties from now on"
              );

              var fontSizeString = typeof this._fontSize === "number" ? this._fontSize + "px" : this._fontSize;

              return this._fontStyle + " " + this._fontVariant + " " + this._fontWeight + " " + fontSizeString + " " + this._fontFamily;
            },
            set: function set(font) {
              warn(
                "text style property 'font' is now deprecated, please use the " +
                  "'fontFamily','fontSize',fontStyle','fontVariant' and 'fontWeight' properties from now on"
              );

              // can work out fontStyle from search of whole string
              if (font.indexOf("italic") > 1) {
                this._fontStyle = "italic";
              } else if (font.indexOf("oblique") > -1) {
                this._fontStyle = "oblique";
              } else {
                this._fontStyle = "normal";
              }

              // can work out fontVariant from search of whole string
              if (font.indexOf("small-caps") > -1) {
                this._fontVariant = "small-caps";
              } else {
                this._fontVariant = "normal";
              }

              // fontWeight and fontFamily are tricker to find, but it's easier to find the fontSize due to it's units
              var splits = font.split(" ");
              var fontSizeIndex = -1;

              this._fontSize = 26;
              for (var i = 0; i < splits.length; ++i) {
                if (splits[i].match(/(px|pt|em|%)/)) {
                  fontSizeIndex = i;
                  this._fontSize = splits[i];
                  break;
                }
              }

              // we can now search for fontWeight as we know it must occur before the fontSize
              this._fontWeight = "normal";
              for (var _i = 0; _i < fontSizeIndex; ++_i) {
                if (splits[_i].match(/(bold|bolder|lighter|100|200|300|400|500|600|700|800|900)/)) {
                  this._fontWeight = splits[_i];
                  break;
                }
              }

              // and finally join everything together after the fontSize in case the font family has multiple words
              if (fontSizeIndex > -1 && fontSizeIndex < splits.length - 1) {
                this._fontFamily = "";
                for (var _i2 = fontSizeIndex + 1; _i2 < splits.length; ++_i2) {
                  this._fontFamily += splits[_i2] + " ";
                }

                this._fontFamily = this._fontFamily.slice(0, -1);
              } else {
                this._fontFamily = "Arial";
              }

              this.styleID++;
            },
          },
        });

        /**
         * @method
         * @name PIXI.Texture#setFrame
         * @see PIXI.Texture#setFrame
         * @deprecated since version 3.0.0
         * @param {PIXI.Rectangle} frame - The frame to set.
         */
        core.Texture.prototype.setFrame = function setFrame(frame) {
          this.frame = frame;
          warn("setFrame is now deprecated, please use the frame property, e.g: myTexture.frame = frame;");
        };

        /**
         * @static
         * @function
         * @name PIXI.Texture.addTextureToCache
         * @see PIXI.Texture.addToCache
         * @deprecated since 4.5.0
         * @param {PIXI.Texture} texture - The Texture to add to the cache.
         * @param {string} id - The id that the texture will be stored against.
         */
        core.Texture.addTextureToCache = function addTextureToCache(texture, id) {
          core.Texture.addToCache(texture, id);
          warn("Texture.addTextureToCache is deprecated, please use Texture.addToCache from now on.");
        };

        /**
         * @static
         * @function
         * @name PIXI.Texture.removeTextureFromCache
         * @see PIXI.Texture.removeFromCache
         * @deprecated since 4.5.0
         * @param {string} id - The id of the texture to be removed
         * @return {PIXI.Texture|null} The texture that was removed
         */
        core.Texture.removeTextureFromCache = function removeTextureFromCache(id) {
          warn(
            "Texture.removeTextureFromCache is deprecated, please use Texture.removeFromCache from now on. " +
              "Be aware that Texture.removeFromCache does not automatically its BaseTexture from the BaseTextureCache. " +
              "For that, use BaseTexture.removeFromCache"
          );

          core.BaseTexture.removeFromCache(id);

          return core.Texture.removeFromCache(id);
        };

        Object.defineProperties(filters, {
          /**
           * @class
           * @private
           * @name PIXI.filters.AbstractFilter
           * @see PIXI.AbstractFilter
           * @deprecated since version 3.0.6
           */
          AbstractFilter: {
            get: function get() {
              warn("AstractFilter has been renamed to Filter, please use PIXI.Filter");

              return core.AbstractFilter;
            },
          },

          /**
           * @class
           * @private
           * @name PIXI.filters.SpriteMaskFilter
           * @see PIXI.SpriteMaskFilter
           * @deprecated since version 3.0.6
           */
          SpriteMaskFilter: {
            get: function get() {
              warn("filters.SpriteMaskFilter is an undocumented alias, please use SpriteMaskFilter from now on.");

              return core.SpriteMaskFilter;
            },
          },

          /**
           * @class
           * @private
           * @name PIXI.filters.VoidFilter
           * @see PIXI.filters.AlphaFilter
           * @deprecated since version 4.5.7
           */
          VoidFilter: {
            get: function get() {
              warn("VoidFilter has been renamed to AlphaFilter, please use PIXI.filters.AlphaFilter");

              return filters.AlphaFilter;
            },
          },
        });

        /**
         * @method
         * @name PIXI.utils.uuid
         * @see PIXI.utils.uid
         * @deprecated since version 3.0.6
         * @return {number} The uid
         */
        core.utils.uuid = function () {
          warn("utils.uuid() is deprecated, please use utils.uid() from now on.");

          return core.utils.uid();
        };

        /**
         * @method
         * @name PIXI.utils.canUseNewCanvasBlendModes
         * @see PIXI.CanvasTinter
         * @deprecated
         * @return {boolean} Can use blend modes.
         */
        core.utils.canUseNewCanvasBlendModes = function () {
          warn("utils.canUseNewCanvasBlendModes() is deprecated, please use CanvasTinter.canUseMultiply from now on");

          return core.CanvasTinter.canUseMultiply;
        };

        var saidHello = true;

        /**
         * @name PIXI.utils._saidHello
         * @type {boolean}
         * @see PIXI.utils.skipHello
         * @deprecated since 4.1.0
         */
        Object.defineProperty(core.utils, "_saidHello", {
          set: function set(bool) {
            if (bool) {
              warn("PIXI.utils._saidHello is deprecated, please use PIXI.utils.skipHello()");
              this.skipHello();
            }
            saidHello = bool;
          },
          get: function get() {
            return saidHello;
          },
        });

        if (prepare.BasePrepare) {
          /**
           * @method
           * @name PIXI.prepare.BasePrepare#register
           * @see PIXI.prepare.BasePrepare#registerFindHook
           * @deprecated since version 4.4.2
           * @param {Function} [addHook] - Function call that takes two parameters: `item:*, queue:Array`
           *        function must return `true` if it was able to add item to the queue.
           * @param {Function} [uploadHook] - Function call that takes two parameters: `prepare:CanvasPrepare, item:*` and
           *        function must return `true` if it was able to handle upload of item.
           * @return {PIXI.BasePrepare} Instance of plugin for chaining.
           */
          prepare.BasePrepare.prototype.register = function register(addHook, uploadHook) {
            warn(
              "renderer.plugins.prepare.register is now deprecated, " +
                "please use renderer.plugins.prepare.registerFindHook & renderer.plugins.prepare.registerUploadHook"
            );

            if (addHook) {
              this.registerFindHook(addHook);
            }

            if (uploadHook) {
              this.registerUploadHook(uploadHook);
            }

            return this;
          };
        }

        if (prepare.canvas) {
          /**
           * The number of graphics or textures to upload to the GPU.
           *
           * @name PIXI.prepare.canvas.UPLOADS_PER_FRAME
           * @static
           * @type {number}
           * @see PIXI.prepare.BasePrepare.limiter
           * @deprecated since 4.2.0
           */
          Object.defineProperty(prepare.canvas, "UPLOADS_PER_FRAME", {
            set: function set() {
              warn(
                "PIXI.CanvasPrepare.UPLOADS_PER_FRAME has been removed. Please set " +
                  "renderer.plugins.prepare.limiter.maxItemsPerFrame on your renderer"
              );
              // because we don't have a reference to the renderer, we can't actually set
              // the uploads per frame, so we'll have to stick with the warning.
            },
            get: function get() {
              warn("PIXI.CanvasPrepare.UPLOADS_PER_FRAME has been removed. Please use " + "renderer.plugins.prepare.limiter");

              return NaN;
            },
          });
        }

        if (prepare.webgl) {
          /**
           * The number of graphics or textures to upload to the GPU.
           *
           * @name PIXI.prepare.webgl.UPLOADS_PER_FRAME
           * @static
           * @type {number}
           * @see PIXI.prepare.BasePrepare.limiter
           * @deprecated since 4.2.0
           */
          Object.defineProperty(prepare.webgl, "UPLOADS_PER_FRAME", {
            set: function set() {
              warn(
                "PIXI.WebGLPrepare.UPLOADS_PER_FRAME has been removed. Please set " +
                  "renderer.plugins.prepare.limiter.maxItemsPerFrame on your renderer"
              );
              // because we don't have a reference to the renderer, we can't actually set
              // the uploads per frame, so we'll have to stick with the warning.
            },
            get: function get() {
              warn("PIXI.WebGLPrepare.UPLOADS_PER_FRAME has been removed. Please use " + "renderer.plugins.prepare.limiter");

              return NaN;
            },
          });
        }

        if (loaders.Loader) {
          var Resource = loaders.Resource;
          var Loader = loaders.Loader;

          Object.defineProperties(Resource.prototype, {
            isJson: {
              get: function get() {
                warn("The isJson property is deprecated, please use `resource.type === Resource.TYPE.JSON`.");

                return this.type === Resource.TYPE.JSON;
              },
            },
            isXml: {
              get: function get() {
                warn("The isXml property is deprecated, please use `resource.type === Resource.TYPE.XML`.");

                return this.type === Resource.TYPE.XML;
              },
            },
            isImage: {
              get: function get() {
                warn("The isImage property is deprecated, please use `resource.type === Resource.TYPE.IMAGE`.");

                return this.type === Resource.TYPE.IMAGE;
              },
            },
            isAudio: {
              get: function get() {
                warn("The isAudio property is deprecated, please use `resource.type === Resource.TYPE.AUDIO`.");

                return this.type === Resource.TYPE.AUDIO;
              },
            },
            isVideo: {
              get: function get() {
                warn("The isVideo property is deprecated, please use `resource.type === Resource.TYPE.VIDEO`.");

                return this.type === Resource.TYPE.VIDEO;
              },
            },
          });

          Object.defineProperties(Loader.prototype, {
            before: {
              get: function get() {
                warn("The before() method is deprecated, please use pre().");

                return this.pre;
              },
            },
            after: {
              get: function get() {
                warn("The after() method is deprecated, please use use().");

                return this.use;
              },
            },
          });
        }

        if (interaction.interactiveTarget) {
          /**
           * @name PIXI.interaction.interactiveTarget#defaultCursor
           * @static
           * @type {number}
           * @see PIXI.interaction.interactiveTarget#cursor
           * @deprecated since 4.3.0
           */
          Object.defineProperty(interaction.interactiveTarget, "defaultCursor", {
            set: function set(value) {
              warn("Property defaultCursor has been replaced with 'cursor'. ");
              this.cursor = value;
            },
            get: function get() {
              warn("Property defaultCursor has been replaced with 'cursor'. ");

              return this.cursor;
            },
          });
        }

        if (interaction.InteractionManager) {
          /**
           * @name PIXI.interaction.InteractionManager#defaultCursorStyle
           * @static
           * @type {string}
           * @see PIXI.interaction.InteractionManager#cursorStyles
           * @deprecated since 4.3.0
           */
          Object.defineProperty(interaction.InteractionManager, "defaultCursorStyle", {
            set: function set(value) {
              warn("Property defaultCursorStyle has been replaced with 'cursorStyles.default'. ");
              this.cursorStyles.default = value;
            },
            get: function get() {
              warn("Property defaultCursorStyle has been replaced with 'cursorStyles.default'. ");

              return this.cursorStyles.default;
            },
          });

          /**
           * @name PIXI.interaction.InteractionManager#currentCursorStyle
           * @static
           * @type {string}
           * @see PIXI.interaction.InteractionManager#cursorStyles
           * @deprecated since 4.3.0
           */
          Object.defineProperty(interaction.InteractionManager, "currentCursorStyle", {
            set: function set(value) {
              warn("Property currentCursorStyle has been removed." + "See the currentCursorMode property, which works differently.");
              this.currentCursorMode = value;
            },
            get: function get() {
              warn("Property currentCursorStyle has been removed." + "See the currentCursorMode property, which works differently.");

              return this.currentCursorMode;
            },
          });
        }
      }
      //# sourceMappingURL=deprecation.js.map

      /***/
    },
    /* 532 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      var _accessibleTarget = __webpack_require__(424);

      Object.defineProperty(exports, "accessibleTarget", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_accessibleTarget).default;
        },
      });

      var _AccessibilityManager = __webpack_require__(533);

      Object.defineProperty(exports, "AccessibilityManager", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_AccessibilityManager).default;
        },
      });

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      //# sourceMappingURL=index.js.map

      /***/
    },
    /* 533 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      var _core = __webpack_require__(344);

      var core = _interopRequireWildcard(_core);

      var _ismobilejs = __webpack_require__(378);

      var _ismobilejs2 = _interopRequireDefault(_ismobilejs);

      var _accessibleTarget = __webpack_require__(424);

      var _accessibleTarget2 = _interopRequireDefault(_accessibleTarget);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};
          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }
          newObj.default = obj;
          return newObj;
        }
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      // add some extra variables to the container..
      core.utils.mixins.delayMixin(core.DisplayObject.prototype, _accessibleTarget2.default);

      var KEY_CODE_TAB = 9;

      var DIV_TOUCH_SIZE = 100;
      var DIV_TOUCH_POS_X = 0;
      var DIV_TOUCH_POS_Y = 0;
      var DIV_TOUCH_ZINDEX = 2;

      var DIV_HOOK_SIZE = 1;
      var DIV_HOOK_POS_X = -1000;
      var DIV_HOOK_POS_Y = -1000;
      var DIV_HOOK_ZINDEX = 2;

      /**
       * The Accessibility manager recreates the ability to tab and have content read by screen
       * readers. This is very important as it can possibly help people with disabilities access pixi
       * content.
       *
       * Much like interaction any DisplayObject can be made accessible. This manager will map the
       * events as if the mouse was being used, minimizing the effort required to implement.
       *
       * An instance of this class is automatically created by default, and can be found at renderer.plugins.accessibility
       *
       * @class
       * @memberof PIXI.accessibility
       */

      var AccessibilityManager = (function () {
        /**
         * @param {PIXI.CanvasRenderer|PIXI.WebGLRenderer} renderer - A reference to the current renderer
         */
        function AccessibilityManager(renderer) {
          _classCallCheck(this, AccessibilityManager);

          if ((_ismobilejs2.default.tablet || _ismobilejs2.default.phone) && !navigator.isCocoonJS) {
            this.createTouchHook();
          }

          // first we create a div that will sit over the PixiJS element. This is where the div overlays will go.
          var div = document.createElement("div");

          div.style.width = DIV_TOUCH_SIZE + "px";
          div.style.height = DIV_TOUCH_SIZE + "px";
          div.style.position = "absolute";
          div.style.top = DIV_TOUCH_POS_X + "px";
          div.style.left = DIV_TOUCH_POS_Y + "px";
          div.style.zIndex = DIV_TOUCH_ZINDEX;

          /**
           * This is the dom element that will sit over the PixiJS element. This is where the div overlays will go.
           *
           * @type {HTMLElement}
           * @private
           */
          this.div = div;

          /**
           * A simple pool for storing divs.
           *
           * @type {*}
           * @private
           */
          this.pool = [];

          /**
           * This is a tick used to check if an object is no longer being rendered.
           *
           * @type {Number}
           * @private
           */
          this.renderId = 0;

          /**
           * Setting this to true will visually show the divs.
           *
           * @type {boolean}
           */
          this.debug = false;

          /**
           * The renderer this accessibility manager works for.
           *
           * @member {PIXI.SystemRenderer}
           */
          this.renderer = renderer;

          /**
           * The array of currently active accessible items.
           *
           * @member {Array<*>}
           * @private
           */
          this.children = [];

          /**
           * pre-bind the functions
           *
           * @private
           */
          this._onKeyDown = this._onKeyDown.bind(this);
          this._onMouseMove = this._onMouseMove.bind(this);

          /**
           * stores the state of the manager. If there are no accessible objects or the mouse is moving, this will be false.
           *
           * @member {Array<*>}
           * @private
           */
          this.isActive = false;
          this.isMobileAccessabillity = false;

          // let listen for tab.. once pressed we can fire up and show the accessibility layer
          window.addEventListener("keydown", this._onKeyDown, false);
        }

        /**
         * Creates the touch hooks.
         *
         */

        AccessibilityManager.prototype.createTouchHook = function createTouchHook() {
          var _this = this;

          var hookDiv = document.createElement("button");

          hookDiv.style.width = DIV_HOOK_SIZE + "px";
          hookDiv.style.height = DIV_HOOK_SIZE + "px";
          hookDiv.style.position = "absolute";
          hookDiv.style.top = DIV_HOOK_POS_X + "px";
          hookDiv.style.left = DIV_HOOK_POS_Y + "px";
          hookDiv.style.zIndex = DIV_HOOK_ZINDEX;
          hookDiv.style.backgroundColor = "#FF0000";
          hookDiv.title = "HOOK DIV";

          hookDiv.addEventListener("focus", function () {
            _this.isMobileAccessabillity = true;
            _this.activate();
            document.body.removeChild(hookDiv);
          });

          document.body.appendChild(hookDiv);
        };

        /**
         * Activating will cause the Accessibility layer to be shown. This is called when a user
         * preses the tab key.
         *
         * @private
         */

        AccessibilityManager.prototype.activate = function activate() {
          if (this.isActive) {
            return;
          }

          this.isActive = true;

          window.document.addEventListener("mousemove", this._onMouseMove, true);
          window.removeEventListener("keydown", this._onKeyDown, false);

          this.renderer.on("postrender", this.update, this);

          if (this.renderer.view.parentNode) {
            this.renderer.view.parentNode.appendChild(this.div);
          }
        };

        /**
         * Deactivating will cause the Accessibility layer to be hidden. This is called when a user moves
         * the mouse.
         *
         * @private
         */

        AccessibilityManager.prototype.deactivate = function deactivate() {
          if (!this.isActive || this.isMobileAccessabillity) {
            return;
          }

          this.isActive = false;

          window.document.removeEventListener("mousemove", this._onMouseMove, true);
          window.addEventListener("keydown", this._onKeyDown, false);

          this.renderer.off("postrender", this.update);

          if (this.div.parentNode) {
            this.div.parentNode.removeChild(this.div);
          }
        };

        /**
         * This recursive function will run through the scene graph and add any new accessible objects to the DOM layer.
         *
         * @private
         * @param {PIXI.Container} displayObject - The DisplayObject to check.
         */

        AccessibilityManager.prototype.updateAccessibleObjects = function updateAccessibleObjects(displayObject) {
          if (!displayObject.visible) {
            return;
          }

          if (displayObject.accessible && displayObject.interactive) {
            if (!displayObject._accessibleActive) {
              this.addChild(displayObject);
            }

            displayObject.renderId = this.renderId;
          }

          var children = displayObject.children;

          for (var i = 0; i < children.length; i++) {
            this.updateAccessibleObjects(children[i]);
          }
        };

        /**
         * Before each render this function will ensure that all divs are mapped correctly to their DisplayObjects.
         *
         * @private
         */

        AccessibilityManager.prototype.update = function update() {
          if (!this.renderer.renderingToScreen) {
            return;
          }

          // update children...
          this.updateAccessibleObjects(this.renderer._lastObjectRendered);

          var rect = this.renderer.view.getBoundingClientRect();
          var sx = rect.width / this.renderer.width;
          var sy = rect.height / this.renderer.height;

          var div = this.div;

          div.style.left = rect.left + "px";
          div.style.top = rect.top + "px";
          div.style.width = this.renderer.width + "px";
          div.style.height = this.renderer.height + "px";

          for (var i = 0; i < this.children.length; i++) {
            var child = this.children[i];

            if (child.renderId !== this.renderId) {
              child._accessibleActive = false;

              core.utils.removeItems(this.children, i, 1);
              this.div.removeChild(child._accessibleDiv);
              this.pool.push(child._accessibleDiv);
              child._accessibleDiv = null;

              i--;

              if (this.children.length === 0) {
                this.deactivate();
              }
            } else {
              // map div to display..
              div = child._accessibleDiv;
              var hitArea = child.hitArea;
              var wt = child.worldTransform;

              if (child.hitArea) {
                div.style.left = (wt.tx + hitArea.x * wt.a) * sx + "px";
                div.style.top = (wt.ty + hitArea.y * wt.d) * sy + "px";

                div.style.width = hitArea.width * wt.a * sx + "px";
                div.style.height = hitArea.height * wt.d * sy + "px";
              } else {
                hitArea = child.getBounds();

                this.capHitArea(hitArea);

                div.style.left = hitArea.x * sx + "px";
                div.style.top = hitArea.y * sy + "px";

                div.style.width = hitArea.width * sx + "px";
                div.style.height = hitArea.height * sy + "px";

                // update button titles and hints if they exist and they've changed
                if (div.title !== child.accessibleTitle && child.accessibleTitle !== null) {
                  div.title = child.accessibleTitle;
                }
                if (div.getAttribute("aria-label") !== child.accessibleHint && child.accessibleHint !== null) {
                  div.setAttribute("aria-label", child.accessibleHint);
                }
              }
            }
          }

          // increment the render id..
          this.renderId++;
        };

        /**
         * TODO: docs.
         *
         * @param {Rectangle} hitArea - TODO docs
         */

        AccessibilityManager.prototype.capHitArea = function capHitArea(hitArea) {
          if (hitArea.x < 0) {
            hitArea.width += hitArea.x;
            hitArea.x = 0;
          }

          if (hitArea.y < 0) {
            hitArea.height += hitArea.y;
            hitArea.y = 0;
          }

          if (hitArea.x + hitArea.width > this.renderer.width) {
            hitArea.width = this.renderer.width - hitArea.x;
          }

          if (hitArea.y + hitArea.height > this.renderer.height) {
            hitArea.height = this.renderer.height - hitArea.y;
          }
        };

        /**
         * Adds a DisplayObject to the accessibility manager
         *
         * @private
         * @param {DisplayObject} displayObject - The child to make accessible.
         */

        AccessibilityManager.prototype.addChild = function addChild(displayObject) {
          //    this.activate();

          var div = this.pool.pop();

          if (!div) {
            div = document.createElement("button");

            div.style.width = DIV_TOUCH_SIZE + "px";
            div.style.height = DIV_TOUCH_SIZE + "px";
            div.style.backgroundColor = this.debug ? "rgba(255,0,0,0.5)" : "transparent";
            div.style.position = "absolute";
            div.style.zIndex = DIV_TOUCH_ZINDEX;
            div.style.borderStyle = "none";

            // ARIA attributes ensure that button title and hint updates are announced properly
            if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
              // Chrome doesn't need aria-live to work as intended; in fact it just gets more confused.
              div.setAttribute("aria-live", "off");
            } else {
              div.setAttribute("aria-live", "polite");
            }

            if (navigator.userAgent.match(/rv:.*Gecko\//)) {
              // FireFox needs this to announce only the new button name
              div.setAttribute("aria-relevant", "additions");
            } else {
              // required by IE, other browsers don't much care
              div.setAttribute("aria-relevant", "text");
            }

            div.addEventListener("click", this._onClick.bind(this));
            div.addEventListener("focus", this._onFocus.bind(this));
            div.addEventListener("focusout", this._onFocusOut.bind(this));
          }

          if (displayObject.accessibleTitle && displayObject.accessibleTitle !== null) {
            div.title = displayObject.accessibleTitle;
          } else if (!displayObject.accessibleHint || displayObject.accessibleHint === null) {
            div.title = "displayObject " + displayObject.tabIndex;
          }

          if (displayObject.accessibleHint && displayObject.accessibleHint !== null) {
            div.setAttribute("aria-label", displayObject.accessibleHint);
          }

          //

          displayObject._accessibleActive = true;
          displayObject._accessibleDiv = div;
          div.displayObject = displayObject;

          this.children.push(displayObject);
          this.div.appendChild(displayObject._accessibleDiv);
          displayObject._accessibleDiv.tabIndex = displayObject.tabIndex;
        };

        /**
         * Maps the div button press to pixi's InteractionManager (click)
         *
         * @private
         * @param {MouseEvent} e - The click event.
         */

        AccessibilityManager.prototype._onClick = function _onClick(e) {
          var interactionManager = this.renderer.plugins.interaction;

          interactionManager.dispatchEvent(e.target.displayObject, "click", interactionManager.eventData);
        };

        /**
         * Maps the div focus events to pixi's InteractionManager (mouseover)
         *
         * @private
         * @param {FocusEvent} e - The focus event.
         */

        AccessibilityManager.prototype._onFocus = function _onFocus(e) {
          if (!e.target.getAttribute("aria-live", "off")) {
            e.target.setAttribute("aria-live", "assertive");
          }
          var interactionManager = this.renderer.plugins.interaction;

          interactionManager.dispatchEvent(e.target.displayObject, "mouseover", interactionManager.eventData);
        };

        /**
         * Maps the div focus events to pixi's InteractionManager (mouseout)
         *
         * @private
         * @param {FocusEvent} e - The focusout event.
         */

        AccessibilityManager.prototype._onFocusOut = function _onFocusOut(e) {
          if (!e.target.getAttribute("aria-live", "off")) {
            e.target.setAttribute("aria-live", "polite");
          }
          var interactionManager = this.renderer.plugins.interaction;

          interactionManager.dispatchEvent(e.target.displayObject, "mouseout", interactionManager.eventData);
        };

        /**
         * Is called when a key is pressed
         *
         * @private
         * @param {KeyboardEvent} e - The keydown event.
         */

        AccessibilityManager.prototype._onKeyDown = function _onKeyDown(e) {
          if (e.keyCode !== KEY_CODE_TAB) {
            return;
          }

          this.activate();
        };

        /**
         * Is called when the mouse moves across the renderer element
         *
         * @private
         * @param {MouseEvent} e - The mouse event.
         */

        AccessibilityManager.prototype._onMouseMove = function _onMouseMove(e) {
          if (e.movementX === 0 && e.movementY === 0) {
            return;
          }

          this.deactivate();
        };

        /**
         * Destroys the accessibility manager
         *
         */

        AccessibilityManager.prototype.destroy = function destroy() {
          this.div = null;

          for (var i = 0; i < this.children.length; i++) {
            this.children[i].div = null;
          }

          window.document.removeEventListener("mousemove", this._onMouseMove, true);
          window.removeEventListener("keydown", this._onKeyDown);

          this.pool = null;
          this.children = null;
          this.renderer = null;
        };

        return AccessibilityManager;
      })();

      exports.default = AccessibilityManager;

      core.WebGLRenderer.registerPlugin("accessibility", AccessibilityManager);
      core.CanvasRenderer.registerPlugin("accessibility", AccessibilityManager);
      //# sourceMappingURL=AccessibilityManager.js.map

      /***/
    },
    /* 534 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      var _WebGLExtract = __webpack_require__(535);

      Object.defineProperty(exports, "webgl", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_WebGLExtract).default;
        },
      });

      var _CanvasExtract = __webpack_require__(536);

      Object.defineProperty(exports, "canvas", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_CanvasExtract).default;
        },
      });

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      //# sourceMappingURL=index.js.map

      /***/
    },
    /* 535 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      var _core = __webpack_require__(344);

      var core = _interopRequireWildcard(_core);

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};
          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }
          newObj.default = obj;
          return newObj;
        }
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var TEMP_RECT = new core.Rectangle();
      var BYTES_PER_PIXEL = 4;

      /**
       * The extract manager provides functionality to export content from the renderers.
       *
       * An instance of this class is automatically created by default, and can be found at renderer.plugins.extract
       *
       * @class
       * @memberof PIXI.extract
       */

      var WebGLExtract = (function () {
        /**
         * @param {PIXI.WebGLRenderer} renderer - A reference to the current renderer
         */
        function WebGLExtract(renderer) {
          _classCallCheck(this, WebGLExtract);

          this.renderer = renderer;
          /**
           * Collection of methods for extracting data (image, pixels, etc.) from a display object or render texture
           *
           * @member {PIXI.extract.WebGLExtract} extract
           * @memberof PIXI.WebGLRenderer#
           * @see PIXI.extract.WebGLExtract
           */
          renderer.extract = this;
        }

        /**
         * Will return a HTML Image of the target
         *
         * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture
         *  to convert. If left empty will use use the main renderer
         * @return {HTMLImageElement} HTML Image of the target
         */

        WebGLExtract.prototype.image = function image(target) {
          var image = new Image();

          image.src = this.base64(target);

          return image;
        };

        /**
         * Will return a a base64 encoded string of this target. It works by calling
         *  `WebGLExtract.getCanvas` and then running toDataURL on that.
         *
         * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture
         *  to convert. If left empty will use use the main renderer
         * @return {string} A base64 encoded string of the texture.
         */

        WebGLExtract.prototype.base64 = function base64(target) {
          return this.canvas(target).toDataURL();
        };

        /**
         * Creates a Canvas element, renders this target to it and then returns it.
         *
         * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture
         *  to convert. If left empty will use use the main renderer
         * @return {HTMLCanvasElement} A Canvas element with the texture rendered on.
         */

        WebGLExtract.prototype.canvas = function canvas(target) {
          var renderer = this.renderer;
          var textureBuffer = void 0;
          var resolution = void 0;
          var frame = void 0;
          var flipY = false;
          var renderTexture = void 0;
          var generated = false;

          if (target) {
            if (target instanceof core.RenderTexture) {
              renderTexture = target;
            } else {
              renderTexture = this.renderer.generateTexture(target);
              generated = true;
            }
          }

          if (renderTexture) {
            textureBuffer = renderTexture.baseTexture._glRenderTargets[this.renderer.CONTEXT_UID];
            resolution = textureBuffer.resolution;
            frame = renderTexture.frame;
            flipY = false;
          } else {
            textureBuffer = this.renderer.rootRenderTarget;
            resolution = textureBuffer.resolution;
            flipY = true;

            frame = TEMP_RECT;
            frame.width = textureBuffer.size.width;
            frame.height = textureBuffer.size.height;
          }

          var width = Math.floor(frame.width * resolution + 1e-4);
          var height = Math.floor(frame.height * resolution + 1e-4);

          var canvasBuffer = new core.CanvasRenderTarget(width, height, 1);

          if (textureBuffer) {
            // bind the buffer
            renderer.bindRenderTarget(textureBuffer);

            // set up an array of pixels
            var webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height);

            // read pixels to the array
            var gl = renderer.gl;

            gl.readPixels(frame.x * resolution, frame.y * resolution, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);

            // add the pixels to the canvas
            var canvasData = canvasBuffer.context.getImageData(0, 0, width, height);

            canvasData.data.set(webglPixels);

            canvasBuffer.context.putImageData(canvasData, 0, 0);

            // pulling pixels
            if (flipY) {
              canvasBuffer.context.scale(1, -1);
              canvasBuffer.context.drawImage(canvasBuffer.canvas, 0, -height);
            }
          }

          if (generated) {
            renderTexture.destroy(true);
          }
          // send the canvas back..

          return canvasBuffer.canvas;
        };

        /**
         * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA
         * order, with integer values between 0 and 255 (included).
         *
         * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture
         *  to convert. If left empty will use use the main renderer
         * @return {Uint8ClampedArray} One-dimensional array containing the pixel data of the entire texture
         */

        WebGLExtract.prototype.pixels = function pixels(target) {
          var renderer = this.renderer;
          var textureBuffer = void 0;
          var resolution = void 0;
          var frame = void 0;
          var renderTexture = void 0;
          var generated = false;

          if (target) {
            if (target instanceof core.RenderTexture) {
              renderTexture = target;
            } else {
              renderTexture = this.renderer.generateTexture(target);
              generated = true;
            }
          }

          if (renderTexture) {
            textureBuffer = renderTexture.baseTexture._glRenderTargets[this.renderer.CONTEXT_UID];
            resolution = textureBuffer.resolution;
            frame = renderTexture.frame;
          } else {
            textureBuffer = this.renderer.rootRenderTarget;
            resolution = textureBuffer.resolution;

            frame = TEMP_RECT;
            frame.width = textureBuffer.size.width;
            frame.height = textureBuffer.size.height;
          }

          var width = frame.width * resolution;
          var height = frame.height * resolution;

          var webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height);

          if (textureBuffer) {
            // bind the buffer
            renderer.bindRenderTarget(textureBuffer);
            // read pixels to the array
            var gl = renderer.gl;

            gl.readPixels(frame.x * resolution, frame.y * resolution, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);
          }

          if (generated) {
            renderTexture.destroy(true);
          }

          return webglPixels;
        };

        /**
         * Destroys the extract
         *
         */

        WebGLExtract.prototype.destroy = function destroy() {
          this.renderer.extract = null;
          this.renderer = null;
        };

        return WebGLExtract;
      })();

      exports.default = WebGLExtract;

      core.WebGLRenderer.registerPlugin("extract", WebGLExtract);
      //# sourceMappingURL=WebGLExtract.js.map

      /***/
    },
    /* 536 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      var _core = __webpack_require__(344);

      var core = _interopRequireWildcard(_core);

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};
          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }
          newObj.default = obj;
          return newObj;
        }
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var TEMP_RECT = new core.Rectangle();

      /**
       * The extract manager provides functionality to export content from the renderers.
       *
       * An instance of this class is automatically created by default, and can be found at renderer.plugins.extract
       *
       * @class
       * @memberof PIXI.extract
       */

      var CanvasExtract = (function () {
        /**
         * @param {PIXI.CanvasRenderer} renderer - A reference to the current renderer
         */
        function CanvasExtract(renderer) {
          _classCallCheck(this, CanvasExtract);

          this.renderer = renderer;
          /**
           * Collection of methods for extracting data (image, pixels, etc.) from a display object or render texture
           *
           * @member {PIXI.extract.CanvasExtract} extract
           * @memberof PIXI.CanvasRenderer#
           * @see PIXI.extract.CanvasExtract
           */
          renderer.extract = this;
        }

        /**
         * Will return a HTML Image of the target
         *
         * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture
         *  to convert. If left empty will use use the main renderer
         * @return {HTMLImageElement} HTML Image of the target
         */

        CanvasExtract.prototype.image = function image(target) {
          var image = new Image();

          image.src = this.base64(target);

          return image;
        };

        /**
         * Will return a a base64 encoded string of this target. It works by calling
         *  `CanvasExtract.getCanvas` and then running toDataURL on that.
         *
         * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture
         *  to convert. If left empty will use use the main renderer
         * @return {string} A base64 encoded string of the texture.
         */

        CanvasExtract.prototype.base64 = function base64(target) {
          return this.canvas(target).toDataURL();
        };

        /**
         * Creates a Canvas element, renders this target to it and then returns it.
         *
         * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture
         *  to convert. If left empty will use use the main renderer
         * @return {HTMLCanvasElement} A Canvas element with the texture rendered on.
         */

        CanvasExtract.prototype.canvas = function canvas(target) {
          var renderer = this.renderer;
          var context = void 0;
          var resolution = void 0;
          var frame = void 0;
          var renderTexture = void 0;

          if (target) {
            if (target instanceof core.RenderTexture) {
              renderTexture = target;
            } else {
              renderTexture = renderer.generateTexture(target);
            }
          }

          if (renderTexture) {
            context = renderTexture.baseTexture._canvasRenderTarget.context;
            resolution = renderTexture.baseTexture._canvasRenderTarget.resolution;
            frame = renderTexture.frame;
          } else {
            context = renderer.rootContext;
            resolution = renderer.resolution;
            frame = TEMP_RECT;
            frame.width = this.renderer.width;
            frame.height = this.renderer.height;
          }

          var width = Math.floor(frame.width * resolution + 1e-4);
          var height = Math.floor(frame.height * resolution + 1e-4);

          var canvasBuffer = new core.CanvasRenderTarget(width, height, 1);
          var canvasData = context.getImageData(frame.x * resolution, frame.y * resolution, width, height);

          canvasBuffer.context.putImageData(canvasData, 0, 0);

          // send the canvas back..
          return canvasBuffer.canvas;
        };

        /**
         * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA
         * order, with integer values between 0 and 255 (included).
         *
         * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture
         *  to convert. If left empty will use use the main renderer
         * @return {Uint8ClampedArray} One-dimensional array containing the pixel data of the entire texture
         */

        CanvasExtract.prototype.pixels = function pixels(target) {
          var renderer = this.renderer;
          var context = void 0;
          var resolution = void 0;
          var frame = void 0;
          var renderTexture = void 0;

          if (target) {
            if (target instanceof core.RenderTexture) {
              renderTexture = target;
            } else {
              renderTexture = renderer.generateTexture(target);
            }
          }

          if (renderTexture) {
            context = renderTexture.baseTexture._canvasRenderTarget.context;
            resolution = renderTexture.baseTexture._canvasRenderTarget.resolution;
            frame = renderTexture.frame;
          } else {
            context = renderer.rootContext;

            frame = TEMP_RECT;
            frame.width = renderer.width;
            frame.height = renderer.height;
          }

          return context.getImageData(0, 0, frame.width * resolution, frame.height * resolution).data;
        };

        /**
         * Destroys the extract
         *
         */

        CanvasExtract.prototype.destroy = function destroy() {
          this.renderer.extract = null;
          this.renderer = null;
        };

        return CanvasExtract;
      })();

      exports.default = CanvasExtract;

      core.CanvasRenderer.registerPlugin("extract", CanvasExtract);
      //# sourceMappingURL=CanvasExtract.js.map

      /***/
    },
    /* 537 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      var _createClass = (function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      })();

      var _core = __webpack_require__(344);

      var core = _interopRequireWildcard(_core);

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};
          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }
          newObj.default = obj;
          return newObj;
        }
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: { value: subClass, enumerable: false, writable: true, configurable: true },
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass);
      }

      /**
       * @typedef PIXI.extras.AnimatedSprite~FrameObject
       * @type {object}
       * @property {PIXI.Texture} texture - The {@link PIXI.Texture} of the frame
       * @property {number} time - the duration of the frame in ms
       */

      /**
       * An AnimatedSprite is a simple way to display an animation depicted by a list of textures.
       *
       * ```js
       * let alienImages = ["image_sequence_01.png","image_sequence_02.png","image_sequence_03.png","image_sequence_04.png"];
       * let textureArray = [];
       *
       * for (let i=0; i < 4; i++)
       * {
       *      let texture = PIXI.Texture.fromImage(alienImages[i]);
       *      textureArray.push(texture);
       * };
       *
       * let animatedSprite = new PIXI.extras.AnimatedSprite(textureArray);
       * ```
       *
       * The more efficient and simpler way to create an animated sprite is using a {@link PIXI.Spritesheet}
       * containing the animation definitions:
       *
       * ```js
       * PIXI.loader.add("assets/spritesheet.json").load(setup);
       *
       * function setup() {
       *   let sheet = PIXI.loader.resources["assets/spritesheet.json"].spritesheet;
       *   animatedSprite = new PIXI.extras.AnimatedSprite(sheet.animations["image_sequence"]);
       *   ...
       * }
       * ```
       *
       * @class
       * @extends PIXI.Sprite
       * @memberof PIXI.extras
       */
      var AnimatedSprite = (function (_core$Sprite) {
        _inherits(AnimatedSprite, _core$Sprite);

        /**
         * @param {PIXI.Texture[]|PIXI.extras.AnimatedSprite~FrameObject[]} textures - an array of {@link PIXI.Texture} or frame
         *  objects that make up the animation
         * @param {boolean} [autoUpdate=true] - Whether to use PIXI.ticker.shared to auto update animation time.
         */
        function AnimatedSprite(textures, autoUpdate) {
          _classCallCheck(this, AnimatedSprite);

          /**
           * @private
           */
          var _this = _possibleConstructorReturn(
            this,
            _core$Sprite.call(this, textures[0] instanceof core.Texture ? textures[0] : textures[0].texture)
          );

          _this._textures = null;

          /**
           * @private
           */
          _this._durations = null;

          _this.textures = textures;

          /**
           * `true` uses PIXI.ticker.shared to auto update animation time.
           * @type {boolean}
           * @default true
           * @private
           */
          _this._autoUpdate = autoUpdate !== false;

          /**
           * The speed that the AnimatedSprite will play at. Higher is faster, lower is slower
           *
           * @member {number}
           * @default 1
           */
          _this.animationSpeed = 1;

          /**
           * Whether or not the animate sprite repeats after playing.
           *
           * @member {boolean}
           * @default true
           */
          _this.loop = true;

          /**
           * Update anchor to [Texture's defaultAnchor]{@link PIXI.Texture#defaultAnchor} when frame changes.
           *
           * Useful with [sprite sheet animations]{@link PIXI.Spritesheet#animations} created with tools.
           * Changing anchor for each frame allows to pin sprite origin to certain moving feature
           * of the frame (e.g. left foot).
           *
           * Note: Enabling this will override any previously set `anchor` on each frame change.
           *
           * @member {boolean}
           * @default false
           */
          _this.updateAnchor = false;

          /**
           * Function to call when a AnimatedSprite finishes playing
           *
           * @member {Function}
           */
          _this.onComplete = null;

          /**
           * Function to call when a AnimatedSprite changes which texture is being rendered
           *
           * @member {Function}
           */
          _this.onFrameChange = null;

          /**
           * Function to call when 'loop' is true, and an AnimatedSprite is played and loops around to start again
           *
           * @member {Function}
           */
          _this.onLoop = null;

          /**
           * Elapsed time since animation has been started, used internally to display current texture
           *
           * @member {number}
           * @private
           */
          _this._currentTime = 0;

          /**
           * Indicates if the AnimatedSprite is currently playing
           *
           * @member {boolean}
           * @readonly
           */
          _this.playing = false;
          return _this;
        }

        /**
         * Stops the AnimatedSprite
         *
         */

        AnimatedSprite.prototype.stop = function stop() {
          if (!this.playing) {
            return;
          }

          this.playing = false;
          if (this._autoUpdate) {
            core.ticker.shared.remove(this.update, this);
          }
        };

        /**
         * Plays the AnimatedSprite
         *
         */

        AnimatedSprite.prototype.play = function play() {
          if (this.playing) {
            return;
          }

          this.playing = true;
          if (this._autoUpdate) {
            core.ticker.shared.add(this.update, this, core.UPDATE_PRIORITY.HIGH);
          }
        };

        /**
         * Stops the AnimatedSprite and goes to a specific frame
         *
         * @param {number} frameNumber - frame index to stop at
         */

        AnimatedSprite.prototype.gotoAndStop = function gotoAndStop(frameNumber) {
          this.stop();

          var previousFrame = this.currentFrame;

          this._currentTime = frameNumber;

          if (previousFrame !== this.currentFrame) {
            this.updateTexture();
          }
        };

        /**
         * Goes to a specific frame and begins playing the AnimatedSprite
         *
         * @param {number} frameNumber - frame index to start at
         */

        AnimatedSprite.prototype.gotoAndPlay = function gotoAndPlay(frameNumber) {
          var previousFrame = this.currentFrame;

          this._currentTime = frameNumber;

          if (previousFrame !== this.currentFrame) {
            this.updateTexture();
          }

          this.play();
        };

        /**
         * Updates the object transform for rendering.
         *
         * @private
         * @param {number} deltaTime - Time since last tick.
         */

        AnimatedSprite.prototype.update = function update(deltaTime) {
          var elapsed = this.animationSpeed * deltaTime;
          var previousFrame = this.currentFrame;

          if (this._durations !== null) {
            var lag = (this._currentTime % 1) * this._durations[this.currentFrame];

            lag += (elapsed / 60) * 1000;

            while (lag < 0) {
              this._currentTime--;
              lag += this._durations[this.currentFrame];
            }

            var sign = Math.sign(this.animationSpeed * deltaTime);

            this._currentTime = Math.floor(this._currentTime);

            while (lag >= this._durations[this.currentFrame]) {
              lag -= this._durations[this.currentFrame] * sign;
              this._currentTime += sign;
            }

            this._currentTime += lag / this._durations[this.currentFrame];
          } else {
            this._currentTime += elapsed;
          }

          if (this._currentTime < 0 && !this.loop) {
            this.gotoAndStop(0);

            if (this.onComplete) {
              this.onComplete();
            }
          } else if (this._currentTime >= this._textures.length && !this.loop) {
            this.gotoAndStop(this._textures.length - 1);

            if (this.onComplete) {
              this.onComplete();
            }
          } else if (previousFrame !== this.currentFrame) {
            if (this.loop && this.onLoop) {
              if (this.animationSpeed > 0 && this.currentFrame < previousFrame) {
                this.onLoop();
              } else if (this.animationSpeed < 0 && this.currentFrame > previousFrame) {
                this.onLoop();
              }
            }

            this.updateTexture();
          }
        };

        /**
         * Updates the displayed texture to match the current frame index
         *
         * @private
         */

        AnimatedSprite.prototype.updateTexture = function updateTexture() {
          this._texture = this._textures[this.currentFrame];
          this._textureID = -1;
          this.cachedTint = 0xffffff;

          if (this.updateAnchor) {
            this._anchor.copy(this._texture.defaultAnchor);
          }

          if (this.onFrameChange) {
            this.onFrameChange(this.currentFrame);
          }
        };

        /**
         * Stops the AnimatedSprite and destroys it
         *
         * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
         *  have been set to that value
         * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
         *      method called as well. 'options' will be passed on to those calls.
         * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well
         * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well
         */

        AnimatedSprite.prototype.destroy = function destroy(options) {
          this.stop();
          _core$Sprite.prototype.destroy.call(this, options);
        };

        /**
         * A short hand way of creating a movieclip from an array of frame ids
         *
         * @static
         * @param {string[]} frames - The array of frames ids the movieclip will use as its texture frames
         * @return {AnimatedSprite} The new animated sprite with the specified frames.
         */

        AnimatedSprite.fromFrames = function fromFrames(frames) {
          var textures = [];

          for (var i = 0; i < frames.length; ++i) {
            textures.push(core.Texture.fromFrame(frames[i]));
          }

          return new AnimatedSprite(textures);
        };

        /**
         * A short hand way of creating a movieclip from an array of image ids
         *
         * @static
         * @param {string[]} images - the array of image urls the movieclip will use as its texture frames
         * @return {AnimatedSprite} The new animate sprite with the specified images as frames.
         */

        AnimatedSprite.fromImages = function fromImages(images) {
          var textures = [];

          for (var i = 0; i < images.length; ++i) {
            textures.push(core.Texture.fromImage(images[i]));
          }

          return new AnimatedSprite(textures);
        };

        /**
         * totalFrames is the total number of frames in the AnimatedSprite. This is the same as number of textures
         * assigned to the AnimatedSprite.
         *
         * @readonly
         * @member {number}
         * @default 0
         */

        _createClass(AnimatedSprite, [
          {
            key: "totalFrames",
            get: function get() {
              return this._textures.length;
            },

            /**
             * The array of textures used for this AnimatedSprite
             *
             * @member {PIXI.Texture[]}
             */
          },
          {
            key: "textures",
            get: function get() {
              return this._textures;
            },
            set: function set(
              value // eslint-disable-line require-jsdoc
            ) {
              if (value[0] instanceof core.Texture) {
                this._textures = value;
                this._durations = null;
              } else {
                this._textures = [];
                this._durations = [];

                for (var i = 0; i < value.length; i++) {
                  this._textures.push(value[i].texture);
                  this._durations.push(value[i].time);
                }
              }
              this.gotoAndStop(0);
              this.updateTexture();
            },

            /**
             * The AnimatedSprites current frame index
             *
             * @member {number}
             * @readonly
             */
          },
          {
            key: "currentFrame",
            get: function get() {
              var currentFrame = Math.floor(this._currentTime) % this._textures.length;

              if (currentFrame < 0) {
                currentFrame += this._textures.length;
              }

              return currentFrame;
            },
          },
        ]);

        return AnimatedSprite;
      })(core.Sprite);

      exports.default = AnimatedSprite;
      //# sourceMappingURL=AnimatedSprite.js.map

      /***/
    },
    /* 538 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.__esModule = true;

      var _createClass = (function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      })();

      var _core = __webpack_require__(344);

      var core = _interopRequireWildcard(_core);

      var _CanvasTinter = __webpack_require__(364);

      var _CanvasTinter2 = _interopRequireDefault(_CanvasTinter);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};
          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }
          newObj.default = obj;
          return newObj;
        }
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: { value: subClass, enumerable: false, writable: true, configurable: true },
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass);
      }

      var tempPoint = new core.Point();

      /**
       * A tiling sprite is a fast way of rendering a tiling image
       *
       * @class
       * @extends PIXI.Sprite
       * @memberof PIXI.extras
       */

      var TilingSprite = function (_core$Sprite) {
        _inherits(TilingSprite, _core$Sprite);

        /**
         * @param {PIXI.Texture} texture - the texture of the tiling sprite
         * @param {number} [width=100] - the width of the tiling sprite
         * @param {number} [height=100] - the height of the tiling sprite
         */
        function TilingSprite(texture) {
          var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
          var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;

          _classCallCheck(this, TilingSprite);

          /**
           * Tile transform
           *
           * @member {PIXI.TransformStatic}
           */
          var _this = _possibleConstructorReturn(this, _core$Sprite.call(this, texture));

          _this.tileTransform = new core.TransformStatic();

          // /// private

          /**
           * The with of the tiling sprite
           *
           * @member {number}
           * @private
           */
          _this._width = width;

          /**
           * The height of the tiling sprite
           *
           * @member {number}
           * @private
           */
          _this._height = height;

          /**
           * Canvas pattern
           *
           * @type {CanvasPattern}
           * @private
           */
          _this._canvasPattern = null;

          /**
           * transform that is applied to UV to get the texture coords
           *
           * @member {PIXI.TextureMatrix}
           */
          _this.uvTransform = texture.transform || new core.TextureMatrix(texture);

          /**
           * Plugin that is responsible for rendering this element.
           * Allows to customize the rendering process without overriding '_renderWebGL' method.
           *
           * @member {string}
           * @default 'tilingSprite'
           */
          _this.pluginName = "tilingSprite";

          /**
           * Whether or not anchor affects uvs
           *
           * @member {boolean}
           * @default false
           */
          _this.uvRespectAnchor = false;
          return _this;
        }
        /**
         * Changes frame clamping in corresponding textureTransform, shortcut
         * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas
         *
         * @default 0.5
         * @member {number}
         */

        /**
         * @private
         */
        TilingSprite.prototype._onTextureUpdate = function _onTextureUpdate() {
          if (this.uvTransform) {
            this.uvTransform.texture = this._texture;
          }
          this.cachedTint = 0xffffff;
        };

        /**
         * Renders the object using the WebGL renderer
         *
         * @private
         * @param {PIXI.WebGLRenderer} renderer - The renderer
         */

        TilingSprite.prototype._renderWebGL = function _renderWebGL(renderer) {
          // tweak our texture temporarily..
          var texture = this._texture;

          if (!texture || !texture.valid) {
            return;
          }

          this.tileTransform.updateLocalTransform();
          this.uvTransform.update();

          renderer.setObjectRenderer(renderer.plugins[this.pluginName]);
          renderer.plugins[this.pluginName].render(this);
        };

        /**
         * Renders the object using the Canvas renderer
         *
         * @private
         * @param {PIXI.CanvasRenderer} renderer - a reference to the canvas renderer
         */

        TilingSprite.prototype._renderCanvas = function _renderCanvas(renderer) {
          var texture = this._texture;

          if (!texture.baseTexture.hasLoaded) {
            return;
          }

          var context = renderer.context;
          var transform = this.worldTransform;
          var resolution = renderer.resolution;
          var isTextureRotated = texture.rotate === 2;
          var baseTexture = texture.baseTexture;
          var baseTextureResolution = baseTexture.resolution;
          var modX = ((this.tilePosition.x / this.tileScale.x) % texture.orig.width) * baseTextureResolution;
          var modY = ((this.tilePosition.y / this.tileScale.y) % texture.orig.height) * baseTextureResolution;

          // create a nice shiny pattern!
          if (this._textureID !== this._texture._updateID || this.cachedTint !== this.tint) {
            this._textureID = this._texture._updateID;
            // cut an object from a spritesheet..
            var tempCanvas = new core.CanvasRenderTarget(texture.orig.width, texture.orig.height, baseTextureResolution);

            // Tint the tiling sprite
            if (this.tint !== 0xffffff) {
              this.tintedTexture = _CanvasTinter2.default.getTintedTexture(this, this.tint);
              tempCanvas.context.drawImage(this.tintedTexture, 0, 0);
            } else {
              var sx = texture._frame.x * baseTextureResolution;
              var sy = texture._frame.y * baseTextureResolution;
              var sWidth = texture._frame.width * baseTextureResolution;
              var sHeight = texture._frame.height * baseTextureResolution;
              var dWidth = (texture.trim ? texture.trim.width : texture.orig.width) * baseTextureResolution;
              var dHeight = (texture.trim ? texture.trim.height : texture.orig.height) * baseTextureResolution;
              var dx = (texture.trim ? texture.trim.x : 0) * baseTextureResolution;
              var dy = (texture.trim ? texture.trim.y : 0) * baseTextureResolution;

              if (isTextureRotated) {
                // Apply rotation and transform
                tempCanvas.context.rotate(-Math.PI / 2);
                tempCanvas.context.translate(-dHeight, 0);
                tempCanvas.context.drawImage(baseTexture.source, sx, sy, sWidth, sHeight, -dy, dx, dHeight, dWidth);
              } else {
                tempCanvas.context.drawImage(baseTexture.source, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
              }
            }

            this.cachedTint = this.tint;
            this._canvasPattern = tempCanvas.context.createPattern(tempCanvas.canvas, "repeat");
          }

          // set context state..
          context.globalAlpha = this.worldAlpha;
          context.setTransform(
            transform.a * resolution,
            transform.b * resolution,
            transform.c * resolution,
            transform.d * resolution,
            transform.tx * resolution,
            transform.ty * resolution
          );

          renderer.setBlendMode(this.blendMode);

          // fill the pattern!
          context.fillStyle = this._canvasPattern;

          // TODO - this should be rolled into the setTransform above..
          context.scale(this.tileScale.x / baseTextureResolution, this.tileScale.y / baseTextureResolution);

          var anchorX = this.anchor.x * -this._width * baseTextureResolution;
          var anchorY = this.anchor.y * -this._height * baseTextureResolution;

          if (this.uvRespectAnchor) {
            context.translate(modX, modY);

            context.fillRect(
              -modX + anchorX,
              -modY + anchorY,
              (this._width / this.tileScale.x) * baseTextureResolution,
              (this._height / this.tileScale.y) * baseTextureResolution
            );
          } else {
            context.translate(modX + anchorX, modY + anchorY);

            context.fillRect(
              -modX,
              -modY,
              (this._width / this.tileScale.x) * baseTextureResolution,
              (this._height / this.tileScale.y) * baseTextureResolution
            );
          }
        };

        /**
         * Updates the bounds of the tiling sprite.
         *
         * @private
         */

        TilingSprite.prototype._calculateBounds = function _calculateBounds() {
          var minX = this._width * -this._anchor._x;
          var minY = this._height * -this._anchor._y;
          var maxX = this._width * (1 - this._anchor._x);
          var maxY = this._height * (1 - this._anchor._y);

          this._bounds.addFrame(this.transform, m);
        };
      };
    },
  ]),
]);
